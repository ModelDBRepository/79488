// ta_Dump File v2.0
LeabraProject .projects[0] { 
Doc_Group @.docs = [1] {
taDoc @[0] { };
};

Wizard_Group @.wizards = [1] {
LeabraWizard @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};

LayerWizElList @.layer_cfg = [3] {
LayerWizEl @[0] { };
LayerWizEl @[1] { };
LayerWizEl @[2] { };
};
};
};

SelectEdit_Group @.edits = [1] {
SelectEdit @[0] { 
EditMbrItem_Group @.mbrs = [8] {
EditMbrItem @[0] { };
EditMbrItem @[1] { };
EditMbrItem @[2] { };
EditMbrItem @[3] { };
EditMbrItem @[4] { };
EditMbrItem @[5] { };
EditMbrItem @[6] { };
EditMbrItem @[7] { };
};
};
};

DataTable_Group @.data = [0] {
DataTable_Group @.gp[0] = [3] { 
DataTable @[0] { 
DataTableCols @.data = [2] {
String_Data @[0] { };
float_Data @[1] { };
};
};
DataTable @[1] { 
DataTableCols @.data = [5] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
};
};
DataTable @[2] { 
DataTableCols @.data = [5] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
};
};
};
DataTable_Group @.gp[1] = [3] { 
DataTable @[0] { 
DataTableCols @.data = [10] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
String_Data @[3] { };
String_Data @[4] { };
int_Data @[5] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[6] { };
float_Data @[7] { };
float_Data @[8] { };
float_Data @[9] { };
};
};
DataTable @[1] { 
DataTableCols @.data = [6] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
float_Data @[5] { };
};
};
DataTable @[2] { 
DataTableCols @.data = [16] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
String_Data @[3] { };
String_Data @[4] { };
int_Data @[5] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[6] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[7] { };
float_Data @[8] { };
float_Data @[9] { };
float_Data @[10] { };
float_Data @[11] { };
float_Data @[12] { };
float_Data @[13] { };
float_Data @[14] { };
float_Data @[15] { };
};
};
};
DataTable_Group @.gp[2] = [3] { 
DataTable @[0] { 
DataTableCols @.data = [4] {
float_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[3] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};
};
DataTable @[1] { 
DataTableCols @.data = [8] {
float_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[3] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[4] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[5] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[6] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[7] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};
};
DataTable @[2] { 
DataTableCols @.data = [2] {
float_Data @[0] { };
float_Data @[1] { };
};
};
};
};

taBase_Group @.data_proc = [4] {
taDataProc @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taDataAnal @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taDataGen @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taImageProc @[3] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};

Program_Group @.programs = [2] {
Program @[0] { 
ProgObjList @.objs = [2] {
ActBasedRF @[0] { };
DataTable @[1] { 
DataTableCols @.data = [9] {
float_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
float_Data @[5] { };
float_Data @[6] { };
float_Data @[7] { };
float_Data @[8] { };
};
};
};

ProgVar_List @.args = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgVar_List @.vars = [4] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
};

ProgEl_List @.init_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
};

ProgEl_List @.prog_code = [1] {
IfElse @[0] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
};

ProgEl_List @.false_code = [1] {
IfElse @[0] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};

ProgEl_List @.false_code = [1] {
MethodCall @[0] { };
};
};
};
};
};
};
Program @[1] { 
ProgVar_List @.args = [8] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
};

ProgVar_List @.vars = [7] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
};

ProgEl_List @.init_code = [1] {
IfReturn @[0] { };
};

ProgEl_List @.prog_code = [28] {
IfReturn @[0] { };
Comment @[1] { };
MiscCall @[2] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[3] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[4] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[5] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[6] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[7] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[8] { };
RegisterArgs @[9] { };
Comment @[10] { };
PrintExpr @[11] { };
ProgVarFmArg @[12] { };
MethodCall @[13] { };
MiscCall @[14] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MiscCall @[15] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
ProgVarFmArg @[16] { };
ProgVarFmArg @[17] { };
ProgVarFmArg @[18] { };
ProgVarFmArg @[19] { };
Comment @[20] { };
MethodCall @[21] { 
ProgArg_List @.meth_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
MethodCall @[22] { 
ProgArg_List @.meth_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
MethodCall @[23] { 
ProgArg_List @.meth_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
MethodCall @[24] { 
ProgArg_List @.meth_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
OtherProgramVar @[25] { };
PrintExpr @[26] { };
ProgramCall @[27] { 
ProgArg_List @.prog_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
};
};
Program_Group @.gp[0] = [18] { 
Program @[0] { 
ProgVar_List @.args = [4] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
};

ProgVar_List @.vars = [5] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
};

ProgEl_List @.init_code = [2] {
NetCounterInit @[0] { };
IfElse @[1] { 
ProgEl_List @.true_code = [2] {
AssignExpr @[0] { };
OtherProgramVar @[1] { };
};

ProgEl_List @.false_code = [2] {
AssignExpr @[0] { };
OtherProgramVar @[1] { };
};
};
};

ProgEl_List @.prog_code = [3] {
NetCounterInit @[0] { };
WhileLoop @[1] { 
ProgEl_List @.loop_code = [3] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
ProgramCall @[1] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[2] { };
};
};
DataCalcLoop @[2] { 
ProgEl_List @.loop_code = [1] {
UserScript @[0] { };
};
};
};
};
Program @[1] { 
ProgObjList @.objs = [1] {
RndSeed @[0] { };
};

ProgType_List @.types = [1] {
DynEnumType @[0] { 
DynEnumItem_List @.enums = [2] {
DynEnumItem @[0] { };
DynEnumItem @[1] { };
};
};
};

ProgVar_List @.args = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgVar_List @.vars = [18] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
ProgVar @[15] { };
ProgVar @[16] { };
ProgVar @[17] { };
};

ProgEl_List @.init_code = [6] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
AssignExpr @[2] { };
NetCounterInit @[3] { };
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};

ProgEl_List @.false_code = [1] {
MethodCall @[0] { };
};
};
IfGuiPrompt @[5] { 
ProgEl_List @.yes_code = [2] {
MethodCall @[0] { };
PrintExpr @[1] { };
};
};
};

ProgEl_List @.prog_code = [13] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
NetCounterInit @[2] { };
MemberAssign @[3] { };
MemberAssign @[4] { };
IfElse @[5] { 
ProgEl_List @.true_code = [2] {
MethodCall @[0] { };
PrintExpr @[1] { };
};
};
AssignExpr @[6] { };
ForLoop @[7] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
UserScript @[0] { };
};
};
};
};
OtherProgramVar @[8] { };
OtherProgramVar @[9] { };
MemberAssign @[10] { };
WhileLoop @[11] { 
ProgEl_List @.loop_code = [5] {
MemberAssign @[0] { };
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
NetCounterIncr @[2] { };
IfBreak @[3] { };
MemberAssign @[4] { };
};
};
MethodCall @[12] { };
};
};
Program @[2] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [5] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
};

ProgEl_List @.init_code = [2] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
};

ProgEl_List @.prog_code = [9] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[3] { };
NetDataLoop @[4] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
};
};
IfElse @[5] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
MethodCall @[6] { };
ProgramCall @[7] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[8] { };
};
};
Program @[3] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [15] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
};

ProgEl_List @.init_code = [4] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
AssignExpr @[3] { };
};

ProgEl_List @.prog_code = [17] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
MemberAssign @[3] { };
AssignExpr @[4] { };
MethodCall @[5] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[6] { };
AssignExpr @[7] { };
ProgramCall @[8] { 
ProgArg_List @.prog_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
AssignExpr @[9] { };
NetDataLoop @[10] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
};
};
IfElse @[11] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
MethodCall @[12] { };
ProgramCall @[13] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
ProgramCall @[14] { 
ProgArg_List @.prog_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
ProgramCall @[15] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[16] { };
};
};
Program @[4] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [6] {
NetCounterInit @[0] { };
MethodCall @[1] { };
WhileLoop @[2] { 
ProgEl_List @.loop_code = [4] {
UserScript @[0] { };
ProgramCall @[1] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[2] { };
MethodCall @[3] { };
};
};
MethodCall @[3] { };
ProgramCall @[4] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetUpdateView @[5] { };
};
};
Program @[5] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [4] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [7] {
NetCounterInit @[0] { };
MethodCall @[1] { };
WhileLoop @[2] { 
ProgEl_List @.loop_code = [4] {
UserScript @[0] { };
ProgramCall @[1] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[2] { };
MethodCall @[3] { };
};
};
MethodCall @[3] { };
ProgramCall @[4] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
ProgramCall @[5] { 
ProgArg_List @.prog_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
NetUpdateView @[6] { };
};
};
Program @[6] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [4] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [12] {
NetCounterInit @[0] { };
MethodCall @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
ProgramCall @[3] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MemberAssign @[0] { };
};

ProgEl_List @.false_code = [1] {
MemberAssign @[0] { };
};
};
MethodCall @[5] { };
IfElse @[6] { 
ProgEl_List @.true_code = [1] {
AssignExpr @[0] { };
};

ProgEl_List @.false_code = [1] {
AssignExpr @[0] { };
};
};
WhileLoop @[7] { 
ProgEl_List @.loop_code = [4] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetCounterIncr @[1] { };
IfContinue @[2] { };
IfBreak @[3] { };
};
};
MethodCall @[8] { };
IfElse @[9] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
IfElse @[10] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
NetUpdateView @[11] { };
};
};
Program @[7] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [12] {
NetCounterInit @[0] { };
MethodCall @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
ProgramCall @[3] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MemberAssign @[0] { };
};

ProgEl_List @.false_code = [1] {
MemberAssign @[0] { };
};
};
MethodCall @[5] { };
IfElse @[6] { 
ProgEl_List @.true_code = [1] {
AssignExpr @[0] { };
};

ProgEl_List @.false_code = [1] {
AssignExpr @[0] { };
};
};
WhileLoop @[7] { 
ProgEl_List @.loop_code = [4] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetCounterIncr @[1] { };
IfContinue @[2] { };
IfBreak @[3] { };
};
};
MethodCall @[8] { };
IfElse @[9] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
IfElse @[10] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
NetUpdateView @[11] { };
};
};
Program @[8] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.prog_code = [3] {
MethodCall @[0] { };
NetUpdateView @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
};
};
Program @[9] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.prog_code = [3] {
MethodCall @[0] { };
NetUpdateView @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
};
};
Program @[10] { 
ProgObjList @.objs = [1] {
LayerWriter @[0] { 
LayerDataEl_List @.layer_data = [5] {
LayerWriterEl @[0] { };
LayerWriterEl @[1] { };
LayerWriterEl @[2] { };
LayerWriterEl @[3] { };
LayerWriterEl @[4] { };
};
};
};

ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.init_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { };
};
};
Program @[11] { 
ProgObjList @.objs = [1] {
LayerWriter @[0] { 
LayerDataEl_List @.layer_data = [5] {
LayerWriterEl @[0] { };
LayerWriterEl @[1] { };
LayerWriterEl @[2] { };
LayerWriterEl @[3] { };
LayerWriterEl @[4] { };
};
};
};

ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.init_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { };
};
};
Program @[12] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [10] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
NetMonItem @[6] { };
NetMonItem @[7] { };
NetMonItem @[8] { };
NetMonItem @[9] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [3] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [4] {
MethodCall @[0] { };
MethodCall @[1] { };
MethodCall @[2] { };
MethodCall @[3] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[13] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [16] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
NetMonItem @[6] { };
NetMonItem @[7] { };
NetMonItem @[8] { };
NetMonItem @[9] { };
NetMonItem @[10] { };
NetMonItem @[11] { };
NetMonItem @[12] { };
NetMonItem @[13] { };
NetMonItem @[14] { };
NetMonItem @[15] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [3] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [5] {
IfReturn @[0] { };
MethodCall @[1] { };
MethodCall @[2] { };
MethodCall @[3] { };
MethodCall @[4] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[14] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [6] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgEl_List @.init_code = [4] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[3] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [4] {
MethodCall @[0] { };
MethodCall @[1] { };
AssignExpr @[2] { };
MethodCall @[3] { };
};
};
Program @[15] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [6] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
};

ProgEl_List @.prog_code = [6] {
IfReturn @[0] { };
MiscCall @[1] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[2] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
AssignExpr @[3] { };
MethodCall @[4] { 
ProgArg_List @.meth_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
MethodCall @[5] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[16] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [15] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
};

ProgEl_List @.prog_code = [6] {
AssignExpr @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
MemberAssign @[3] { };
MemberAssign @[4] { };
IfElse @[5] { 
ProgEl_List @.true_code = [4] {
IfElse @[0] { 
ProgEl_List @.true_code = [2] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
MemberAssign @[0] { };
};
};
MemberAssign @[1] { };
};

ProgEl_List @.false_code = [2] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
MemberAssign @[0] { };
};
};
MemberAssign @[1] { };
};
};
AssignExpr @[1] { };
AssignExpr @[2] { };
IfElse @[3] { 
ProgEl_List @.true_code = [6] {
MemberAssign @[0] { };
MemberAssign @[1] { };
MemberAssign @[2] { };
MemberAssign @[3] { };
MemberAssign @[4] { };
MemberAssign @[5] { };
};

ProgEl_List @.false_code = [6] {
MemberAssign @[0] { };
MemberAssign @[1] { };
MemberAssign @[2] { };
MemberAssign @[3] { };
MemberAssign @[4] { };
MemberAssign @[5] { };
};
};
};

ProgEl_List @.false_code = [5] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [2] {
MemberAssign @[0] { };
MemberAssign @[1] { };
};
};
MemberAssign @[1] { };
MemberAssign @[2] { };
MemberAssign @[3] { };
MemberAssign @[4] { };
};
};
};
};
Program @[17] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [15] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
};

ProgEl_List @.init_code = [1] {
ResetDataRows @[0] { };
};

ProgEl_List @.prog_code = [27] {
AssignExpr @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
AssignExpr @[3] { };
AssignExpr @[4] { };
AssignExpr @[5] { };
AssignExpr @[6] { };
AssignExpr @[7] { };
AssignExpr @[8] { };
AssignExpr @[9] { };
AssignExpr @[10] { };
AssignExpr @[11] { };
ForLoop @[12] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
ForLoop @[13] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
ForLoop @[14] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
ForLoop @[15] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
ForLoop @[16] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
ForLoop @[17] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
ForLoop @[18] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
ForLoop @[19] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
VarIncr @[0] { };
};
};
};
};
AssignExpr @[20] { };
AssignExpr @[21] { };
AssignExpr @[22] { };
AssignExpr @[23] { };
AddNewDataRow @[24] { };
DataVarProg @[25] { };
DoneWritingDataRow @[26] { };
};
};
};
};

DataViewer_List @.viewers = [1] {
MainWindowViewer @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
UserDataItem @[1] { };
UserDataItem @[2] { };
UserDataItem @[3] { };
UserDataItem @[4] { };
UserDataItem @[5] { };
};

ToolBar_List @.toolbars = [1] {
ToolBar @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};

FrameViewer_List @.frames = [3] {
tabBrowseViewer @[0] { };
PanelViewer @[1] { };
T3DataViewer @[2] { 
T3DataViewFrame_List @.frames = [5] {
T3DataViewFrame @[0] { 
T3DataView_List @.children = [1] {
NetView @[0] { 
ScaleRange_List @.scale_ranges = [18] {
ScaleRange @[0] { };
ScaleRange @[1] { };
ScaleRange @[2] { };
ScaleRange @[3] { };
ScaleRange @[4] { };
ScaleRange @[5] { };
ScaleRange @[6] { };
ScaleRange @[7] { };
ScaleRange @[8] { };
ScaleRange @[9] { };
ScaleRange @[10] { };
ScaleRange @[11] { };
ScaleRange @[12] { };
ScaleRange @[13] { };
ScaleRange @[14] { };
ScaleRange @[15] { };
ScaleRange @[16] { };
ScaleRange @[17] { };
};
};
};
};
T3DataViewFrame @[1] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [16] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
GraphColView @[6] { };
GraphColView @[7] { };
GraphColView @[8] { };
GraphColView @[9] { };
GraphColView @[10] { };
GraphColView @[11] { };
GraphColView @[12] { };
GraphColView @[13] { };
GraphColView @[14] { };
GraphColView @[15] { };
};
};
};
};
T3DataViewFrame @[2] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [6] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
};
};
};
};
T3DataViewFrame @[3] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [4] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
};
};
};
};
T3DataViewFrame @[4] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [8] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
GraphColView @[6] { };
GraphColView @[7] { };
};
};
};
};
};
};
};

DockViewer_List @.docks = [1] {
ToolBoxDockViewer @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
UserDataItem @[1] { };
UserDataItem @[2] { };
UserDataItem @[3] { };
UserDataItem @[4] { };
UserDataItem @[5] { };
};
};
};
};
};

Network_Group @.networks = [1] {
LeabraNetwork @[0] { 
BaseSpec_Group @.specs = [3] {
ConSpec @[0] { };
UniformRndPrjnSpec @[1] { };
UniformRndPrjnSpec @[2] { };
BaseSpec_Group @.gp[0] = [10] { 
FullPrjnSpec @[0] { };
OneToOnePrjnSpec @[1] { };
TesselPrjnSpec @[2] { 
BaseSpec_Group @.children = [1] {
TesselPrjnSpec @[0] { 
TessEl_List @.send_offs = [18] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
TessEl @[12] { };
TessEl @[13] { };
TessEl @[14] { };
TessEl @[15] { };
TessEl @[16] { };
TessEl @[17] { };
};
};
};

TessEl_List @.send_offs = [18] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
TessEl @[12] { };
TessEl @[13] { };
TessEl @[14] { };
TessEl @[15] { };
TessEl @[16] { };
TessEl @[17] { };
};
};
TesselPrjnSpec @[3] { 
TessEl_List @.send_offs = [9] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
};
};
TesselPrjnSpec @[4] { 
TessEl_List @.send_offs = [12] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
};
};
TesselPrjnSpec @[5] { 
TessEl_List @.send_offs = [2] {
TessEl @[0] { };
TessEl @[1] { };
};
};
TesselPrjnSpec @[6] { 
TessEl_List @.send_offs = [12] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
};
};
TesselPrjnSpec @[7] { 
TessEl_List @.send_offs = [9] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
};
};
TesselPrjnSpec @[8] { 
TessEl_List @.send_offs = [4] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
};
};
OneToOnePrjnSpec @[9] { };
};
BaseSpec_Group @.gp[1] = [7] { 
LeabraBiasSpec @[0] { 
BaseSpec_Group @.children = [1] {
LeabraBiasSpec @[0] { };
};
};
LeabraConSpec @[1] { };
LeabraConSpec @[2] { 
BaseSpec_Group @.children = [2] {
LeabraConSpec @[0] { };
LeabraConSpec @[1] { };
};
};
LeabraConSpec @[3] { 
BaseSpec_Group @.children = [7] {
LeabraConSpec @[0] { };
LeabraConSpec @[1] { };
LeabraConSpec @[2] { };
LeabraConSpec @[3] { };
LeabraConSpec @[4] { };
LeabraConSpec @[5] { };
LeabraConSpec @[6] { };
};
};
LeabraConSpec @[4] { };
LeabraConSpec @[5] { };
LeabraConSpec @[6] { };
};
BaseSpec_Group @.gp[2] = [2] { 
LeabraUnitSpec @[0] { 
BaseSpec_Group @.children = [5] {
LeabraUnitSpec @[0] { };
LeabraUnitSpec @[1] { };
LeabraUnitSpec @[2] { };
LeabraUnitSpec @[3] { 
BaseSpec_Group @.children = [3] {
LeabraUnitSpec @[0] { };
LeabraUnitSpec @[1] { 
Schedule @.noise_sched = [4] {
SchedItem @[0] { };
SchedItem @[1] { };
SchedItem @[2] { };
SchedItem @[3] { };
};
};
LeabraUnitSpec @[2] { };
};
};
LeabraUnitSpec @[4] { };
};
};
LeabraUnitSpec @[1] { };
};
BaseSpec_Group @.gp[3] = [2] { 
LeabraLayerSpec @[0] { 
BaseSpec_Group @.children = [7] {
LeabraLayerSpec @[0] { };
LeabraLayerSpec @[1] { };
LeabraLayerSpec @[2] { };
LeabraLayerSpec @[3] { };
LeabraLayerSpec @[4] { };
LeabraLayerSpec @[5] { };
LeabraLayerSpec @[6] { };
};
};
LeabraLayerSpec @[1] { 
BaseSpec_Group @.children = [2] {
LeabraLayerSpec @[0] { };
LeabraLayerSpec @[1] { };
};
};
};
};

Layer_Group @.layers = [9] {
LeabraLayer @[0] { 
Unit_Group @.units = [25] {
};
};
LeabraLayer @[1] { 
Projection_Group @.projections = [5] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
LeabraPrjn @[2] { };
LeabraPrjn @[3] { };
LeabraPrjn @[4] { };
};

Unit_Group @.units = [36] {
};
};
LeabraLayer @[2] { 
Unit_Group @.units = [4] {
};
};
LeabraLayer @[3] { 
Projection_Group @.projections = [3] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
LeabraPrjn @[2] { };
};

Unit_Group @.units = [4] {
};
};
LeabraLayer @[4] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[5] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[6] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [4] {
};
};
LeabraLayer @[7] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[8] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [9] {
};
};
};
};
};
};
LeabraProject .projects[0] {
name="Project_0";
desc="mtrNoGoGlut: stronger glutamate projns from ctx to NoGo (mGluR!)
nodecMat = no decay b/w phases in matrix, so can learn about recently active synapses
stnGPrnd2575: 25 = % con from STN-GPe 75 = % con from GPe to STN
noise in motor cortex, so after learning NOGO can try GO on other acton";
tags=;
templates {
name=;
el_typ=taBase;
el_def=0;
};
docs {
name=;
el_typ=taDoc;
el_def=0;
taDoc @[0] {
name="ProjectDocs";
auto_open=1;
text="<html>
<head></head>
<body>

= Probabilistic Go and NoGo Learning in the Basal Ganglia: Parkinson's and Medication Effects =


* GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in
the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  If your screen is small, you may also want to make this new window \"Always on Top\": e.g., in Linux, <code>Emergent-logo-at-top-left-></code> <code> Advanced-> Keep Above Others</code>).   Alternatively, you can always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.


This project replicates the basic effects of simulated Parkinson's disease and medications on striatal Go-NoGo associations in response to \"positive\" and \"negative\" stimuli, as described in Frank, Seeberger, O'Reilly (2004), which used the Frank (2005) model to predict behavioral dissociations in medicated and non-medicated patients.  Here the model includes the subthalamic nucleus, as described in Frank (2006), Neural Networks (the STN was omitted from the initial 2005 model for simplicity, but we thought it was important to replicate all the results with the more complete model, as is done here. The explicit contributions of the STN are explored elsewhere). The model uses identical parameters to those in the weather prediction and probabilistic reversal simulations.

The model is trained with four stimuli (A,B,C,D) each represented by a column of four input units. When stimulus A is presented, the model is rewarded for selecting R1 (\"approach\") on 80% of trials, and for selecting R2 (\"avoid\") on 20% of trials.  The opposite contingencies are  simulated for stimulus B, where R1 is incorrect on 80% of trials, while R2 is correct on these trials. Stimuli C and D are associated with 60% positive reinforcement for choosing R1 and R2 respectively.   (See the notes at the end for details on relating this choice of task representation to the empirical Probabilistic Selection task.) Rewards are associated with DA bursts that drive Go learning in the striatum to encode the stimulus-response-reinforcement conjunction. Non-rewarded trials are associated with DA dips that drive NoGo learning in the striatum so that it learns to suppress the non-rewarding response. 

Networks are trained for 10 epochs with this probabilistic structure before assessing relative Go and NoGo learning. After training, the LeabraTestEpoch presents all stimuli to the model one at a time, and computes Activation Based Receptive fields in the Striatum.  These record the degree to which units become activated by particular input patterns. 
(See http://www.cnbc.cmu.edu/Resources/PDP++/manual/pdp-user_176.html for more detailed info).  In this case, we are interested in the amount of learned striatal Go activity coding for good (positive) responses (R1 for stimulus A, and R2 for stimulus B). Similarly, we can also assess learned NoGo activity for bad (negative) responses (R2 for stimulus A and R1 for stimulus B). The main findings are that (i) intact networks learn both Go to positive responses and NoGo to negative responses, (ii) simulated PD leads to impaired Go learning but intact NoGo learning, and (iii) simulated DA medications lead to the opposite pattern, as found in our empirical studies.
  

The activation based RF's are computed by the <code> ActBasedRField </code> Program, which is called by <code>LeabraTestEpoch</code>. Normalized receptive fields are stored for each striatal unit in the <code>ActRFData</code> data table, which is a local object within the <code>ActBasedRField</code> Program.  

After the receptive fields for each unit are calculated, we then sum these over all Go units for the relevant stimuli and responses, so that we can calculate total striatal Go activity for 'good'  (most often rewarded) responses and subtract the total NoGo activity for these responses. This measure gives us the relative Go-NoGo learning achieved for positive responses, and is an index of positive feedback learning. Similarly, we can compute the total Go and NoGo activity for bad (least often rewarded) responses, and perform the same subtraction. In this case we expect relatively greater NoGo than Go activity after learning (so that the Go-NoGo difference should be negative, as an index of negative feedback learning). All of these computations occur in the <code>Calc_GoNoGo</code> Program. The resulting statistics are reported in the <code>Go_NoGo</code> data table,  as follows:

<b> gn_pos </b> computes relative Go-NoGo striatal activity for positive
stimulus-response conjunctions (R1 for A and R2 for B). Networks should learn greater Go than NoGo representations for these positive associations, so the value should be positive.

 
<b> gn_neg </b> computes relative Go-NoGo striatal activity for negative
stimulus-response conjunctions (R2 for A and R1 for B). Networks should learn greater NoGo representations for these negative associations, so the value should be negative. (Note that if plotting NoGo-Go
associations the sign should be flipped (i.e.the value is positive such that more positive values indicate better learning for both gn_pos and gn_neg), as was
done in Frank et al 2004 for comparison with behavioral accuracy results.)

PD networks should be impaired at positive Go learning (less positive gn_pos) and
medicated networks should be impaired at negative NoGo learning (less negative
gn_neg). These effects should be evident both when comparing the groups in the different conditions, or simply testing whether the gn_pos is significantly greater than zero (in PD nets) and whether gn_neg is significantly less than zero (in medicated nets).

<b> gn_A_R1 </b> and <b> gn_B_R1 </b> are somewhat redundant, and reflect Go-NoGo associations just for A-R1 conjunctions (should be positive) and B-R1 conjunctions (should be negative). These are what were used in our original paper, but both measures are valid and should show the same pattern.

 
== Running the networks ==

For intact network performance, make sure the number of intact SNc units is set to 4 (out of 4 units), the DA burst value is set to 1 (corresponding to maximal phasic burst firing rate) and the DA dip value is set to 0 (minimum phasic dip DA firing rate). These values are set in the  [[.PanelTab.MasterControl]] control panel.
 

To monitor performance across multiple networks, first save a Data Log file to store the data. Open the <code>data->AnalysisData subgroup</code> tree in the '''Tree''' window (far left) and click on <code>Go_NoGo</code> to display the data table (which is where the relative Go NoGo activity values are reported, as described above, with each row representing a single network). Click on <code>Object->Save Data Log</code>). Make sure to name this logfile with some reference to the current dopamine settings, so that you can properly interpret the data (e.g., name this 'Intact.dat').  To run a set of networks on the task, expand the <code> programs</code> tab in the \"Tree\" window on the far left, and then under <code> LeabraAll_Std_subgrpup</code>, click on the <code>LeabraBatch</code> object. Hit Init and Run on the bottom of the resulting [[.PanelTab.LeabraBatch]] panel that will open. This  will run a set of 50 networks, and store the data in the logfile you just created .
 

(To speed things up when running a batch of networks, turn off the display of the network by clicking on the appropriate tab that you want to view and check off the <code>Display!</code> box on the top left.)

Because the data are noisy (probabilistic rewards, noisy unit activity, combined with random initial synaptic weights), we need to average across multiple networks with different sets of initial weights.  This is done automatically at the end of running a batch of networks, with resulting mean and standard error of gn_pos and gn_neg reported in the <code>Go_NoGo_Group</code> data table and plotted in the associated bar graph on the right (click on it's tab).

(To analyze the data manually, from the [[.PanelTab.Go_NoGo]] data table, click on  <code>DataProc->Group Mean SEM</code>. In the dialog box that pops up, make sure the   <code>dest_data</code> is set to <code>New Data Table</code>; this will create a new output data log under the AnalysisData_subgroup in the left frame, called <code>Go_NoGo_Group</code>. Also set all the   <code>gp_col</code> fields to NULL,  and click <code>Ok</code>. Now open the new analysis  <code>Go_NoGo_Group</code> log. You should see the statistics (mean, standard error) for each variable that was monitored in the Go_NoGo table.)

You should see the correct patterns of results across the runs, where on average gn_pos is positive showing that positively rewarded stimulus-response combinations are associated with relatively greater Go than NoGo activity, wheras the opposite is true for responses that are more often associated with negative feedback (i.e., gn_neg should be negative, unless of course you have flipped the sign of it for plotting purposes!). This pattern will not hold for every individual network (due to random initial weights and noisy unit activity that might happen to favor, e.g., Go-B), just like it doesn't hold for every individual human participant. But you should see relatively more positive gn_pos than gn_neg in virtually every intact network, even if in some cases they are both positive or both negative -- to see gn_pos and gn_neg for individual networks look at the <code>Go_NoGo</code> data table and graph on the right, which plots these measures across networks on the x-axis).

== Simulating PD and DA meds ==

There are two ways to simulate PD in the model (see also the Weather Prediction task simulations in BG_WeatherPred.proj). The first way is to simply reduce the overall DA unit integrity (simulating cell death) by removing 3 out of 4 DA units from processing. The second way removes less units (2 out of 4) but also reduces that phasic burst firing capabilities of these remaining units.

First, set the number of intact DA units to 1 in the  [[.PanelTab.MasterControl]] control panel.  This sets the number of SNc units that are connected to the Striatum to 1 (out of 4). Note that the units themselves are not actually \"lesioned\" (removed) here. The reason for this is purely technical (Leabra normalizes net input to a given layer in proportion to the number of intact units in the sending layer; Equation 2.14, O'Reilly & Munakata (2000). If we reduced the number of DA units from 4 to 1, it would treat output from that unit as effectively four times stronger than output from a unit in a four unit layer. This normalization ensures that the total number of units in a layer doesn't parametrically affect downstream processing, which is useful for many neural net applications, but certainly not when we want to simulate effects of reduced output due to DA unit damage!)  To circumvent this issue we maintain the integrity of the DA units but instead simply eliminate the synaptic weights from 3 out of the 4 DA units to Striatum (test this by looking at the receiving weights from DA units to the Striatum -- you should see connectivity to only one out of four SNc units after setting this value and stepping through a trial). Don't be misled by the activation of all DA units after making this manipulation -- only the connected ones actually influence processing in the BG. This reduction in number of intact DA units  leads to effectively reduced tonic and phasic DA levels in the Striatum. 

Set a new log file name in the Go_NoGo object, and give it a new name (e.g, with a PD descriptor). Hit Init and Run on the LeabraBatch panel. When it's done, analyze the group mean and standard error as above. You should see a NoGo learning bias across networks, on average.

To simulate DA medication, set the number of intact DA units back to 4 units (to simulate the increase in DA synthesis due to levodopa) and simply check off the \"meds\" checkbox in the  [[.PanelTab.MasterControl]] control panel. This sets the DA dip value so that the SNc dopamine units are prevented from completely dropping to zero during negative outcomes (DA dips), as posited to arise from the tonic stimulation of levodopa and especially D2 agonists  taken by most PD patients, onto D2 receptors in the NoGo pathway, even if DA neurons themselves actually stop firing (see Frank, 2005).  (Specifically, the net input to DA cells is set to a minimum of .024 during negative outcomes, which still allows DA levels to 'dip' relative to the tonic value of .03, but less so than the intact case, where DA values can dip to 0, although this is dependent on sufficiently long DA neuron pause durations; see the \"Role of the DA pause\" below).
 
Set a new log file name in the Go_NoGo object, and give it a new name (e.g, with a DA_meds descriptor). Hit Init and Run on the LeabraBatch panel. When it's finished, analyze the group mean and standard error as above. You should see that medicated networks are  impaired at NoGo  learning (ie. they show less negative gn_neg values) compared to intact networks, due to a reduced ability to learn NoGo, and similar to the probabilsitic reversal simulations (Frank, 2005; see also  Cools, Altamirano, & D'Esposito, 2006). 

== Reducing Phasic DA bursts ==

As in the weather prediction task simulations, Parkinson-like Go learning deficits can also be captured with other ways of reducing the fidelity of DA signals. For example, if you reduce the magnitude of the phasic DA burst in a network with less damage to DA units themselves, you should see somewhat reduced  Go learning (compared to the intact state) but intact NoGo learning. This result is similar to the finding that healthy participants given low dose dopaminergic drugs which act to reduce phasic bursting (via presynaptic autoreceptor stimulation), show reduced Go learning in the probabilistic selection task (Frank & O'Reilly, 2006) and in other reinforcement learning tasks (Pizzagalli et al, 2008).

To see this, set the num_intact_snc_units to 2 and reduce the \"DA burst real val\" to 0.04 instead of 1. (This value is the net input applied to the DA units and does NOT reflect the activation (firing rate) of the unit itself, which is a nonlinear function of this input. A DA burst net input of .04 corresponds to a phasic firing rate of roughly 0.8 -- still a burst relative to the tonic level (.03 net input, ~0.5 firing rate) but represents a reduction in phasic bursting compared to the maximal burst firing rate value of 1.0. Run a batch of networks, and you should see relatively reduced Go learning but intact NoGo learning.
 
== Role of the DA Pause ==

Some have argued that while phasic DA bursts encode positive predictions errors,  DA dips may not be functionally effective,  due to already low baseline firing rates of DA cells (e.g., Bayer & Glincher, 2005). However, the smaller range of DA dips is likely compensated for by a counteracting asymmetry in the receptor <i> sensitivity </i> to dips versus bursts.  In particular, because DA binds much more strongly to D2 than D1 class of receptors,  high-affinity D2 receptors are very sensitive to low tonic DA  levels, whereas large increases in DA are required to functionally stimulate D1 receptors (e.g., Goto & Grace, 2005).  Thus D2 receptors may be very sensitive to decreases in DA firing during DA dips, which drive NoGo learning in out model. Supporting this account, synaptic plasticity studies show that corticostriatal NoGo synapses are potentiated in the absence of D2 receptor stimulation, and this effect is exaggerated by DA depletion induced by a rodent model of Parkinson's disease, but reverse by D2 agonist administration  (Shen et al, 2008) -- precisely the same pattern of results seen as in human Parkinson's patients on and off DA medications on NoGo learning in the probabilistic task. Further,  in healthy subjects, genetic factors controlling striatal D2 receptor are strongly predictive of individual differences in probabilistic NoGo learning (Frank et al, 2007; Klein et al, 2007). 

Moreover, recent evidence shows that the magnitude of negative prediction errors is correlated with the <i> duration </i> of DA pauses, rather than in the change in firing rates (Bayer, Lau & Glimcher, 2007).  The BG model provides a plausible explanation for why this might be the case:  in order to learn from DA dips there has to be sufficient time not just for DA neurons to stop firing, but for DA levels  to be cleared from the synapse so that NoGo neurons can be disinhibited. Given a halflife of ~75 ms in dorsal striatum (Gonon, 1997), DA pauses for negative prediction errors lasting up to 350ms would give more than enough time for this signal to be functionally effective. Thus the longer the pause, the greater probability that a given D2 receptor will be unoccupied, and the stronger the learning signal.

To see this in the model, in the [[.PanelTab.MasterControl]] control panel, change the \"burst/pause duration\" from 30 cycles to 10 cycles (or lower for more dramatic effects).  This reduces the number of processing cycles in the reinforcement phase during which simulated DA levels change to their phasic value and drive Go or NoGo learning relative to tonic DA levels (which hold during response selection, prior to feedback).  Make sure all other settings are default (intact): maximal DA bursts (1.0), all 4 SNc units connected, no meds. If you re-run the intact network with this shorter burst/pause duration, you should see that Go learning is spared, but the model shows NoGo learning deficits!  This is because there has to be sufficient time for the SNc DA units to deactivate, and for the NoGo units to become disinhibited. The time course of this is dependent on the integration of membrane potentials and sluggishness of the neurons in the model, which is a crude approximation of the temporal dynamics associated with DA reuptake and NoGo unit disinhibition. In contrast, although this setting also led to corresponding shortening of the duration of DA bursts, you should see that Go learning is preserved. This is because the Go units that participated in selecting the response were already activated and simply got an additional boost of activity from the phasic burst. Thus together with the above simulations regarding the effects of diminishing the magnitude of DA bursts, the model demonstrates that large changes in DA firing rates during bursts are necessary for robust Go learning, but that long <I>duration</I> DA pauses are required for NoGo learning. It is encouraging that the DA signals seem to follow this profile empirically!


= PD Tremor, and Oscillations =
With very low DA levels, you may also see  some oscillations in STN and GP layers (these correspond to Parkinson's tremor; see Frank, 2006 for detailed discussion). You can look at these more carefully in the [[.T3Tab.CycleOutputData]]  graph logs where activity levels of the various layers are recorded. The easiest way to see this is to set the tonic DA value to 0 instead of the default .03 on the [[.PanelTab.MasterControl]] control panel. This will eliminate all tonic DA unit activity during response selection (note this would not work for simulating PD in general because it still allows for maximal phasic DA burst firing during rewards). Then increase the number of cycles that the network processes in each test trial so that you have more room to see oscillations -- change the \"test cycles\" value from 20  to 200. Now  Run a few trials using the <code>LeabraTestEpoch</code> process, and watch the activity levels of the STN and GP in the [[.T3Tab.CycleOutputData]] graph log. You might have to run more than one trial to see the oscillations, which should not (or only rarely) be seen at  in the intact state.  (Note that the same oscillations will be seen in the standard way of simulating PD above, by reducing the num_intact_snc_units to 1, but in that case you have to first Init and step through a trial in the Batch or Train process,  where the code for removal of DA connections is executed, before running the Test trials to observe unit activity across cycles in the CycleOutputData graph. The latter  is configured only to plot activity during test trials).

== Additional Notes and Relations to the Empirical Task ==

1. The full ABCDEF structure of the empirical probabilistic selection task is not simulated here, but would produce the same results. We are interested in the extent to which the model learns Go vs NoGo to stimuli A and B. With the model, we can directly probe the learned Go and NoGo representations in response to each stimulus in the Striatum.  This is not the case in humans (even in neuroimaging studies where it is impossible to disentangle Go vs NoGo activity, given that the cells are intermingled). Thus the behavioral paradigm requires a test phase to reveal whether individuals learned more positive associations to stimulus A or negative associations to stimulus B, by re-presenting these stimuli together with several more neutral stimuli C,D,E,F, collectively having 50% reward value. Go learning is inferred by choice of A over these neutral stimuli, wheras NoGo learning reflects avoidance of stimulus B relative to the neutral stimuli. In addition, using six  stimuli in the behavioral experiment is helpful for preventing participants from explicitly keeping track of all the different stimulus-outcome associations in working memory, which we think encourages more implicit reinforcement integration. This issue is not present in this basic BG model, which does not have working memory or rule-based strategies, but see O'Reilly & Frank 2006 and Frank & Claus 2006 for BG interactions with prefrontal working memory. 

2. In the model we present one stimulus at a time (A, B etc) and allow the model to choose a particular response (R1 or R2 which can be mapped on to approach and avoid). In the empirical task, participants are presented with two stimuli at a time and have to select one of them, with the actual stimulus locations counterabalanced across trials. The only reason we did not implement this in the model is that it is not equipped with a visual object recognition system that would be necessary for the model to 'know' that stimulus A presented on the left (corresponding to a particular set of input units) is the same stimulus A when presented on the right (another set of input units). Thus as far as the model is concerned, if A and B were presented together simultaneously, their collective input representation is identical to a single combined stimulus. Indeed, one can recast the current simulations such that the stimulus 'A' represented by four input units (depicted above) is really the same as 'AB' in which case the bottom two units represent A and the top two represent B. In that case, R1 would correspond to selecting A and R2 to selecting B, and the same Go/NoGo analysis described above applies identically. Similarly, stimulus B as originally defined above would correspond to simply another two stimuli (C and D) in which R1 corresponds to selecting C, and R2 D, and D is correct on 80% of trials. 

3. Note that for the activation based recepive field analysis each test trial is only run for 20 cycles. This is not enough time for a given response to be selected by the BG, and thus this setting will not work when measuring network 'behavioral' performance (in which case the maximum cycles run are 100). We stop settling early here because we are interested in the striatal Go/NoGo activations during the settling process, rather than after a response is already chosen, and  because NoGo activation to a particular stimulus-response conjunction is typically followed by facilitation (Go) of the alternative response. Once this response is selected (ie. fully active in motor cortex), lateral inhibition within cortex completely suppresses activation of the competing response, such that its corresponding striatal (Go and NoGo) representations also vanish (as these depend on excitatory cortical input). Thus the most valid assessment of the NoGo activity allowing the network to avoid a particular response must occur during the settling process itself, prior to response selection. 20 cycles gives roughly enough time to process the incoming stimulus and leads to differential striatal activation while both responses are still being \"considered\" (activated) in cortex.


</body>
</html>
";
};
};
wizards {
name=;
el_typ=LeabraWizard;
el_def=0;
LeabraWizard @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="LeabraWizard_2";
auto_open=0;
n_layers=3;
layer_cfg {
name=;
el_typ=LayerWizEl;
el_def=0;
LayerWizEl @[0] {
name="LayerWizEl";
n_units=25;
io_type=76;
};
LayerWizEl @[1] {
name="LayerWizEl";
n_units=25;
io_type=INPUT;
};
LayerWizEl @[2] {
name="LayerWizEl";
n_units=25;
io_type=7274496;
};
};
connectivity=BIDIRECTIONAL;
default_net_type=LeabraNetwork;
};
};
edits {
name=;
el_typ=SelectEdit;
el_def=0;
SelectEdit @[0] {
name="MasterControl";
auto_edit=1;
desc=;
mbrs {
name=;
el_typ=EditMbrItem;
el_def=0;
EditMbrItem @[0] {
label="tonic DA ";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[11]$0$;
mbr=ProgVar::real_val;
};
EditMbrItem @[1] {
label="DA burst ";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[14]$1$;
mbr=ProgVar::real_val;
};
EditMbrItem @[2] {
label="DA dip";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[13]$2$;
mbr=ProgVar::real_val;
};
EditMbrItem @[3] {
label="num intact snc units ";
desc=" integer value (also for enum types)";
base=.projects[0].programs.gp[0][1].vars[12]$3$;
mbr=ProgVar::int_val;
};
EditMbrItem @[4] {
label="minus phase cycles";
desc=" the expression to compute and assign to the member<br>  :  enter the expression here -- you can just type in names of program variables or literal values. enclose strings in double quotes. variable names will be checked and automatically updated<br>  var lookup!:  lookup a program variable and add it to the current expression (this field then returns to empty/NULL)<br>  enum lookup!:  lookup a dynamic enum variable and add it to the current expression (this field then returns to empty/NULL)";
base=.projects[0].programs.gp[0][6].prog_code[4].false_code[0]$4$;
mbr=MemberAssign::expr;
};
EditMbrItem @[5] {
label="meds ";
desc=" boolean value";
base=.projects[0].programs.gp[0][0].vars[1]$5$;
mbr=ProgVar::bool_val;
};
EditMbrItem @[6] {
label="test cycles";
desc=" the expression to compute and assign to the member<br>  :  enter the expression here -- you can just type in names of program variables or literal values. enclose strings in double quotes. variable names will be checked and automatically updated<br>  var lookup!:  lookup a program variable and add it to the current expression (this field then returns to empty/NULL)<br>  enum lookup!:  lookup a dynamic enum variable and add it to the current expression (this field then returns to empty/NULL)";
base=.projects[0].programs.gp[0][7].prog_code[4].false_code[0]$6$;
mbr=MemberAssign::expr;
};
EditMbrItem @[7] {
label="burst/pause duration ";
desc=" the expression to compute and assign to the member<br>  :  enter the expression here -- you can just type in names of program variables or literal values. enclose strings in double quotes. variable names will be checked and automatically updated<br>  var lookup!:  lookup a program variable and add it to the current expression (this field then returns to empty/NULL)<br>  enum lookup!:  lookup a dynamic enum variable and add it to the current expression (this field then returns to empty/NULL)";
base=.projects[0].programs.gp[0][6].prog_code[4].true_code[0]$7$;
mbr=MemberAssign::expr;
};
};
mths {
name=;
el_typ=EditMthItem;
el_def=0;
group_type=GT_BUTTONS;
};
};
};
data {
name=;
el_typ=DataTable;
el_def=0;
DataTable_Group @.gp[0] {
name="InputData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="RF_Env";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[36] "Striatum.un[0]";"Striatum.un[1]";"Striatum.un[2]";"Striatum.un[3]";"Striatum.un[4]";"Striatum.un[5]";"Striatum.un[6]";"Striatum.un[7]";"Striatum.un[8]";"Striatum.un[9]";"Striatum.un[10]";"Striatum.un[11]";"Striatum.un[12]";"Striatum.un[13]";"Striatum.un[14]";"Striatum.un[15]";"Striatum.un[16]";"Striatum.un[17]";"Striatum.un[18]";"Striatum.un[19]";"Striatum.un[20]";"Striatum.un[21]";"Striatum.un[22]";"Striatum.un[23]";"Striatum.un[24]";"Striatum.un[25]";"Striatum.un[26]";"Striatum.un[27]";"Striatum.un[28]";"Striatum.un[29]";"Striatum.un[30]";"Striatum.un[31]";"Striatum.un[32]";"Striatum.un[33]";"Striatum.un[34]";"Striatum.un[35]";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 36] 0.0020658399;0.027912499;0.00137255;1.8098601e-05;0;0.0020658399;0.027912499;0.00137255;1.8098601e-05;0;0.0020658399;0.027912499;0.00137255;1.8098601e-05;0;0.0020658399;0.027912499;0.00137255;1.8098601e-05;0;0;0;0;0;0;0.0310445;0.15307499;7.62914e-07;0.0155913;0;0.0310445;0.15307499;7.62914e-07;0.0155913;0;0.0310445;0.15307499;7.62914e-07;0.0155913;0;0.0310445;0.15307499;7.62914e-07;0.0155913;0;0;0;0;0;0;0.30409101;0.136353;0.032774601;2.4158101e-06;0;0.30409101;0.136353;0.032774601;2.4158101e-06;0;0.30409101;0.136353;0.032774601;2.4158101e-06;0;0.30409101;0.136353;0.032774601;2.4158101e-06;0;0;0;0;0;0;1.45115e-10;1.9908599e-08;1.1082e-08;0.0716919;0;1.45115e-10;1.9908599e-08;1.1082e-08;0.0716919;0;1.45115e-10;1.9908599e-08;1.1082e-08;0.0716919;0;1.45115e-10;1.9908599e-08;1.1082e-08;0.0716919;0;0;0;0;0;0;4.7102e-07;8.2514397e-08;5.07108e-09;4.03753e-10;0;4.7102e-07;8.2514397e-08;5.07108e-09;4.03753e-10;0;4.7102e-07;8.2514397e-08;5.07108e-09;4.03753e-10;0;4.7102e-07;8.2514397e-08;5.07108e-09;4.03753e-10;0;0;0;0;0;0;4.46938e-07;8.2186498e-06;3.2926201e-10;8.1646504e-05;0;4.46938e-07;8.2186498e-06;3.2926201e-10;8.1646504e-05;0;4.46938e-07;8.2186498e-06;3.2926201e-10;8.1646504e-05;0;4.46938e-07;8.2186498e-06;3.2926201e-10;8.1646504e-05;0;0;0;0;0;0;0.065097399;0.23739199;0;0.026730699;0;0.065097399;0.23739199;0;0.026730699;0;0.065097399;0.23739199;0;0.026730699;0;0.065097399;0.23739199;0;0.026730699;0;0;0;0;0;0;0.297351;0.0160699;0.080513798;0.00239517;0;0.297351;0.0160699;0.080513798;0.00239517;0;0.297351;0.0160699;0.080513798;0.00239517;0;0.297351;0.0160699;0.080513798;0.00239517;0;0;0;0;0;0;0.119379;0.0379465;0.0025241601;4.24338e-07;0;0.119379;0.0379465;0.0025241601;4.24338e-07;0;0.119379;0.0379465;0.0025241601;4.24338e-07;0;0.119379;0.0379465;0.0025241601;4.24338e-07;0;0;0;0;0;0;0.00051168102;1.7507499e-08;0.42471701;0.00045545201;0;0.00051168102;1.7507499e-08;0.42471701;0.00045545201;0;0.00051168102;1.7507499e-08;0.42471701;0.00045545201;0;0.00051168102;1.7507499e-08;0.42471701;0.00045545201;0;0;0;0;0;0;0.00190418;1.18174e-08;0.033827901;0.42598599;0;0.00190418;1.18174e-08;0.033827901;0.42598599;0;0.00190418;1.18174e-08;0.033827901;0.42598599;0;0.00190418;1.18174e-08;0.033827901;0.42598599;0;0;0;0;0;0;0.27970001;0.42425999;0.24604;7.1675402e-13;0;0.27970001;0.42425999;0.24604;7.1675402e-13;0;0.27970001;0.42425999;0.24604;7.1675402e-13;0;0.27970001;0.42425999;0.24604;7.1675402e-13;0;0;0;0;0;0;0.406872;1.55243e-12;1.37487e-05;0.22317401;0;0.406872;1.55243e-12;1.37487e-05;0.22317401;0;0.406872;1.55243e-12;1.37487e-05;0.22317401;0;0.406872;1.55243e-12;1.37487e-05;0.22317401;0;0;0;0;0;0;0.000373872;2.37976e-06;0.0064154901;4.4448901e-14;0;0.000373872;2.37976e-06;0.0064154901;4.4448901e-14;0;0.000373872;2.37976e-06;0.0064154901;4.4448901e-14;0;0.000373872;2.37976e-06;0.0064154901;4.4448901e-14;0;0;0;0;0;0;0.42959401;0.00262347;4.86824e-06;0.00026277499;0;0.42959401;0.00262347;4.86824e-06;0.00026277499;0;0.42959401;0.00262347;4.86824e-06;0.00026277499;0;0.42959401;0.00262347;4.86824e-06;0.00026277499;0;0;0;0;0;0;0.099185102;1.72989e-11;1.32198e-08;0.061239399;0;0.099185102;1.72989e-11;1.32198e-08;0.061239399;0;0.099185102;1.72989e-11;1.32198e-08;0.061239399;0;0.099185102;1.72989e-11;1.32198e-08;0.061239399;0;0;0;0;0;0;0.00063980499;0.0120797;3.4228599e-16;0.000113398;0;0.00063980499;0.0120797;3.4228599e-16;0.000113398;0;0.00063980499;0.0120797;3.4228599e-16;0.000113398;0;0.00063980499;0.0120797;3.4228599e-16;0.000113398;0;0;0;0;0;0;3.33909e-06;4.2428799e-13;1.6090001e-11;0.00039924399;0;3.33909e-06;4.2428799e-13;1.6090001e-11;0.00039924399;0;3.33909e-06;4.2428799e-13;1.6090001e-11;0.00039924399;0;3.33909e-06;4.2428799e-13;1.6090001e-11;0.00039924399;0;0;0;0;0;0;1.1571e-05;0.25993499;1.76055e-07;0.037213799;0;1.1571e-05;0.25993499;1.76055e-07;0.037213799;0;1.1571e-05;0.25993499;1.76055e-07;0.037213799;0;1.1571e-05;0.25993499;1.76055e-07;0.037213799;0;0;0;0;0;0;0.0091469297;0;5.06449e-05;3.6560099e-08;0;0.0091469297;0;5.06449e-05;3.6560099e-08;0;0.0091469297;0;5.06449e-05;3.6560099e-08;0;0.0091469297;0;5.06449e-05;3.6560099e-08;0;0;0;0;0;0;0.0019582801;1.7271699e-05;0.00040164401;0.038839702;0;0.0019582801;1.7271699e-05;0.00040164401;0.038839702;0;0.0019582801;1.7271699e-05;0.00040164401;0.038839702;0;0.0019582801;1.7271699e-05;0.00040164401;0.038839702;0;0;0;0;0;0;0.0318661;0.00268858;1.39783e-05;0.0058977599;0;0.0318661;0.00268858;1.39783e-05;0.0058977599;0;0.0318661;0.00268858;1.39783e-05;0.0058977599;0;0.0318661;0.00268858;1.39783e-05;0.0058977599;0;0;0;0;0;0;0.37554801;0.0036525;1.27594e-08;1.63549e-07;0;0.37554801;0.0036525;1.27594e-08;1.63549e-07;0;0.37554801;0.0036525;1.27594e-08;1.63549e-07;0;0.37554801;0.0036525;1.27594e-08;1.63549e-07;0;0;0;0;0;0;0.085854098;0.33838001;0.390661;3.6511301e-18;0;0.085854098;0.33838001;0.390661;3.6511301e-18;0;0.085854098;0.33838001;0.390661;3.6511301e-18;0;0.085854098;0.33838001;0.390661;3.6511301e-18;0;0;0;0;0;0;0.143585;0.000421873;0.00086137297;2.27483e-07;0;0.143585;0.000421873;0.00086137297;2.27483e-07;0;0.143585;0.000421873;0.00086137297;2.27483e-07;0;0.143585;0.000421873;0.00086137297;2.27483e-07;0;0;0;0;0;0;7.6498097e-08;0.00616829;0.0050247698;5.06942e-09;0;7.6498097e-08;0.00616829;0.0050247698;5.06942e-09;0;7.6498097e-08;0.00616829;0.0050247698;5.06942e-09;0;7.6498097e-08;0.00616829;0.0050247698;5.06942e-09;0;0;0;0;0;0;2.34197e-11;0.31961;2.0409299e-08;0.41610399;0;2.34197e-11;0.31961;2.0409299e-08;0.41610399;0;2.34197e-11;0.31961;2.0409299e-08;0.41610399;0;2.34197e-11;0.31961;2.0409299e-08;0.41610399;0;0;0;0;0;0;0.015832599;1.66713e-05;0.00074013497;0.029162901;0;0.015832599;1.66713e-05;0.00074013497;0.029162901;0;0.015832599;1.66713e-05;0.00074013497;0.029162901;0;0.015832599;1.66713e-05;0.00074013497;0.029162901;0;0;0;0;0;0;0.00010524;0.0136846;1.57776e-09;0.00233615;0;0.00010524;0.0136846;1.57776e-09;0.00233615;0;0.00010524;0.0136846;1.57776e-09;0.00233615;0;0.00010524;0.0136846;1.57776e-09;0.00233615;0;0;0;0;0;0;0.064751297;3.1768799e-16;1.16833e-06;4.0101301e-14;0;0.064751297;3.1768799e-16;1.16833e-06;4.0101301e-14;0;0.064751297;3.1768799e-16;1.16833e-06;4.0101301e-14;0;0.064751297;3.1768799e-16;1.16833e-06;4.0101301e-14;0;0;0;0;0;0;2.1050299e-08;0.18277401;3.5982799e-07;2.67466e-06;0;2.1050299e-08;0.18277401;3.5982799e-07;2.67466e-06;0;2.1050299e-08;0.18277401;3.5982799e-07;2.67466e-06;0;2.1050299e-08;0.18277401;3.5982799e-07;2.67466e-06;0;0;0;0;0;0;4.70537e-06;0.39089301;5.61411e-05;1.93715e-05;0;4.70537e-06;0.39089301;5.61411e-05;1.93715e-05;0;4.70537e-06;0.39089301;5.61411e-05;1.93715e-05;0;4.70537e-06;0.39089301;5.61411e-05;1.93715e-05;0;0;0;0;0;0;3.6449401e-07;0.089969203;3.9199999e-06;0;0;3.6449401e-07;0.089969203;3.9199999e-06;0;0;3.6449401e-07;0.089969203;3.9199999e-06;0;0;3.6449401e-07;0.089969203;3.9199999e-06;0;0;0;0;0;0;0;0.0183989;0.034914002;0.00093284401;0.00052059599;0;0.0183989;0.034914002;0.00093284401;0.00052059599;0;0.0183989;0.034914002;0.00093284401;0.00052059599;0;0.0183989;0.034914002;0.00093284401;0.00052059599;0;0;0;0;0;0;0.0036955499;0.0049556601;8.6473602e-18;0.35611901;0;0.0036955499;0.0049556601;8.6473602e-18;0.35611901;0;0.0036955499;0.0049556601;8.6473602e-18;0.35611901;0;0.0036955499;0.0049556601;8.6473602e-18;0.35611901;0;0;0;0;0;0;0.284251;5.0267399e-06;0.427347;0.070759498;0;0.284251;5.0267399e-06;0.427347;0.070759498;0;0.284251;5.0267399e-06;0.427347;0.070759498;0;0.284251;5.0267399e-06;0.427347;0.070759498;0;0;0;0;0;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[1] {
name="TestFreq";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[4] "80";"80";"60";"60";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 4] 1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 4] 1;0;0;1;1;0;0;1;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 4] 0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 4] 0;0;0;0;0;0;0;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[2] {
name="Train_Freq";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[40] "80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"40vs60";"40vs60";"40vs60";"80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"40vs60";"40vs60";"40vs60";"40vs60";"40vs60";"40vs60";"40vs60";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 40] 1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 40] 1;0;1;0;1;0;1;0;0;1;0;1;0;1;1;0;1;0;1;0;1;0;1;0;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 40] 100;100;100;100;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0;0;0;0;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;100;100;100;100;100;100;100;100;0;0;0;0;0;0;0;0;100;100;100;100;100;100;100;100;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 40] 1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
DataTable_Group @.gp[1] {
name="OutputData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="TrialOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="trial";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
String_Data @[3] {
name="trial_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
String_Data @[4] {
name="group_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[5] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="phase_no";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[6] {
name="minus_cycles";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[7] {
name="sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[8] {
name="ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[9] {
name="Output_sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[1] {
name="EpochOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[2] {
name="avg_sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[3] {
name="avg_ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[4] {
name="avg_cycles";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[5] {
name="cnt_err";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[2] {
name="CycleOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="trial";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
String_Data @[3] {
name="trial_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
String_Data @[4] {
name="group_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[5] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="phase_no";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[6] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="cycle";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[7] {
name="sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[8] {
name="ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[9] {
name="STN_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[10] {
name="Motor__acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[11] {
name="Thalam_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[12] {
name="GP_Int_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[13] {
name="GP_Ext_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[14] {
name="Output_act";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
};
float_Data @[15] {
name="Output_units_0_act";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
};
data_flags=AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
DataTable_Group @.gp[2] {
name="AnalysisData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="Go_NoGo";
desc=;
data {
name="data";
el_typ=float_Data;
el_def=0;
float_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_pos";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_neg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_A_R1";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[3] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_B_R1";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[1] {
name="Go_NoGo_Group";
desc=;
data {
name="data";
el_typ=DataColTp;
el_def=0;
float_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_pos_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 3.6923075;};
};
float_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_pos_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 1.1512791;};
};
float_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_neg_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] -0.47660509;};
};
float_Data @[3] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_neg_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 1.8066258;};
};
float_Data @[4] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_A_R1_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 1.8461537;};
};
float_Data @[5] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_A_R1_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 0.73245412;};
};
float_Data @[6] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_B_R1_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] -0.92307681;};
};
float_Data @[7] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_panel_wd";
value 6 0=0.2028397565922921;
};
};
name="gn_B_R1_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 1.0282018;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[2] {
name="Motor_Cortex_unitspec_ActFmNetFun";
desc=;
data {
name="data";
el_typ=float_Data;
el_def=0;
float_Data @[0] {
name="Net";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1001] 0;0.001;0.0020000001;0.003;0.0040000002;0.0050000004;0.0060000005;0.0070000007;0.0080000004;0.0090000005;0.010000001;0.011000001;0.012000001;0.013000001;0.014000001;0.015000002;0.016000001;0.017000001;0.018000001;0.019000001;0.020000001;0.021000002;0.022000002;0.023000002;0.024000002;0.025000002;0.026000002;0.027000003;0.028000003;0.029000003;0.030000003;0.031000003;0.032000002;0.033;0.033999998;0.034999996;0.035999995;0.036999993;0.037999991;0.03899999;0.039999988;0.040999986;0.041999985;0.042999983;0.043999981;0.044999979;0.045999978;0.046999976;0.047999974;0.048999973;0.049999971;0.050999969;0.051999968;0.052999966;0.053999964;0.054999962;0.055999961;0.056999959;0.057999957;0.058999956;0.059999954;0.060999952;0.061999951;0.062999949;0.063999951;0.064999953;0.065999955;0.066999957;0.067999959;0.068999961;0.069999963;0.070999965;0.071999967;0.072999969;0.073999971;0.074999973;0.075999975;0.076999977;0.077999979;0.078999981;0.079999983;0.080999985;0.081999987;0.082999989;0.083999991;0.084999993;0.085999995;0.086999997;0.088;0.089000002;0.090000004;0.091000006;0.092000008;0.09300001;0.094000012;0.095000014;0.096000016;0.097000018;0.09800002;0.099000022;0.10000002;0.10100003;0.10200003;0.10300003;0.10400003;0.10500003;0.10600004;0.10700004;0.10800004;0.10900004;0.11000004;0.11100005;0.11200005;0.11300005;0.11400005;0.11500005;0.11600006;0.11700006;0.11800006;0.11900006;0.12000006;0.12100007;0.12200007;0.12300007;0.12400007;0.12500007;0.12600008;0.12700008;0.12800008;0.12900008;0.13000008;0.13100009;0.13200009;0.13300009;0.13400009;0.13500009;0.1360001;0.1370001;0.1380001;0.1390001;0.1400001;0.14100011;0.14200011;0.14300011;0.14400011;0.14500012;0.14600012;0.14700012;0.14800012;0.14900012;0.15000013;0.15100013;0.15200013;0.15300013;0.15400013;0.15500014;0.15600014;0.15700014;0.15800014;0.15900014;0.16000015;0.16100015;0.16200015;0.16300015;0.16400015;0.16500016;0.16600016;0.16700016;0.16800016;0.16900016;0.17000017;0.17100017;0.17200017;0.17300017;0.17400017;0.17500018;0.17600018;0.17700018;0.17800018;0.17900018;0.18000019;0.18100019;0.18200019;0.18300019;0.18400019;0.1850002;0.1860002;0.1870002;0.1880002;0.1890002;0.19000021;0.19100021;0.19200021;0.19300021;0.19400021;0.19500022;0.19600022;0.19700022;0.19800022;0.19900022;0.20000023;0.20100023;0.20200023;0.20300023;0.20400023;0.20500024;0.20600024;0.20700024;0.20800024;0.20900024;0.21000025;0.21100025;0.21200025;0.21300025;0.21400025;0.21500026;0.21600026;0.21700026;0.21800026;0.21900027;0.22000027;0.22100027;0.22200027;0.22300027;0.22400028;0.22500028;0.22600028;0.22700028;0.22800028;0.22900029;0.23000029;0.23100029;0.23200029;0.23300029;0.2340003;0.2350003;0.2360003;0.2370003;0.2380003;0.23900031;0.24000031;0.24100031;0.24200031;0.24300031;0.24400032;0.24500032;0.24600032;0.24700032;0.24800032;0.24900033;0.25000033;0.25100031;0.2520003;0.25300029;0.25400028;0.25500026;0.25600025;0.25700024;0.25800022;0.25900021;0.2600002;0.26100019;0.26200017;0.26300016;0.26400015;0.26500013;0.26600012;0.26700011;0.2680001;0.26900008;0.27000007;0.27100006;0.27200004;0.27300003;0.27400002;0.27500001;0.27599999;0.27699998;0.27799997;0.27899995;0.27999994;0.28099993;0.28199992;0.2829999;0.28399989;0.28499988;0.28599986;0.28699985;0.28799984;0.28899983;0.28999981;0.2909998;0.29199979;0.29299977;0.29399976;0.29499975;0.29599974;0.29699972;0.29799971;0.2989997;0.29999968;0.30099967;0.30199966;0.30299965;0.30399963;0.30499962;0.30599961;0.30699959;0.30799958;0.30899957;0.30999956;0.31099954;0.31199953;0.31299952;0.3139995;0.31499949;0.31599948;0.31699947;0.31799945;0.31899944;0.31999943;0.32099941;0.3219994;0.32299939;0.32399938;0.32499936;0.32599935;0.32699934;0.32799932;0.32899931;0.3299993;0.33099928;0.33199927;0.33299926;0.33399925;0.33499923;0.33599922;0.33699921;0.33799919;0.33899918;0.33999917;0.34099916;0.34199914;0.34299913;0.34399912;0.3449991;0.34599909;0.34699908;0.34799907;0.34899905;0.34999904;0.35099903;0.35199901;0.352999;0.35399899;0.35499898;0.35599896;0.35699895;0.35799894;0.35899892;0.35999891;0.3609989;0.36199889;0.36299887;0.36399886;0.36499885;0.36599883;0.36699882;0.36799881;0.3689988;0.36999878;0.37099877;0.37199876;0.37299874;0.37399873;0.37499872;0.37599871;0.37699869;0.37799868;0.37899867;0.37999865;0.38099864;0.38199863;0.38299862;0.3839986;0.38499859;0.38599858;0.38699856;0.38799855;0.38899854;0.38999853;0.39099851;0.3919985;0.39299849;0.39399847;0.39499846;0.39599845;0.39699844;0.39799842;0.39899841;0.3999984;0.40099838;0.40199837;0.40299836;0.40399835;0.40499833;0.40599832;0.40699831;0.40799829;0.40899828;0.40999827;0.41099826;0.41199824;0.41299823;0.41399822;0.4149982;0.41599819;0.41699818;0.41799816;0.41899815;0.41999814;0.42099813;0.42199811;0.4229981;0.42399809;0.42499807;0.42599806;0.42699805;0.42799804;0.42899802;0.42999801;0.430998;0.43199798;0.43299797;0.43399796;0.43499795;0.43599793;0.43699792;0.43799791;0.43899789;0.43999788;0.44099787;0.44199786;0.44299784;0.44399783;0.44499782;0.4459978;0.44699779;0.44799778;0.44899777;0.44999775;0.45099774;0.45199773;0.45299771;0.4539977;0.45499769;0.45599768;0.45699766;0.45799765;0.45899764;0.45999762;0.46099761;0.4619976;0.46299759;0.46399757;0.46499756;0.46599755;0.46699753;0.46799752;0.46899751;0.4699975;0.47099748;0.47199747;0.47299746;0.47399744;0.47499743;0.47599742;0.47699741;0.47799739;0.47899738;0.47999737;0.48099735;0.48199734;0.48299733;0.48399732;0.4849973;0.48599729;0.48699728;0.48799726;0.48899725;0.48999724;0.49099723;0.49199721;0.4929972;0.49399719;0.49499717;0.49599716;0.49699715;0.49799713;0.49899712;0.49999711;0.50099713;0.50199711;0.5029971;0.50399709;0.50499707;0.50599706;0.50699705;0.50799704;0.50899702;0.50999701;0.510997;0.51199698;0.51299697;0.51399696;0.51499695;0.51599693;0.51699692;0.51799691;0.51899689;0.51999688;0.52099687;0.52199686;0.52299684;0.52399683;0.52499682;0.5259968;0.52699679;0.52799678;0.52899677;0.52999675;0.53099674;0.53199673;0.53299671;0.5339967;0.53499669;0.53599668;0.53699666;0.53799665;0.53899664;0.53999662;0.54099661;0.5419966;0.54299659;0.54399657;0.54499656;0.54599655;0.54699653;0.54799652;0.54899651;0.5499965;0.55099648;0.55199647;0.55299646;0.55399644;0.55499643;0.55599642;0.55699641;0.55799639;0.55899638;0.55999637;0.56099635;0.56199634;0.56299633;0.56399632;0.5649963;0.56599629;0.56699628;0.56799626;0.56899625;0.56999624;0.57099622;0.57199621;0.5729962;0.57399619;0.57499617;0.57599616;0.57699615;0.57799613;0.57899612;0.57999611;0.5809961;0.58199608;0.58299607;0.58399606;0.58499604;0.58599603;0.58699602;0.58799601;0.58899599;0.58999598;0.59099597;0.59199595;0.59299594;0.59399593;0.59499592;0.5959959;0.59699589;0.59799588;0.59899586;0.59999585;0.60099584;0.60199583;0.60299581;0.6039958;0.60499579;0.60599577;0.60699576;0.60799575;0.60899574;0.60999572;0.61099571;0.6119957;0.61299568;0.61399567;0.61499566;0.61599565;0.61699563;0.61799562;0.61899561;0.61999559;0.62099558;0.62199557;0.62299556;0.62399554;0.62499553;0.62599552;0.6269955;0.62799549;0.62899548;0.62999547;0.63099545;0.63199544;0.63299543;0.63399541;0.6349954;0.63599539;0.63699538;0.63799536;0.63899535;0.63999534;0.64099532;0.64199531;0.6429953;0.64399529;0.64499527;0.64599526;0.64699525;0.64799523;0.64899522;0.64999521;0.65099519;0.65199518;0.65299517;0.65399516;0.65499514;0.65599513;0.65699512;0.6579951;0.65899509;0.65999508;0.66099507;0.66199505;0.66299504;0.66399503;0.66499501;0.665995;0.66699499;0.66799498;0.66899496;0.66999495;0.67099494;0.67199492;0.67299491;0.6739949;0.67499489;0.67599487;0.67699486;0.67799485;0.67899483;0.67999482;0.68099481;0.6819948;0.68299478;0.68399477;0.68499476;0.68599474;0.68699473;0.68799472;0.68899471;0.68999469;0.69099468;0.69199467;0.69299465;0.69399464;0.69499463;0.69599462;0.6969946;0.69799459;0.69899458;0.69999456;0.70099455;0.70199454;0.70299453;0.70399451;0.7049945;0.70599449;0.70699447;0.70799446;0.70899445;0.70999444;0.71099442;0.71199441;0.7129944;0.71399438;0.71499437;0.71599436;0.71699435;0.71799433;0.71899432;0.71999431;0.72099429;0.72199428;0.72299427;0.72399426;0.72499424;0.72599423;0.72699422;0.7279942;0.72899419;0.72999418;0.73099416;0.73199415;0.73299414;0.73399413;0.73499411;0.7359941;0.73699409;0.73799407;0.73899406;0.73999405;0.74099404;0.74199402;0.74299401;0.743994;0.74499398;0.74599397;0.74699396;0.74799395;0.74899393;0.74999392;0.75099391;0.75199389;0.75299388;0.75399387;0.75499386;0.75599384;0.75699383;0.75799382;0.7589938;0.75999379;0.76099378;0.76199377;0.76299375;0.76399374;0.76499373;0.76599371;0.7669937;0.76799369;0.76899368;0.76999366;0.77099365;0.77199364;0.77299362;0.77399361;0.7749936;0.77599359;0.77699357;0.77799356;0.77899355;0.77999353;0.78099352;0.78199351;0.7829935;0.78399348;0.78499347;0.78599346;0.78699344;0.78799343;0.78899342;0.78999341;0.79099339;0.79199338;0.79299337;0.79399335;0.79499334;0.79599333;0.79699332;0.7979933;0.79899329;0.79999328;0.80099326;0.80199325;0.80299324;0.80399323;0.80499321;0.8059932;0.80699319;0.80799317;0.80899316;0.80999315;0.81099313;0.81199312;0.81299311;0.8139931;0.81499308;0.81599307;0.81699306;0.81799304;0.81899303;0.81999302;0.82099301;0.82199299;0.82299298;0.82399297;0.82499295;0.82599294;0.82699293;0.82799292;0.8289929;0.82999289;0.83099288;0.83199286;0.83299285;0.83399284;0.83499283;0.83599281;0.8369928;0.83799279;0.83899277;0.83999276;0.84099275;0.84199274;0.84299272;0.84399271;0.8449927;0.84599268;0.84699267;0.84799266;0.84899265;0.84999263;0.85099262;0.85199261;0.85299259;0.85399258;0.85499257;0.85599256;0.85699254;0.85799253;0.85899252;0.8599925;0.86099249;0.86199248;0.86299247;0.86399245;0.86499244;0.86599243;0.86699241;0.8679924;0.86899239;0.86999238;0.87099236;0.87199235;0.87299234;0.87399232;0.87499231;0.8759923;0.87699229;0.87799227;0.87899226;0.87999225;0.88099223;0.88199222;0.88299221;0.8839922;0.88499218;0.88599217;0.88699216;0.88799214;0.88899213;0.88999212;0.89099211;0.89199209;0.89299208;0.89399207;0.89499205;0.89599204;0.89699203;0.89799201;0.898992;0.89999199;0.90099198;0.90199196;0.90299195;0.90399194;0.90499192;0.90599191;0.9069919;0.90799189;0.90899187;0.90999186;0.91099185;0.91199183;0.91299182;0.91399181;0.9149918;0.91599178;0.91699177;0.91799176;0.91899174;0.91999173;0.92099172;0.92199171;0.92299169;0.92399168;0.92499167;0.92599165;0.92699164;0.92799163;0.92899162;0.9299916;0.93099159;0.93199158;0.93299156;0.93399155;0.93499154;0.93599153;0.93699151;0.9379915;0.93899149;0.93999147;0.94099146;0.94199145;0.94299144;0.94399142;0.94499141;0.9459914;0.94699138;0.94799137;0.94899136;0.94999135;0.95099133;0.95199132;0.95299131;0.95399129;0.95499128;0.95599127;0.95699126;0.95799124;0.95899123;0.95999122;0.9609912;0.96199119;0.96299118;0.96399117;0.96499115;0.96599114;0.96699113;0.96799111;0.9689911;0.96999109;0.97099108;0.97199106;0.97299105;0.97399104;0.97499102;0.97599101;0.976991;0.97799098;0.97899097;0.97999096;0.98099095;0.98199093;0.98299092;0.98399091;0.98499089;0.98599088;0.98699087;0.98799086;0.98899084;0.98999083;0.99099082;0.9919908;0.99299079;0.99399078;0.99499077;0.99599075;0.99699074;0.99799073;0.99899071;0.9999907;};
};
float_Data @[1] {
name="Act";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1001] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2.8405523e-18;5.1824708e-17;7.1795137e-16;8.3778504e-15;8.5568861e-14;1.1632274e-12;1.3195469e-11;1.1365989e-10;8.2493123e-10;5.2431357e-09;2.9732043e-08;1.8047972e-07;1.0025293e-06;4.629992e-06;1.863513e-05;6.6810106e-05;0.00021595958;0.00063418446;0.001783078;0.004614403;0.010668835;0.022344189;0.042776436;0.075366288;0.12289923;0.18646185;0.26458189;0.35341108;0.44526732;0.5335263;0.61284161;0.68005151;0.73429722;0.77653062;0.80872267;0.83313107;0.85180944;0.86639088;0.87805074;0.8875441;0.89553493;0.90237629;0.90831417;0.91352588;0.91814268;0.92226464;0.92596954;0.92931914;0.93236369;0.93514371;0.93769276;0.94003904;0.9422062;0.94421422;0.94608027;0.94781911;0.94944334;0.95096415;0.95239115;0.95373285;0.95499694;0.95618993;0.95731747;0.95838505;0.95939726;0.96035844;0.96127242;0.96214253;0.96297181;0.96376324;0.96451932;0.96524233;0.96593451;0.9665978;0.96723378;0.96784437;0.968431;0.96899498;0.96953768;0.97006029;0.97056395;0.97104949;0.9715181;0.97197044;0.9724068;0.97282851;0.97323644;0.97363126;0.97401351;0.97438401;0.97474331;0.9750917;0.97542959;0.97575772;0.97607648;0.97638607;0.97668725;0.97697896;0.97726291;0.97753942;0.97780854;0.97807068;0.97832608;0.97857499;0.97881794;0.97905463;0.97928512;0.97950977;0.97972929;0.97994357;0.9801529;0.98035747;0.98055744;0.980753;0.98094386;0.98113018;0.98131257;0.98149103;0.98166579;0.98183703;0.98200458;0.98216861;0.98232889;0.98248601;0.98264009;0.9827913;0.98293954;0.98308492;0.98322678;0.98336631;0.98350328;0.98363775;0.98376977;0.9838993;0.98402607;0.98415077;0.98427331;0.98439372;0.98451203;0.98462802;0.98474211;0.98485422;0.98496437;0.98507285;0.98517954;0.98528427;0.98538727;0.98548865;0.98558849;0.98568642;0.98578298;0.98587793;0.98597145;0.98606372;0.98615414;0.98624331;0.98633128;0.98641795;0.98650318;0.98658705;0.98666972;0.98675126;0.98683184;0.98691082;0.9869889;0.98706591;0.98714179;0.98721653;0.9872902;0.98736292;0.98743474;0.98750526;0.98757499;0.98764384;0.98771185;0.98777878;0.98784482;0.98791009;0.98797458;0.988038;0.98810077;0.98816276;0.98822385;0.98828423;0.98834383;0.98840272;0.98846078;0.98851812;0.98857492;0.98863113;0.98868638;0.98874104;0.98879516;0.98884857;0.98890126;0.98895341;0.98900497;0.98905581;0.98910612;0.98915589;0.98920512;0.98925376;0.98930186;0.98934942;0.98939645;0.98944294;0.9894889;0.98953432;0.98957938;0.98962402;0.98966795;0.98971146;0.98975456;0.98979717;0.98983932;0.9898811;0.98992229;0.98996317;0.99000365;0.99004358;0.99008322;0.99012256;0.99016136;0.9901998;0.99023795;0.99027544;0.9903127;0.99034977;0.99038637;0.99042243;0.99045819;0.99049371;0.99052894;0.99056387;0.9905982;0.9906323;0.99066615;0.99069971;0.99073291;0.99076581;0.99079829;0.99083054;0.99086261;0.99089426;0.99092573;0.99095684;0.9909876;0.99101818;0.99104846;0.9910785;0.9911083;0.99113768;0.99116695;0.9911958;0.99122447;0.99125296;0.99128121;0.99130923;0.991337;0.99136454;0.9913919;0.99141884;0.9914456;0.99147213;0.99149853;0.99152476;0.99155056;0.99157625;0.99160182;0.99162704;0.99165207;0.99167699;0.99170178;0.99172628;0.99175316;0.99177724;0.99180108;0.99182481;0.99184829;0.9918716;0.99189472;0.99191767;0.99194044;0.99196309;0.9919855;0.99200773;0.99202985;0.99205172;0.99207348;0.99209505;0.99211651;0.99213773;0.99215883;0.99217981;0.99220061;0.99222124;0.99224174;0.99226207;0.99228221;0.99230224;0.99232215;0.99234194;0.99236149;0.99238098;0.99240029;0.99241948;0.99243855;0.99245745;0.99247622;0.99249488;0.99251342;0.99253184;0.99255008;0.99256819;0.9925862;0.99260408;0.9926219;0.99263954;0.99265707;0.99267441;0.99269176;0.99270892;0.99272597;0.9927429;0.9927597;0.99277645;0.99279302;0.99280953;0.99282593;0.9928422;0.99285835;0.99287444;0.99289042;0.99290627;0.99292201;0.99293768;0.99295324;0.99296868;0.992984;0.99299926;0.99301445;0.99302948;0.9930445;0.99305934;0.99307412;0.99308884;0.99310344;0.99311793;0.99313235;0.99314666;0.9931609;0.99317509;0.99318916;0.9932031;0.99321705;0.99323082;0.99324459;0.99325824;0.99327177;0.9932853;0.99329871;0.993312;0.99332523;0.99333841;0.99335152;0.99336451;0.99337745;0.99339032;0.99340314;0.99341583;0.99342847;0.99344105;0.9934535;0.99346596;0.9934783;0.99349058;0.9935028;0.9935149;0.993527;0.99353898;0.99355096;0.99356282;0.99357462;0.99358636;0.99359804;0.99360961;0.99362117;0.99363267;0.99364406;0.99365544;0.99366671;0.99367797;0.99368912;0.99370021;0.99371129;0.99372226;0.99373317;0.99374408;0.99375486;0.99376565;0.99377632;0.99378699;0.99379754;0.99380809;0.99381858;0.99382895;0.99383932;0.99384964;0.99385989;0.99387008;0.99388027;0.99389035;0.99390042;0.99391037;0.99392033;0.99393022;0.99394006;0.99394983;0.99395961;0.99396926;0.99397892;0.99398851;0.99399805;0.99400753;0.994017;0.99402642;0.99403578;0.99404508;0.99405432;0.99406356;0.99407274;0.99408185;0.99409091;0.99409997;0.99410897;0.99411792;0.9941268;0.99413568;0.9941445;0.99415326;0.99416202;0.99417073;0.99417937;0.99418795;0.99419653;0.99420506;0.99421352;0.99422199;0.99423039;0.99423879;0.99424708;0.99425536;0.99426365;0.99427187;0.99428004;0.99428815;0.99429625;0.9943043;0.99431235;0.99432033;0.99432826;0.99433619;0.99434406;0.99435192;0.99435973;0.99436748;0.99437523;0.99438292;0.99439061;0.99439824;0.99440581;0.99441338;0.99442089;0.9944284;0.99443585;0.9944433;0.99445069;0.99445808;0.99446541;0.99447268;0.99447995;0.99448717;0.99449438;0.99450159;0.99450868;0.99451584;0.99452287;0.99452996;0.99453694;0.99454397;0.99455088;0.99455786;0.99456471;0.99457163;0.99457842;0.99458528;0.99459201;0.99459881;0.99460548;0.99461222;0.99461889;0.99462551;0.99463212;0.99463868;0.99464524;0.99465179;0.99465829;0.99466479;0.99467123;0.99467766;0.99468404;0.99469042;0.99469674;0.99470305;0.99470937;0.99471563;0.99472189;0.99472809;0.99473429;0.99474043;0.99474657;0.99475271;0.99475878;0.99476486;0.99477088;0.9947769;0.99478287;0.99478889;0.99479479;0.99480075;0.99480665;0.99481249;0.99481833;0.99482417;0.99483001;0.99483579;0.99484152;0.9948473;0.99485302;0.99485868;0.99486434;0.99487001;0.99487561;0.99488127;0.99488682;0.99489242;0.99489796;0.99490345;0.99490893;0.99491441;0.9949199;0.99492532;0.99493074;0.99493617;0.99494153;0.9949469;0.9949522;0.99495751;0.99496281;0.99496812;0.99497336;0.99497861;0.99498379;0.99498898;0.99499416;0.99499935;0.99500448;0.9950096;0.99501473;0.99501979;0.99502486;0.99502993;0.99503493;0.99503994;0.99504495;0.99504989;0.99505484;0.99505979;0.99506474;0.99506962;0.99507451;0.99507934;0.99508423;0.99508905;0.99509388;0.99509865;0.99510342;0.99510819;0.99511296;0.99511766;0.99512237;0.99512708;0.99513179;0.99513644;0.99514109;0.99514568;0.99515033;0.99515492;0.99515951;0.99516404;0.99516863;0.99517316;0.99517769;0.99518216;0.99518669;0.99519116;0.99519557;0.99520004;0.99520445;0.99520886;0.99521327;0.99521762;0.99522203;0.99522638;0.99523067;0.99523503;0.99523932;0.99524361;0.9952479;0.99525213;0.99525642;0.99526066;0.99526489;0.99526906;0.99527329;0.99527746;0.99528158;0.99528575;0.99528992;0.99529403;0.99529815;0.9953022;0.99530631;0.99531037;0.99531442;0.99531847;0.99532253;0.99532652;0.99533051;0.99533451;0.9953385;0.99534243;0.99534643;0.99535036;0.99535429;0.99535817;0.9953621;0.99536598;0.99536985;0.99537373;0.99537754;0.99538141;0.99538523;0.99538904;0.99539286;0.99539661;0.99540043;0.99540418;0.99540794;0.99541169;0.99541539;0.99541914;0.99542284;0.99542654;0.99543023;0.99543387;0.99543756;0.9954412;0.99544483;0.99544847;0.99545211;0.99545568;0.99545926;0.99546289;0.99546647;0.99546999;0.99547356;0.99547708;0.9954806;0.99548411;0.99548763;0.99549115;0.9954946;0.99549812;0.99550158;0.99550503;0.99550843;0.99551189;0.99551529;0.99551874;0.99552214;0.99552554;0.99552888;0.99553227;0.99553561;0.99553901;0.99554235;0.99554569;0.99554896;0.9955523;0.99555558;0.99555886;0.9955622;0.99556541;0.99556869;0.99557197;0.99557519;0.99557841;0.99558169;0.99558491;0.99558806;0.99559128;0.99559444;0.99559766;0.99560082;0.99560398;0.99560714;0.99561024;0.9956134;0.9956165;0.99561965;0.99562275;0.99562585;0.99562895;0.99563199;0.99563509;0.99563813;0.99564117;0.99564421;0.99564725;0.99565029;0.99565333;0.99565631;0.99565935;0.99566233;0.99566531;0.99566829;0.99567127;0.99567419;0.99567717;0.99568009;0.99568301;0.99568594;0.99568886;0.99569178;0.9956947;0.99569756;0.99570048;0.99570334;0.9957062;0.99570906;0.99571192;0.99571478;0.99571764;0.99572045;0.99572325;0.99572611;0.99572891;0.99573171;0.99573451;0.99573725;0.99574006;0.9957428;0.9957456;0.99574834;0.99575108;0.99575382;0.99575657;0.99575931;0.99576199;0.99576473;0.99576741;0.9957701;0.99577278;0.99577546;0.99577814;0.99578083;0.99578351;0.99578613;0.99578875;0.99579144;0.99579406;0.99579668;0.9957993;0.99580193;0.99580449;0.99580711;0.99580967;0.9958123;0.99581486;0.99581742;0.99581999;0.99582255;0.99582511;0.99582767;0.99583018;0.99583274;0.99583524;0.99583775;0.99584025;0.99584275;0.99584526;0.99584776;0.99585027;0.99585271;0.99585521;0.99585766;0.9958601;0.9958626;0.99586505;0.99586749;0.99586993;0.99587232;0.99587476;0.99587715;0.99587959;0.99588197;0.99588436;0.9958868;0.99588919;0.99589157;0.9958939;0.99589628;0.99589866;0.99590099;0.99590337;0.9959057;0.99590802;0.99591035;0.99591273;0.995915;0.99591732;0.99591964;0.99592197;0.99592423;0.99592656;0.99592882;0.99593109;0.99593341;0.99593568;0.99593794;0.99594021;0.99594241;0.99594468;0.99594694;0.99594915;0.99595141;0.99595362;0.99595582;0.99595809;0.9959603;0.9959625;0.99596471;0.99596685;0.99596906;0.99597126;0.99597341;0.99597561;0.99597776;0.99597991;0.99598211;0.99598426;0.9959864;0.99598855;0.99599069;0.99599278;0.99599493;0.99599707;0.99599916;0.9960013;0.99600339;0.99600548;0.99600756;0.99600965;0.99601173;0.99601382;0.99601591;0.99601799;0.99602008;0.99602211;0.99602419;0.99602622;0.9960283;0.99603033;0.99603236;0.99603438;0.99603641;0.99603844;0.99604046;0.99604249;0.99604452;0.99604648;0.99604851;0.99605048;0.9960525;0.99605447;0.99605644;0.99605846;0.99606043;0.9960624;0.99606436;0.99606633;0.99606824;0.99607021;0.99607217;0.99607408;0.99607605;0.99607795;0.99607992;0.99608183;0.99608374;0.99608564;0.99608761;0.99608952;0.99609143;0.99609327;0.99609518;0.99609709;0.996099;0.99610084;0.99610275;0.9961046;0.99610645;0.99610835;0.9961102;0.99611205;0.9961139;0.99611574;0.99611759;0.99611944;0.99612129;0.99612314;0.99612492;0.99612677;0.99612856;0.99613041;0.99613219;0.99613404;0.99613583;0.99613762;0.99613941;0.9961412;0.99614298;0.99614477;0.99614656;0.99614835;0.99615014;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
};
data_proc {
name=;
el_typ=taDataProc;
el_def=0;
taDataProc @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_base";
};
taDataAnal @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_anal";
};
taDataGen @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_gen";
};
taImageProc @[3] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="image_proc";
};
};
programs {
name=;
el_typ=Program;
el_def=0;
step_prog=.projects[0].programs[1]$8$;
tags=;
desc=;
Program @[0] {
name="ActBasedRField";
tags="Statistic, Receptive Field";
desc="computes an activation based receptive field using ActBasedRF object type -- allows you to see how units in a selected target layer relate to activations of units throughout the network";
flags=;
objs {
name=;
el_typ=ActBasedRF;
el_def=0;
ActBasedRF @[0] {
name="ActBasedRF_0";
rf_data=.projects[0].programs[0].objs[1]$9$;
network=.projects[0].networks[0]$10$;
trg_layer=.projects[0].networks[0].layers[1]$11$;
norm_mode=NORM_RF_LAY;
threshold=0.5;
};
DataTable @[1] {
name="ActRFData";
desc="receptive field data -- could move this into AnalysisData if you want..";
data {
name="data";
el_typ=float_Data;
el_def=0;
float_Data @[0] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[1] {
name="Striatum";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 4;9;};
calc_expr {
expr=;
};
ar {
name=;
[4 9 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[3] {
name="GP_Int";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[4] {
name="GP_Ext";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[5] {
name="Thalamus";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[6] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[7] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[8] {
name="STN";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 3;3;};
calc_expr {
expr=;
};
ar {
name=;
[3 3 36] 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[1] {
name="final_rf";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="whether to compute the final receptive field or just increment the sums -- call with false to accumulate, and true at end to get final values";
};
ProgVar @[2] {
name="init_rf";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="whether to compute the final receptive field or just increment the sums -- call with false to accumulate, and true at end to get final values";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="ActBasedRF_0";
var_type=T_Object;
object_type=ActBasedRF;
object_val=.projects[0].programs[0].objs[0]$12$;
objs_ptr=1;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[1] {
name="ActRFData";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=1;
flags=NULL_CHECK|USED;
reference=0;
desc="data table to record activation based receptive field information into";
};
ProgVar @[2] {
name="trg_layer_name";
var_type=T_String;
string_val="Striatum";
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[3] {
name="trg_layer";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$11$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="target layer to get receptive field data for";
};
};
functions {
name=;
el_typ=Function;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc=;
flags=;
result_var=.projects[0].programs[0].vars[3]$13$;
obj=.projects[0].programs[0].args[0]$14$;
method=Network::FindLayer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_char_ptr;
type="const char*";
name="nm";
required=0;
def_val=;
expr {
expr="trg_layer_name";
};
};
};
};
MethodCall @[1] {
desc=;
flags=;
result_var=NULL;
obj=.projects[0].programs[0].vars[0]$15$;
method=ActBasedRF::InitAll;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="ActRFData";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
ProgArg @[2] {
arg_type=Layer_ptr;
type="Layer*";
name="tlay";
required=0;
def_val=;
expr {
expr="trg_layer";
};
};
};
};
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
IfElse @[0] {
desc=;
flags=;
cond {
expr="init_rf";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc=;
flags=;
result_var=NULL;
obj=$15$;
method=ActBasedRF::InitAll;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="ActRFData";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
ProgArg @[2] {
arg_type=Layer_ptr;
type="Layer*";
name="tlay";
required=0;
def_val=;
expr {
expr="trg_layer";
};
};
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
IfElse @[0] {
desc=;
flags=;
cond {
expr="final_rf";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc=;
flags=;
result_var=NULL;
obj=$15$;
method=ActBasedRF::ComputeRF;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc=;
flags=;
result_var=NULL;
obj=$15$;
method=ActBasedRF::IncrementSums;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
};
};
};
};
Program @[1] {
name="LeabraStartup";
tags="Leabra, Startup";
desc="run project in the background (replaces leabra_startup.css)
command line is: emergent -nogui -ni -p <project name>.proj [epochs=xxx] [batches=xxx] [tag=xxx]";
flags=STARTUP_RUN;
objs {
name=;
el_typ=taNBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to operate on -- updates batch counter on network and passes it to train program";
};
ProgVar @[1] {
name="batches";
var_type=T_Int;
int_val=25;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[2] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[3] {
name="DA_burst_val";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[4] {
name="meds";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[5] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][2]$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
ProgVar @[6] {
name="TrainFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
ProgVar @[7] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][1]$17$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="batch";
var_type=T_Object;
object_type=Program;
object_val=.projects[0].programs.gp[0][0]$18$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="set this to point to your batch process";
};
ProgVar @[1] {
name="tag";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[2] {
name="log_dir";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="log file directory";
};
ProgVar @[3] {
name="log_file_nm";
var_type=T_String;
string_val="/home/frankmj/sims/bg_da/stn/distro/pn/pdp4/BG_PS_repl_a.gn.dat";
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="name of log file";
};
ProgVar @[4] {
name="EpochOutputData";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[1][1]$19$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[5] {
name="TrialOutputData";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[1][0]$20$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[6] {
name="Go_NoGo";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[2][0]$21$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
};
functions {
name=;
el_typ=Function;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
IfReturn @[0] {
desc="don't run if running in the gui!";
flags=;
cond {
expr="taMisc::gui_active";
};
};
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
IfReturn @[0] {
desc="don't run if running in the gui!";
flags=;
cond {
expr="taMisc::gui_active";
};
};
Comment @[1] {
desc="add our special args from command line";
flags=;
};
MiscCall @[2] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"tag=\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"FileTag\"";
};
};
};
};
MiscCall @[3] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"logdir=\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"LogDir\"";
};
};
};
};
MiscCall @[4] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"num_intact_snc_units=\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"num_intact_snc_units\"";
};
};
};
};
MiscCall @[5] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"DA_burst_val=\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"DA_burst_val\"";
};
};
};
};
MiscCall @[6] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"meds=\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"meds\"";
};
};
};
};
MiscCall @[7] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"batches=\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"batches\"";
};
};
};
};
MiscCall @[8] {
desc="key step: actually process args!";
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::UpdateArgs;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
RegisterArgs @[9] {
desc="This is KEY!!! actuall processes all args, including those from ProgVarFmArg guys below";
flags=;
};
Comment @[10] {
desc="Initialize and set variables from args";
flags=;
};
PrintExpr @[11] {
desc=;
flags=;
expr {
expr="\"Loaded project: \" << .projects[0].file_name";
};
};
ProgVarFmArg @[12] {
desc=;
flags=;
prog=$18$;
var_name="meds";
arg_name="meds";
};
MethodCall @[13] {
desc=;
flags=;
result_var=NULL;
obj=.projects[0].programs[1].vars[0]$22$;
method=Program::Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MiscCall @[14] {
desc=;
flags=;
result_var=.projects[0].programs[1].vars[1]$23$;
object_type=taMisc;
method=taMisc::FindArgByName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="nm";
required=0;
def_val="\"\"";
expr {
expr="\"FileTag\"";
};
};
};
};
MiscCall @[15] {
desc=;
flags=;
result_var=.projects[0].programs[1].vars[2]$24$;
object_type=taMisc;
method=taMisc::FindArgByName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="nm";
required=0;
def_val="\"\"";
expr {
expr="\"LogDir\"";
};
};
};
};
ProgVarFmArg @[16] {
desc=;
flags=;
prog=$18$;
var_name="max_batch";
arg_name="batches";
};
ProgVarFmArg @[17] {
desc=;
flags=;
prog=.projects[0].programs.gp[0][1]$25$;
var_name="max_epoch";
arg_name="epochs";
};
ProgVarFmArg @[18] {
desc=;
flags=;
prog=$25$;
var_name="num_intact_snc_units";
arg_name="num_intact_snc_units";
};
ProgVarFmArg @[19] {
desc=;
flags=;
prog=.projects[0].programs.gp[0][16]$26$;
var_name="DA_burst_val";
arg_name="DA_burst_val";
};
Comment @[20] {
desc="Set log files";
flags=;
};
MethodCall @[21] {
desc="last arg is to include dmem proc number";
flags=;
result_var=.projects[0].programs[1].vars[3]$27$;
obj=.projects[0].programs[1].vars[6]$28$;
method=taBase::GetFileNameFmProject;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="ext";
required=1;
def_val=;
expr {
expr="\".gn.dat\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="tag";
required=0;
def_val="\"\"";
expr {
expr="tag";
};
};
ProgArg @[2] {
arg_type=const_taString_ref;
type="const taString&";
name="subdir";
required=0;
def_val="\"\"";
expr {
expr="log_dir";
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="dmem_proc_no";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
MethodCall @[22] {
desc="last arg is to restrict log to dmem_proc = 0";
flags=;
result_var=NULL;
obj=$28$;
method=DataTable::SaveDataLog;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="fname";
required=0;
def_val="\"\"";
expr {
expr="log_file_nm";
};
};
ProgArg @[1] {
arg_type=bool;
type="bool";
name="append";
required=0;
def_val="false";
expr {
expr="false";
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="dmem_proc_0";
required=0;
def_val="true";
expr {
expr="true";
};
};
};
};
MethodCall @[23] {
desc="last arg is to include dmem proc number";
flags=OFF;
result_var=$27$;
obj=.projects[0].programs[1].vars[5]$29$;
method=taBase::GetFileNameFmProject;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="ext";
required=1;
def_val=;
expr {
expr="\".trl.dat\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="tag";
required=0;
def_val="\"\"";
expr {
expr="tag";
};
};
ProgArg @[2] {
arg_type=const_taString_ref;
type="const taString&";
name="subdir";
required=0;
def_val="\"\"";
expr {
expr="log_dir";
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="dmem_proc_no";
required=0;
def_val="false";
expr {
expr="true";
};
};
};
};
MethodCall @[24] {
desc="last arg is to restrict log to dmem_proc = 0";
flags=OFF;
result_var=NULL;
obj=$29$;
method=DataTable::SaveDataLog;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="fname";
required=0;
def_val="\"\"";
expr {
expr="log_file_nm";
};
};
ProgArg @[1] {
arg_type=bool;
type="bool";
name="append";
required=0;
def_val="false";
expr {
expr="false";
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="dmem_proc_0";
required=0;
def_val="true";
expr {
expr="false";
};
};
};
};
OtherProgramVar @[25] {
desc=;
flags=OFF;
other_prog=$18$;
set_other=1;
var_1=.projects[0].programs[1].args[4]$30$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
PrintExpr @[26] {
desc=;
flags=;
expr {
expr="\"Running: \" << batch.name";
};
};
ProgramCall @[27] {
desc=;
flags=;
target=$18$;
targ_ld_init="*LeabraBatch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
};
};
ProgArg @[2] {
arg_type=DataTable;
type="DataTable*";
name="TrainFreq";
required=1;
def_val=;
expr {
expr="TrainFreq";
};
};
ProgArg @[3] {
arg_type=DataTable;
type="DataTable*";
name="TestFreq";
required=1;
def_val=;
expr {
expr="TestFreq";
};
};
};
};
};
};
Program_Group @.gp[0] {
name="LeabraAll_Std";
el_typ=Program;
el_def=0;
step_prog=.projects[0].programs.gp[0][6]$31$;
tags="Leabra, Std, All";
desc="The full set of programs for training a standard Leabra network";
Program @[0] {
name="LeabraBatch";
tags="Leabra, Std";
desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to operate on -- updates batch counter on network and passes it to train program";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
ProgVar @[2] {
name="TrainFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc="datatable with training patterns";
};
ProgVar @[3] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="batch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="batch counter";
};
ProgVar @[1] {
name="meds";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="simulate da meds (reduced da dip)";
};
ProgVar @[2] {
name="DA_dip_val";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[3] {
name="max_batch";
var_type=T_Int;
int_val=50;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="maximum number of batch runs to perform";
};
ProgVar @[4] {
name="Go_NoGo";
var_type=T_Object;
object_type=DataTable;
object_val=$21$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="datatable with training patterns";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initializes local batch counter and batch field on network";
flags=;
network_var=.projects[0].programs.gp[0][0].args[0]$32$;
local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$33$;
counter=Network::batch;
};
IfElse @[1] {
desc=;
flags=;
cond {
expr="meds==true";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][0].vars[2]$34$;
expr {
expr=".024";
};
};
OtherProgramVar @[1] {
desc=;
flags=;
other_prog=$26$;
set_other=1;
var_1=$34$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=$34$;
expr {
expr="0";
};
};
OtherProgramVar @[1] {
desc=;
flags=;
other_prog=$26$;
set_other=1;
var_1=$34$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
};
};
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
NetCounterInit @[0] {
desc="initializes local batch counter and batch field on network";
flags=;
network_var=$32$;
local_ctr_var=$33$;
counter=Network::batch;
};
WhileLoop @[1] {
desc="the main loop over training runs";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc="run the training program -- sets the network and input_data args";
flags=;
target=$25$;
targ_ld_init="*LeabraTrain*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="no_prompts";
required=1;
def_val=;
expr {
expr="true";
};
};
};
};
ProgramCall @[1] {
desc=;
flags=;
target=.projects[0].programs.gp[0][3]$35$;
targ_ld_init="*LeabraTestEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestEnv";
required=1;
def_val=;
expr {
expr="TestFreq";
};
};
};
};
NetCounterIncr @[2] {
desc="increment the local batch counter and copy to network";
flags=;
network_var=$32$;
local_ctr_var=$33$;
counter=Network::batch;
};
};
test {
expr="batch < max_batch";
};
};
DataCalcLoop @[2] {
desc=;
flags=;
src_data_var=.projects[0].programs.gp[0][0].vars[4]$36$;
dest_data_var=NULL;
src_cols {
name="src_cols";
el_typ=DataOpEl;
el_def=0;
};
dest_cols {
name="dest_cols";
el_typ=DataOpEl;
el_def=0;
};
loop_code {
name=;
el_typ=UserScript;
el_def=0;
UserScript @[0] {
desc=;
flags=;
script {
expr="Go_NoGo.GroupMeanSEM(NULL,NULL,NULL,NULL,NULL);";
};
};
};
src_col_vars {
name=;
el_typ=ProgVar;
el_def=0;
};
dest_col_vars {
name=;
el_typ=ProgVar;
el_def=0;
};
};
};
};
Program @[1] {
name="LeabraTrain";
tags="Leabra, Std";
desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
flags=SHOW_STEP;
objs {
name=;
el_typ=RndSeed;
el_def=0;
RndSeed @[0] {
name="rnd_seed";
seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;};
mti=156;
};
};
types {
name=;
el_typ=DynEnumType;
el_def=0;
DynEnumType @[0] {
name="RndInitType";
desc=;
enums {
name=;
el_typ=DynEnumItem;
el_def=0;
DynEnumItem @[0] {
name="OLD_SEED";
value=0;
desc="use stored random seed value (recreates same sequence every time)";
};
DynEnumItem @[1] {
name="NEW_SEED";
value=1;
desc="generate new random seed (new sequence of random numbers)";
};
};
bits=0;
};
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to train";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc="datatable with training patterns";
};
ProgVar @[2] {
name="no_prompts";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="max_epoch";
var_type=T_Int;
int_val=10;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="maximum number of epochs to run";
};
ProgVar @[1] {
name="train_mode";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=Network::TrainMode;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
};
ProgVar @[2] {
name="test_mode";
var_type=T_HardEnum;
int_val=0;
hard_enum_type=Network::TrainMode;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
};
ProgVar @[3] {
name="rnd_init";
var_type=T_DynEnum;
dyn_enum_val {
enum_type=.projects[0].programs.gp[0][1].types[0]$37$;
value=0;
};
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="how to initialize the random numbers when the Init button is pressed";
};
ProgVar @[4] {
name="epoch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="current epoch -- local copy, which is used to update network's epoch counter";
};
ProgVar @[5] {
name="err_stopcrit";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
};
ProgVar @[6] {
name="rnd_seed";
var_type=T_Object;
object_type=RndSeed;
object_val=.projects[0].programs.gp[0][1].objs[0]$38$;
objs_ptr=1;
flags=NULL_CHECK|USED;
reference=0;
desc="random seed that is used at start of training -- if OldSeed is called";
};
ProgVar @[7] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[8] {
name="train_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=.projects[0].networks[0].train_time$39$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="records time used to train network (object lives on network -- this is a pointer to it)";
};
ProgVar @[9] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[10] {
name="j";
var_type=T_Int;
int_val=18;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[11] {
name="i";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[12] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[13] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[14] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=.projects[0].networks[0].layers[2]$40$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[15] {
name="Striatum";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$11$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[16] {
name="Train_Freq";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="datatable with training patterns";
};
ProgVar @[17] {
name="str_unit";
var_type=T_Object;
object_type=UnitSpec;
object_val=.projects[0].networks[0].specs.gp[2][0].children[3].children[0]$41$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][1].args[2]$42$;
expr {
expr="false";
};
};
MethodCall @[1] {
desc="check network to make sure it is ready to be run";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][1].args[0]$43$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
AssignExpr @[2] {
desc="get our pointer to the network training time object";
flags=;
result_var=.projects[0].programs.gp[0][1].vars[8]$44$;
expr {
expr="network.train_time";
};
};
NetCounterInit @[3] {
desc="initialize epoch counter ";
flags=;
network_var=$43$;
local_ctr_var=.projects[0].programs.gp[0][1].vars[4]$45$;
counter=Network::epoch;
};
IfElse @[4] {
desc="initialize random seed (either old or new)";
flags=;
cond {
expr="rnd_init == OLD_SEED";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="restore previous random seed (all runs produce same results)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][1].vars[6]$46$;
method=RndSeed::OldSeed;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="new random numbers each time";
flags=;
result_var=NULL;
obj=$46$;
method=RndSeed::NewSeed;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
IfGuiPrompt @[5] {
desc="don't initialize weights without checking";
flags=;
prompt="Do you want to Initialize Network Weights";
yes_label="Yes";
no_label="No";
yes_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="initialize network weights: could also load pre-set weights or something else here";
flags=;
result_var=NULL;
obj=$43$;
method=Network::Init_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
PrintExpr @[1] {
desc=;
flags=;
expr {
expr="network.name << \" Weights Initialized\"";
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc="get our pointer to the network training time object";
flags=;
result_var=$44$;
expr {
expr="network.train_time";
};
};
MethodCall @[1] {
desc="start timer to keep track of how long it takes to run entire training run";
flags=;
result_var=NULL;
obj=$44$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
};
};
};
};
NetCounterInit @[2] {
desc="initialize epoch counter (both our local copy and network's epoch counter)";
flags=;
network_var=$43$;
local_ctr_var=$45$;
counter=Network::epoch;
};
MemberAssign @[3] {
desc=;
flags=;
obj=.projects[0].programs.gp[0][1].vars[17]$47$;
path="noise.mean";
expr {
expr=".001";
};
update_after=0;
};
MemberAssign @[4] {
desc="set network's training mode to our local value";
flags=;
obj=$43$;
path="train_mode";
expr {
expr="train_mode";
};
update_after=0;
};
IfElse @[5] {
desc=;
flags=;
cond {
expr="no_prompts";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="initialize network weights: could also load pre-set weights or something else here";
flags=;
result_var=NULL;
obj=$43$;
method=Network::Init_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
PrintExpr @[1] {
desc=;
flags=;
expr {
expr="network.name << \" Weights Initialized\"";
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
AssignExpr @[6] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][1].vars[13]$48$;
expr {
expr="SNc.units.size";
};
};
ForLoop @[7] {
desc="only connect intact snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over striatal units  (Go units for D1 projection and NoGo units for D2 projection)";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
UserScript @[0] {
desc="zero out weights for non-intact snc units";
flags=;
script {
expr="SNc.units[i].send[0].Cn(j).wt=0; SNc.units[i].send[1].Cn(j).wt=0;       ";
};
};
};
init {
expr="j = 0";
};
test {
expr="j <    (Striatum.units.size)/2";
};
iter {
expr="j++";
};
};
};
init {
expr="i = num_intact_snc_units";
};
test {
expr="i <  snc_size";
};
iter {
expr="i++";
};
};
OtherProgramVar @[8] {
desc=;
flags=;
other_prog=$26$;
set_other=1;
var_1=$3$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
OtherProgramVar @[9] {
desc=;
flags=;
other_prog=$35$;
set_other=1;
var_1=$3$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
MemberAssign @[10] {
desc="set network's training mode to our local value";
flags=;
obj=$43$;
path="train_mode";
expr {
expr="test_mode";
};
update_after=0;
};
WhileLoop @[11] {
desc="main loop over epochs of training";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
MemberAssign @[0] {
desc="set network's training mode to our local value";
flags=;
obj=$43$;
path="train_mode";
expr {
expr="train_mode";
};
update_after=0;
};
IfElse @[1] {
desc="Set Reversal environment mid-way through";
flags=;
cond {
expr="epoch<max_epoch";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc="run the epoch program (one epoch), passes our network and input_data";
flags=;
target=.projects[0].programs.gp[0][2]$49$;
targ_ld_init="*LeabraEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="Train_Freq";
};
};
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
NetCounterIncr @[2] {
desc="increment the epoch counter (locally and on network)";
flags=;
network_var=$43$;
local_ctr_var=$45$;
counter=Network::epoch;
};
IfBreak @[3] {
desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
flags=OFF;
cond {
expr="network.cnt_err <= err_stopcrit";
};
};
MemberAssign @[4] {
desc="set network's training mode to our local value";
flags=;
obj=$43$;
path="train_mode";
expr {
expr="test_mode";
};
update_after=0;
};
};
test {
expr="epoch < max_epoch";
};
};
MethodCall @[12] {
desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
flags=;
result_var=NULL;
obj=$44$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[2] {
name="LeabraEpoch";
tags="Leabra, Std";
desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to operate on";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="table of patterns to present to the network, one row at a time";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="data_loop_order";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=DataLoop::Order;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
};
ProgVar @[1] {
name="trial";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="current trial (event) within the epoch -- increments automatically";
};
ProgVar @[2] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$20$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
};
ProgVar @[3] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=.projects[0].networks[0].epoch_time$50$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
};
ProgVar @[4] {
name="data_loop_index";
var_type=T_Int;
int_val=2;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=.projects[0].programs.gp[0][2].args[0]$51$;
local_ctr_var=.projects[0].programs.gp[0][2].vars[1]$52$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=.projects[0].programs.gp[0][2].vars[3]$53$;
expr {
expr="network.epoch_time";
};
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=$51$;
local_ctr_var=$52$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=$53$;
expr {
expr="network.epoch_time";
};
};
MethodCall @[2] {
desc="start the epoch timer to record computation time per epoch";
flags=;
result_var=NULL;
obj=$53$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
};
};
};
};
MethodCall @[3] {
desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][2].vars[2]$54$;
method=DataTable::ResetData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetDataLoop @[4] {
desc="iterates over the events/rows of input_data, according to data_loop_order variable";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the trial program, passing network and input_data";
flags=;
target=.projects[0].programs.gp[0][4]$55$;
targ_ld_init="*LeabraTrial*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
};
};
};
};
IfElse @[1] {
desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
flags=;
cond {
expr="network.Compute_Weights_Test(trial+1)";
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="update the weight values based on changes computed by trial program";
flags=;
result_var=NULL;
obj=$51$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
};
data_var=.projects[0].programs.gp[0][2].args[1]$56$;
index_var=.projects[0].programs.gp[0][2].vars[4]$57$;
order_var=.projects[0].programs.gp[0][2].vars[0]$58$;
order=PERMUTED;
item_idx_list{ 32;28;26;35;13;37;5;36;0;14;31;3;16;2;7;22;15;9;6;39;10;11;20;38;19;4;17;21;34;23;30;18;1;24;25;33;12;8;29;27;};
dmem_nprocs=1;
dmem_this_proc=0;
};
IfElse @[5] {
desc="if full batch mode, update only at end of epoch";
flags=;
cond {
expr="network.wt_update == Network::BATCH";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="final update of weights based on accumulated changes";
flags=;
result_var=NULL;
obj=$51$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
MethodCall @[6] {
desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
flags=;
result_var=NULL;
obj=$51$;
method=LeabraNetwork::Compute_EpochStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[7] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=OFF;
target=.projects[0].programs.gp[0][14]$59$;
targ_ld_init="*LeabraEpochMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[8] {
desc="done with the computation in the epoch -- record time it took";
flags=;
result_var=NULL;
obj=$53$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[3] {
name="LeabraTestEpoch";
tags=;
desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to operate on";
};
ProgVar @[1] {
name="TestEnv";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="data_loop_order";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=DataLoop::Order;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
};
ProgVar @[1] {
name="trial";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="current trial (event) within the epoch -- increments automatically";
};
ProgVar @[2] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$20$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
};
ProgVar @[3] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=$50$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
};
ProgVar @[4] {
name="data_loop_index";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
};
ProgVar @[5] {
name="epoch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[6] {
name="max_epoch";
var_type=T_Int;
int_val=10;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[7] {
name="final_rf";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[8] {
name="acc_rf";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[9] {
name="init_rf";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[10] {
name="str_unit";
var_type=T_Object;
object_type=UnitSpec;
object_val=$41$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[11] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[12] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[13] {
name="k";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[14] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$40$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=.projects[0].programs.gp[0][3].args[0]$60$;
local_ctr_var=.projects[0].programs.gp[0][3].vars[1]$61$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=.projects[0].programs.gp[0][3].vars[3]$62$;
expr {
expr="network.epoch_time";
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[5]$63$;
expr {
expr=".programs.LeabraTrain.epoch.int_val";
};
};
AssignExpr @[3] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[6]$64$;
expr {
expr=".programs.LeabraTrain.max_epoch.int_val";
};
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=$60$;
local_ctr_var=$61$;
counter=Network::trial;
};
AssignExpr @[1] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[12]$65$;
expr {
expr="SNc.units.size";
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[13]$66$;
expr {
expr="(float)num_intact_snc_units/ snc_size";
};
};
MemberAssign @[3] {
desc="turn off noise in striatum to get reliable measure of learned activity";
flags=;
obj=.projects[0].programs.gp[0][3].vars[10]$67$;
path="noise.mean";
expr {
expr="0.00";
};
update_after=0;
};
AssignExpr @[4] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=$62$;
expr {
expr="network.epoch_time";
};
};
MethodCall @[5] {
desc="start the epoch timer to record computation time per epoch";
flags=;
result_var=NULL;
obj=$62$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
};
};
};
};
MethodCall @[6] {
desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][3].vars[2]$68$;
method=DataTable::ResetData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
AssignExpr @[7] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[9]$69$;
expr {
expr="true";
};
};
ProgramCall @[8] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=;
target=.projects[0].programs[0]$70$;
targ_ld_init="*ActBasedRField*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=bool;
type="bool";
name="final_rf";
required=1;
def_val=;
expr {
expr="final_rf";
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="init_rf";
required=1;
def_val=;
expr {
expr="init_rf";
};
};
};
};
AssignExpr @[9] {
desc=;
flags=;
result_var=$69$;
expr {
expr="false";
};
};
NetDataLoop @[10] {
desc="iterates over the events/rows of input_data, according to data_loop_order variable";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the trial program, passing network and input_data";
flags=;
target=.projects[0].programs.gp[0][5]$71$;
targ_ld_init="*LeabraTestTrial*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestEnv";
};
};
};
};
IfElse @[1] {
desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
flags=;
cond {
expr="network.Compute_Weights_Test(trial+1)";
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="update the weight values based on changes computed by trial program";
flags=;
result_var=NULL;
obj=$60$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
};
data_var=.projects[0].programs.gp[0][3].args[1]$72$;
index_var=.projects[0].programs.gp[0][3].vars[4]$73$;
order_var=.projects[0].programs.gp[0][3].vars[0]$74$;
order=PERMUTED;
item_idx_list{ 2;3;0;1;};
dmem_nprocs=1;
dmem_this_proc=0;
};
IfElse @[11] {
desc="if full batch mode, update only at end of epoch";
flags=;
cond {
expr="network.wt_update == Network::BATCH";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="final update of weights based on accumulated changes";
flags=;
result_var=NULL;
obj=$60$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
MethodCall @[12] {
desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
flags=;
result_var=NULL;
obj=$60$;
method=LeabraNetwork::Compute_EpochStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[13] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=;
target=$59$;
targ_ld_init="*LeabraEpochMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
ProgramCall @[14] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=;
target=$70$;
targ_ld_init="*ActBasedRField*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=bool;
type="bool";
name="final_rf";
required=1;
def_val=;
expr {
expr="final_rf";
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="init_rf";
required=1;
def_val=;
expr {
expr="init_rf";
};
};
};
};
ProgramCall @[15] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=;
target=.projects[0].programs.gp[0][17]$75$;
targ_ld_init="*Calc_GoNoGo*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[16] {
desc="done with the computation in the epoch -- record time it took";
flags=;
result_var=NULL;
obj=$62$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[4] {
name="LeabraTrial";
tags="Leabra, Std";
desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="network to operate on -- typically set by higher-level calling programs";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="datatable containing training input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="phase_no";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
};
ProgVar @[1] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="determines whether to update any network view displays after trial is completed";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=.projects[0].programs.gp[0][4].args[0]$76$;
local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$77$;
counter=LeabraNetwork::phase_no;
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=$76$;
local_ctr_var=$77$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[1] {
desc="initializes various counters at start of trial";
flags=;
result_var=NULL;
obj=$76$;
method=LeabraNetwork::Trial_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
WhileLoop @[2] {
desc="loop over phases of settling in the network";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
UserScript @[0] {
desc=;
flags=OFF;
script {
expr=".programs.LeabraSettle.Init();
";
};
};
ProgramCall @[1] {
desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
flags=;
target=$31$;
targ_ld_init="*LeabraSettle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
};
};
};
};
NetCounterIncr @[2] {
desc="increment the phase number (also on network)";
flags=;
network_var=$76$;
local_ctr_var=$77$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[3] {
desc="increments other phase state information to prepare for the next phase of settling";
flags=;
result_var=NULL;
obj=$76$;
method=LeabraNetwork::Trial_UpdatePhase;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
test {
expr="phase_no < network.phase_max";
};
};
MethodCall @[3] {
desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
flags=;
result_var=NULL;
obj=$76$;
method=LeabraNetwork::Trial_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[4] {
desc="records data about the trial-level processing to a datatable for graphing/processing";
flags=OFF;
target=.projects[0].programs.gp[0][12]$78$;
targ_ld_init="*LeabraTrialMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
NetUpdateView @[5] {
desc="update the network view(s) (only if update_net_view is true)";
flags=;
network_var=$76$;
update_var=.projects[0].programs.gp[0][4].vars[1]$79$;
};
};
};
Program @[5] {
name="LeabraTestTrial";
tags=;
desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="network to operate on -- typically set by higher-level calling programs";
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="datatable containing training input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="phase_no";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
};
ProgVar @[1] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="determines whether to update any network view displays after trial is completed";
};
ProgVar @[2] {
name="acc_rf";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[3] {
name="init_rf";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=.projects[0].programs.gp[0][5].args[0]$80$;
local_ctr_var=.projects[0].programs.gp[0][5].vars[0]$81$;
counter=LeabraNetwork::phase_no;
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=$80$;
local_ctr_var=$81$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[1] {
desc="initializes various counters at start of trial";
flags=;
result_var=NULL;
obj=$80$;
method=LeabraNetwork::Trial_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
WhileLoop @[2] {
desc="loop over phases of settling in the network";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
UserScript @[0] {
desc=;
flags=OFF;
script {
expr=".programs.LeabraTestSettle.Init();
";
};
};
ProgramCall @[1] {
desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
flags=;
target=.projects[0].programs.gp[0][7]$82$;
targ_ld_init="*LeabraTestSettle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
};
};
};
};
NetCounterIncr @[2] {
desc="increment the phase number (also on network)";
flags=;
network_var=$80$;
local_ctr_var=$81$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[3] {
desc="increments other phase state information to prepare for the next phase of settling";
flags=;
result_var=NULL;
obj=$80$;
method=LeabraNetwork::Trial_UpdatePhase;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
test {
expr="phase_no < network.phase_max";
};
};
MethodCall @[3] {
desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
flags=;
result_var=NULL;
obj=$80$;
method=LeabraNetwork::Trial_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[4] {
desc="records data about the trial-level processing to a datatable for graphing/processing";
flags=;
target=$78$;
targ_ld_init="*LeabraTrialMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
ProgramCall @[5] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=;
target=$70$;
targ_ld_init="*ActBasedRField*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=bool;
type="bool";
name="final_rf";
required=1;
def_val=;
expr {
expr="acc_rf";
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="init_rf";
required=1;
def_val=;
expr {
expr="false";
};
};
};
};
NetUpdateView @[6] {
desc="update the network view(s) (only if update_net_view is true)";
flags=;
network_var=$80$;
update_var=.projects[0].programs.gp[0][5].vars[1]$83$;
};
};
};
Program @[6] {
name="LeabraSettle";
tags="Leabra, Std";
desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="current cycle of settling (local loop counter)";
};
ProgVar @[1] {
name="min_cycles";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
};
ProgVar @[2] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="if true, will update network views at end of settling";
};
ProgVar @[3] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=.projects[0].programs.gp[0][10].objs[0]$84$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=.projects[0].programs.gp[0][6].args[0]$85$;
local_ctr_var=.projects[0].programs.gp[0][6].vars[0]$86$;
counter=Network::cycle;
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=$85$;
local_ctr_var=$86$;
counter=Network::cycle;
};
MethodCall @[1] {
desc="resets input data, before getting new external inputs data from apply inputs call";
flags=;
result_var=NULL;
obj=$85$;
method=Network::Init_InputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[2] {
desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
flags=;
target=.projects[0].programs.gp[0][10]$87$;
targ_ld_init="*ApplyInputs*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
};
};
};
};
ProgramCall @[3] {
desc=;
flags=;
target=$26$;
targ_ld_init="*DA_Rew_Punish*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
};
};
};
};
IfElse @[4] {
desc=;
flags=;
cond {
expr="network.phase == LeabraNetwork::PLUS_PHASE";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=;
flags=;
obj=$85$;
path="cycle_max";
expr {
expr="30";
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="number of cycles to run in minus phase";
flags=;
obj=$85$;
path="cycle_max";
expr {
expr="100";
};
update_after=0;
};
};
};
MethodCall @[5] {
desc="initializes various counters at start of settling";
flags=;
result_var=NULL;
obj=$85$;
method=LeabraNetwork::Settle_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[6] {
desc="get appropriate min_cycles value depending on which phase we're in";
flags=;
cond {
expr="network.phase_no <= 1";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=.projects[0].programs.gp[0][6].vars[1]$88$;
expr {
expr="network.min_cycles";
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=$88$;
expr {
expr="network.min_cycles_phase2";
};
};
};
};
WhileLoop @[7] {
desc="the main loop over cycles of updating";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the cycle program, which computes one cycle of activations";
flags=;
target=.projects[0].programs.gp[0][8]$89$;
targ_ld_init="*LeabraCycle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
NetCounterIncr @[1] {
desc="increment cycle counter (also on network)";
flags=;
network_var=$85$;
local_ctr_var=$86$;
counter=Network::cycle;
};
IfContinue @[2] {
desc="avoid subsequent stopping criteria if below min_cycles";
flags=;
cond {
expr="cycle < min_cycles";
};
};
IfBreak @[3] {
desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
flags=;
cond {
expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
};
};
};
test {
expr="cycle < network.cycle_max";
};
};
MethodCall @[8] {
desc="perform final operations at end of settling (storing final activations, etc)";
flags=;
result_var=NULL;
obj=$85$;
method=LeabraNetwork::Settle_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[9] {
desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
flags=;
cond {
expr="network.phase == LeabraNetwork::MINUS_PHASE";
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="compute trial-level statistics";
flags=;
result_var=NULL;
obj=$85$;
method=LeabraNetwork::Compute_TrialStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
IfElse @[10] {
desc="this stat must be called in plus phase when reward information is avail";
flags=;
cond {
expr="network.phase_no == 1";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="get external reward information";
flags=;
result_var=NULL;
obj=$85$;
method=LeabraNetwork::Compute_ExtRew;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
NetUpdateView @[11] {
desc="update network views, if update_net_view == true";
flags=;
network_var=$85$;
update_var=.projects[0].programs.gp[0][6].vars[2]$90$;
};
};
};
Program @[7] {
name="LeabraTestSettle";
tags=;
desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="current cycle of settling (local loop counter)";
};
ProgVar @[1] {
name="min_cycles";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
};
ProgVar @[2] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="if true, will update network views at end of settling";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=.projects[0].programs.gp[0][7].args[0]$91$;
local_ctr_var=.projects[0].programs.gp[0][7].vars[0]$92$;
counter=Network::cycle;
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=$91$;
local_ctr_var=$92$;
counter=Network::cycle;
};
MethodCall @[1] {
desc="resets input data, before getting new external inputs data from apply inputs call";
flags=;
result_var=NULL;
obj=$91$;
method=Network::Init_InputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[2] {
desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
flags=;
target=.projects[0].programs.gp[0][11]$93$;
targ_ld_init="*ApplyInputsTest*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
};
};
};
};
ProgramCall @[3] {
desc=;
flags=;
target=$26$;
targ_ld_init="*DA_Rew_Punish*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="TestWP";
};
};
};
};
IfElse @[4] {
desc=;
flags=;
cond {
expr="network.phase == LeabraNetwork::PLUS_PHASE";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=;
flags=;
obj=$91$;
path="cycle_max";
expr {
expr="30";
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="number of cycles to run in minus phase";
flags=;
obj=$91$;
path="cycle_max";
expr {
expr="20";
};
update_after=0;
};
};
};
MethodCall @[5] {
desc="initializes various counters at start of settling";
flags=;
result_var=NULL;
obj=$91$;
method=LeabraNetwork::Settle_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[6] {
desc="get appropriate min_cycles value depending on which phase we're in";
flags=;
cond {
expr="network.phase_no <= 1";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=.projects[0].programs.gp[0][7].vars[1]$94$;
expr {
expr="network.min_cycles";
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=$94$;
expr {
expr="network.min_cycles_phase2";
};
};
};
};
WhileLoop @[7] {
desc="the main loop over cycles of updating";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the cycle program, which computes one cycle of activations";
flags=;
target=.projects[0].programs.gp[0][9]$95$;
targ_ld_init="*LeabraTestCycle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
NetCounterIncr @[1] {
desc="increment cycle counter (also on network)";
flags=;
network_var=$91$;
local_ctr_var=$92$;
counter=Network::cycle;
};
IfContinue @[2] {
desc="avoid subsequent stopping criteria if below min_cycles";
flags=;
cond {
expr="cycle < min_cycles";
};
};
IfBreak @[3] {
desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
flags=;
cond {
expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
};
};
};
test {
expr="cycle < network.cycle_max";
};
};
MethodCall @[8] {
desc="perform final operations at end of settling (storing final activations, etc)";
flags=;
result_var=NULL;
obj=$91$;
method=LeabraNetwork::Settle_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[9] {
desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
flags=;
cond {
expr="network.phase == LeabraNetwork::MINUS_PHASE";
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="compute trial-level statistics";
flags=;
result_var=NULL;
obj=$91$;
method=LeabraNetwork::Compute_TrialStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
IfElse @[10] {
desc="this stat must be called in plus phase when reward information is avail";
flags=;
cond {
expr="network.phase_no == 1";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="get external reward information";
flags=;
result_var=NULL;
obj=$91$;
method=LeabraNetwork::Compute_ExtRew;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
NetUpdateView @[11] {
desc="update network views, if update_net_view == true";
flags=;
network_var=$91$;
update_var=.projects[0].programs.gp[0][7].vars[2]$96$;
};
};
};
Program @[8] {
name="LeabraCycle";
tags="Leabra, Std";
desc="runs one cycle of leabra processing (updating net inputs and activations)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="this does all the standard leabra processing for one cycle of activation updating";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][8].args[0]$97$;
method=LeabraNetwork::Cycle_Run;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetUpdateView @[1] {
desc="update network views if update_net_view == true";
flags=;
network_var=$97$;
update_var=.projects[0].programs.gp[0][8].vars[0]$98$;
};
ProgramCall @[2] {
desc=;
flags=OFF|NON_STD;
target=.projects[0].programs.gp[0][13]$99$;
targ_ld_init="*Cycle_Monitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
};
};
Program @[9] {
name="LeabraTestCycle";
tags=;
desc="runs one cycle of leabra processing (updating net inputs and activations)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="this does all the standard leabra processing for one cycle of activation updating";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][9].args[0]$100$;
method=LeabraNetwork::Cycle_Run;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetUpdateView @[1] {
desc="update network views if update_net_view == true";
flags=;
network_var=$100$;
update_var=.projects[0].programs.gp[0][9].vars[0]$101$;
};
ProgramCall @[2] {
desc=;
flags=;
target=$99$;
targ_ld_init="*Cycle_Monitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
};
};
};
};
};
};
Program @[10] {
name="ApplyInputs";
tags="Network, InputData, Apply";
desc="apply the current input data to the network as external input and target values";
flags=;
objs {
name=;
el_typ=LayerWriter;
el_def=0;
LayerWriter @[0] {
name="LayerWriter_0";
data=$16$;
network=$10$;
layer_data {
name=;
el_typ=LayerWriterEl;
el_def=0;
LayerWriterEl @[0] {
chan_name="Input";
net_target=LAYER;
layer_name="Input";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[1] {
chan_name="Output";
net_target=LAYER;
layer_name="Output";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[2] {
chan_name="SNc";
net_target=LAYER;
layer_name="SNc";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[3] {
chan_name="Motor_Cortex";
net_target=LAYER;
layer_name="Motor_Cortex";
offset {x=0: y=0: };
use_layer_type=0;
ext_flags=COMP;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[4] {
chan_name="Name";
net_target=TRIAL_NAME;
layer_name="Name";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
};
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="network to apply inputs to -- typically set by calling program";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$16$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="input datatable containing input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=$84$;
objs_ptr=1;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][10].vars[0]$102$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="input_data";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
flags=;
result_var=NULL;
obj=$102$;
method=taList_impl::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=$102$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="input_data";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[1] {
desc="apply inputs to the network!  layer writer has all the key specs";
flags=;
result_var=NULL;
obj=$102$;
method=LayerWriter::ApplyInputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[11] {
name="ApplyInputsTest";
tags=;
desc="apply the current input data to the network as external input and target values";
flags=;
objs {
name=;
el_typ=LayerWriter;
el_def=0;
LayerWriter @[0] {
name="LayerWriter_0";
data=$17$;
network=$10$;
layer_data {
name=;
el_typ=LayerWriterEl;
el_def=0;
LayerWriterEl @[0] {
chan_name="Input";
net_target=LAYER;
layer_name="Input";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[1] {
chan_name="Output";
net_target=LAYER;
layer_name="Output";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[2] {
chan_name="SNc";
net_target=LAYER;
layer_name="SNc";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[3] {
chan_name="Motor_Cortex";
net_target=LAYER;
layer_name="Motor_Cortex";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[4] {
chan_name="Name";
net_target=TRIAL_NAME;
layer_name="Name";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
};
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="network to apply inputs to -- typically set by calling program";
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="input datatable containing input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=.projects[0].programs.gp[0][11].objs[0]$103$;
objs_ptr=1;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][11].vars[0]$104$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="TestWP";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
flags=;
result_var=NULL;
obj=$104$;
method=taList_impl::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=$104$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="TestWP";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[1] {
desc="apply inputs to the network!  layer writer has all the key specs";
flags=;
result_var=NULL;
obj=$104$;
method=LayerWriter::ApplyInputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[12] {
name="LeabraTrialMonitor";
tags="Leabra, Std, Monitor";
desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="trial_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="trial";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="trial";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="trial_name";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="trial_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="group_name";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="group_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="phase_no";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="phase_no";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[6] {
name="minus_cycles";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="minus_cycles";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[7] {
name="sse";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[8] {
name="ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[9] {
name="Output_sse";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[7]$105$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$10$;
data=$20$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to record data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$20$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="data table to record trial-level data to (this program writes new data to this table!)";
};
ProgVar @[1] {
name="trial_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][12].objs[0]$106$;
objs_ptr=1;
flags=NULL_CHECK|USED;
reference=0;
desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="set the network and datatable for the NetMonitor";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].vars[1]$107$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="trial_mon_data";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
flags=;
result_var=NULL;
obj=$107$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
MethodCall @[2] {
desc="update the monitor items and data schema based on current settings of the NetMonitor object";
flags=;
result_var=NULL;
obj=$107$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].vars[0]$108$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[1] {
desc="get the new monitor data from the network and other sources -- this does the main work";
flags=;
result_var=NULL;
obj=$107$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[2] {
desc="update views and other things after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$108$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[3] {
desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].args[0]$109$;
method=Network::DMem_ShareTrialData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=1;
def_val=;
expr {
expr="trial_mon_data";
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="n_rows";
required=0;
def_val="1";
expr {
expr="1";
};
};
};
};
};
};
Program @[13] {
name="Cycle_Monitor";
tags=;
desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="cycle_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="trial";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="trial";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="trial_name";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="trial_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="group_name";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="group_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="phase_no";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="phase_no";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[6] {
name="cycle";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="cycle";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[7] {
name="sse";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[8] {
name="ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[9] {
name="STN_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[8]$110$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[10] {
name="Motor__acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[6]$111$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[11] {
name="Thalam_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[5]$112$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[12] {
name="GP_Int_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[3]$113$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[13] {
name="GP_Ext_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[4]$114$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[14] {
name="Output_act";
computed=0;
object_type=LeabraLayer;
object=$105$;
variable="act";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[15] {
name="Output_units_0_act";
computed=0;
object_type=LeabraLayer;
object=$105$;
variable="units[0].act";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$10$;
data=.projects[0].data.gp[1][2]$115$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to record data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$115$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="data table to record trial-level data to (this program writes new data to this table!)";
};
ProgVar @[1] {
name="cycle_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][13].objs[0]$116$;
objs_ptr=1;
flags=NULL_CHECK|USED;
reference=0;
desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="set the network and datatable for the NetMonitor";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].vars[1]$117$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="cycle_mon_data";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
flags=;
result_var=NULL;
obj=$117$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
MethodCall @[2] {
desc="update the monitor items and data schema based on current settings of the NetMonitor object";
flags=;
result_var=NULL;
obj=$117$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
IfReturn @[0] {
desc=;
flags=;
cond {
expr="network.phase_no>0";
};
};
MethodCall @[1] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].vars[0]$118$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[2] {
desc="get the new monitor data from the network and other sources -- this does the main work";
flags=;
result_var=NULL;
obj=$117$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[3] {
desc="update views and other things after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$118$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[4] {
desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].args[0]$119$;
method=Network::DMem_ShareTrialData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=1;
def_val=;
expr {
expr="cycle_mon_data";
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="n_rows";
required=0;
def_val="1";
expr {
expr="1";
};
};
};
};
};
};
Program @[14] {
name="LeabraEpochMonitor";
tags="Leabra, Std, Monitor";
desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="epoch_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="avg_sse";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="avg_sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="cnt_err";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="cnt_err";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="avg_ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="avg_ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="avg_cycles";
computed=0;
object_type=LeabraNetwork;
object=$10$;
variable="avg_cycles";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
data_agg=0;
data_src=NULL;
agg_col {
col_name=;
};
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
select_rows=0;
select_spec {
col_name=;
rel=EQUAL;
use_var=0;
cmp 0 1;
var=NULL;
};
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$10$;
data=$19$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to get data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="epoch_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$19$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="data table to write the epoch data to";
};
ProgVar @[1] {
name="epoch_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][14].objs[0]$120$;
objs_ptr=1;
flags=NULL_CHECK|USED;
reference=0;
desc="network monitor object that contains full specs for what to record and where to get it";
};
ProgVar @[2] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=$50$;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=AssignExpr;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc="get the epoch timer from current network";
flags=;
result_var=.projects[0].programs.gp[0][14].vars[2]$121$;
expr {
expr="network.epoch_time";
};
};
MethodCall @[1] {
desc="set data and network on NetMonitor object";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][14].vars[1]$122$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="epoch_mon_data";
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
};
};
};
};
MethodCall @[2] {
desc="check configuration and emit errors/warnings for problems";
flags=;
result_var=NULL;
obj=$122$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
MethodCall @[3] {
desc="update the monitor items and data schema based on current settings of NetMonitor";
flags=;
result_var=NULL;
obj=$122$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][14].vars[0]$123$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[1] {
desc="get the new monitor data and stor it into the data table -- this does the main job here";
flags=;
result_var=NULL;
obj=$122$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
AssignExpr @[2] {
desc="get the epoch timer from current network";
flags=;
result_var=$121$;
expr {
expr="network.epoch_time";
};
};
MethodCall @[3] {
desc="update after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$123$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[15] {
name="SaveWeights";
tags="Network, Weights";
desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="tag";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc="user-provided tag (startup script will set this!)";
};
ProgVar @[1] {
name="wts_subdir";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc="user-provided subdirectory to save weights in";
};
ProgVar @[2] {
name="fname";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="final generated file name -- do not edit!";
};
ProgVar @[3] {
name="epoch_str";
var_type=T_String;
string_val="0036";
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="string rep of epoch with leading zeros";
};
ProgVar @[4] {
name="batch_str";
var_type=T_String;
string_val="03";
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="string rep of batch with leading zeros";
};
ProgVar @[5] {
name="final_tag";
var_type=T_String;
string_val=".03_0036";
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc="batch + epoch";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
IfReturn @[0] {
desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
flags=;
cond {
expr="taMisc::dmem_proc > 0";
};
};
MiscCall @[1] {
desc="get current batch counter for file name, with leading zeros to length 3";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[4]$124$;
object_type=taMisc;
method=taMisc::LeadingZeros;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=int;
type="int";
name="num";
required=0;
def_val=;
expr {
expr="network.batch";
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="len";
required=0;
def_val=;
expr {
expr="2";
};
};
};
};
MiscCall @[2] {
desc="get current epoch counter with leading zeros to length 4";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[3]$125$;
object_type=taMisc;
method=taMisc::LeadingZeros;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=int;
type="int";
name="num";
required=0;
def_val=;
expr {
expr="network.epoch";
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="len";
required=0;
def_val=;
expr {
expr="4";
};
};
};
};
AssignExpr @[3] {
desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[5]$126$;
expr {
expr="tag + \".\" + batch_str + \"_\" + epoch_str";
};
};
MethodCall @[4] {
desc="get a file name based on the project's current file name, for saving the weights";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[2]$127$;
obj=.projects[0].programs.gp[0][15].args[0]$128$;
method=taBase::GetFileNameFmProject;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="ext";
required=1;
def_val=;
expr {
expr="\".wts.gz\"";
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="tag";
required=0;
def_val="\"\"";
expr {
expr="final_tag";
};
};
ProgArg @[2] {
arg_type=const_taString_ref;
type="const taString&";
name="subdir";
required=0;
def_val="\"\"";
expr {
expr="wts_subdir";
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="dmem_proc_no";
required=0;
def_val="false";
expr {
expr="false";
};
};
};
};
MethodCall @[5] {
desc="save the weights to that file name";
flags=;
result_var=NULL;
obj=$128$;
method=Network::SaveWeights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="fname";
required=0;
def_val="\"\"";
expr {
expr="fname";
};
};
ProgArg @[1] {
arg_type=Network::WtSaveFormat;
type="Network::WtSaveFormat";
name="fmt";
required=0;
def_val="Network::NET_FMT";
expr {
expr="Network::NET_FMT";
};
};
};
};
};
};
Program @[16] {
name="DA_Rew_Punish";
tags=;
desc=;
flags=;
objs {
name=;
el_typ=taNBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="network to train";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$17$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc="datatable with training patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[1] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[2] {
name="k";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[3] {
name="sse";
var_type=T_Real;
real_val=1.985028624534607;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[4] {
name="act0";
var_type=T_Real;
real_val=1.243896097236075e-10;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[5] {
name="act1";
var_type=T_Real;
real_val=0.9458604454994202;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[6] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$40$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[7] {
name="Output";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$105$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[8] {
name="Motor_Cortex";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$111$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[9] {
name="matrisom_unitspec";
var_type=T_Object;
object_type=LeabraUnitSpec;
object_val=$41$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[10] {
name="i";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[11] {
name="tonic_DA";
var_type=T_Real;
real_val=0.03;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[12] {
name="op_sse";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc=;
};
ProgVar @[13] {
name="DA_dip_val";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[14] {
name="DA_burst_val";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
};
functions {
name=;
el_typ=Function;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[1]$129$;
expr {
expr="SNc.units.size";
};
};
AssignExpr @[1] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[2]$130$;
expr {
expr="(float)num_intact_snc_units/ snc_size";
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[3]$131$;
expr {
expr="network.sse";
};
};
MemberAssign @[3] {
desc=;
flags=;
obj=.projects[0].programs.gp[0][16].vars[8]$132$;
path="units[1].bias.Cn(0).wt";
expr {
expr="10";
};
update_after=0;
};
MemberAssign @[4] {
desc=;
flags=;
obj=$132$;
path="units[1].bias.Cn(0).wt";
expr {
expr="10";
};
update_after=0;
};
IfElse @[5] {
desc="apply phasic DA in plus phase";
flags=;
cond {
expr="network.phase==LeabraNetwork::PLUS_PHASE";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
IfElse @[0] {
desc="if error is  below threshold, given DA burst";
flags=;
cond {
expr="k>0&&Output.sse<0.5";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set external input on SNC to high value for DA burst";
flags=;
obj=.projects[0].programs.gp[0][16].vars[6]$133$;
path="units[i].ext";
expr {
expr="DA_burst_val";
};
update_after=0;
};
};
init {
expr="i = 0";
};
test {
expr="i < snc_size";
};
iter {
expr="i++";
};
};
MemberAssign @[1] {
desc="set striatal gain in proportion to DA and # intact Snc units";
flags=;
obj=.projects[0].programs.gp[0][16].vars[9]$134$;
path="act.gain";
expr {
expr="k*10000";
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set DA units to 0 for DA dip";
flags=;
obj=$133$;
path="units[i].ext";
expr {
expr="DA_dip_val";
};
update_after=0;
};
};
init {
expr="i = 0";
};
test {
expr="i < snc_size";
};
iter {
expr="i++";
};
};
MemberAssign @[1] {
desc="set striatal gain to be lower for DA dip (less D1 contrast enhancement)";
flags=;
obj=$134$;
path="act.gain";
expr {
expr="600-k*300";
};
update_after=0;
};
};
};
AssignExpr @[1] {
desc="store minus phase activation of motor ctx unit 0";
flags=;
result_var=.projects[0].programs.gp[0][16].vars[4]$135$;
expr {
expr="Motor_Cortex.units[0].act_m";
};
};
AssignExpr @[2] {
desc="store minus phase act of motor unit 1";
flags=;
result_var=.projects[0].programs.gp[0][16].vars[5]$136$;
expr {
expr="Motor_Cortex.units[1].act_m";
};
};
IfElse @[3] {
desc="if model selected R1";
flags=;
cond {
expr="act0>act1";
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[0].ext";
expr {
expr="1.0";
};
update_after=0;
};
MemberAssign @[1] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[1].ext";
expr {
expr="0.0";
};
update_after=0;
};
MemberAssign @[2] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[2].ext";
expr {
expr="1.0";
};
update_after=0;
};
MemberAssign @[3] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[3].ext";
expr {
expr="0";
};
update_after=0;
};
MemberAssign @[4] {
desc="make model choose what it had in minus phase";
flags=;
obj=$132$;
path="units[0].bias.Cn(0).wt";
expr {
expr="10";
};
update_after=0;
};
MemberAssign @[5] {
desc="make model choose what it had in minus phase";
flags=;
obj=$132$;
path="units[2].bias.Cn(0).wt";
expr {
expr="10";
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[0].ext";
expr {
expr="0";
};
update_after=0;
};
MemberAssign @[1] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[1].ext";
expr {
expr="1.0";
};
update_after=0;
};
MemberAssign @[2] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[2].ext";
expr {
expr="0";
};
update_after=0;
};
MemberAssign @[3] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$132$;
path="units[3].ext";
expr {
expr="1.0";
};
update_after=0;
};
MemberAssign @[4] {
desc="make model choose what it had in minus phase";
flags=;
obj=$132$;
path="units[1].bias.Cn(0).wt";
expr {
expr="10";
};
update_after=0;
};
MemberAssign @[5] {
desc="make model choose what it had in minus phase";
flags=;
obj=$132$;
path="units[3].bias.Cn(0).wt";
expr {
expr="10";
};
update_after=0;
};
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set tonic DA val";
flags=;
obj=$133$;
path="units[i].ext";
expr {
expr="tonic_DA";
};
update_after=0;
};
MemberAssign @[1] {
desc="set striatal gain in proportion to DA and # intact Snc units";
flags=;
obj=$134$;
path="act.gain";
expr {
expr="k*2500";
};
update_after=0;
};
};
init {
expr="i = 0";
};
test {
expr="i < snc_size";
};
iter {
expr="i++";
};
};
MemberAssign @[1] {
desc="no biases during selection";
flags=;
obj=$132$;
path="units[0].bias.Cn(0).wt";
expr {
expr="0";
};
update_after=0;
};
MemberAssign @[2] {
desc="no biases";
flags=;
obj=$132$;
path="units[1].bias.Cn(0).wt";
expr {
expr="0";
};
update_after=0;
};
MemberAssign @[3] {
desc="no biases";
flags=;
obj=$132$;
path="units[2].bias.Cn(0).wt";
expr {
expr="0";
};
update_after=0;
};
MemberAssign @[4] {
desc="no biases";
flags=;
obj=$132$;
path="units[3].bias.Cn(0).wt";
expr {
expr="0";
};
update_after=0;
};
};
};
};
};
Program @[17] {
name="Calc_GoNoGo";
tags=;
desc=;
flags=;
objs {
name=;
el_typ=taNBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
reference=0;
desc="network to train";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="i";
var_type=T_Int;
int_val=39;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[1] {
name="j";
var_type=T_Int;
int_val=21;
objs_ptr=0;
flags=NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[2] {
name="B_NoGoR1";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[3] {
name="B_NoGoR2";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[4] {
name="B_GoR2";
var_type=T_Real;
real_val=7.999998807907104;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[5] {
name="B_GoR1";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[6] {
name="A_NoGoR2";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[7] {
name="A_GoR2";
var_type=T_Real;
real_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[8] {
name="A_NoGoR1";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[9] {
name="A_GoR1";
var_type=T_Real;
real_val=7.999999761581421;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[10] {
name="gn_pos";
var_type=T_Real;
real_val=15.99999856948853;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[11] {
name="gn_neg";
var_type=T_Real;
real_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[12] {
name="gn_A_R1";
var_type=T_Real;
real_val=7.999999761581421;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[13] {
name="gn_B_R1";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc=;
};
ProgVar @[14] {
name="out_data";
var_type=T_Object;
object_type=DataTable;
object_val=$21$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK|USED;
reference=0;
desc="datatable with training patterns";
};
};
functions {
name=;
el_typ=Function;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
ResetDataRows @[0] {
desc=;
flags=;
data_var=.projects[0].programs.gp[0][17].vars[14]$137$;
};
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[9]$138$;
expr {
expr="0";
};
};
AssignExpr @[1] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[5]$139$;
expr {
expr="0";
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[7]$140$;
expr {
expr="0";
};
};
AssignExpr @[3] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[4]$141$;
expr {
expr="0";
};
};
AssignExpr @[4] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[8]$142$;
expr {
expr="0";
};
};
AssignExpr @[5] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[2]$143$;
expr {
expr="0";
};
};
AssignExpr @[6] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[6]$144$;
expr {
expr="0";
};
};
AssignExpr @[7] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[3]$145$;
expr {
expr="0";
};
};
AssignExpr @[8] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[12]$146$;
expr {
expr="0";
};
};
AssignExpr @[9] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[10]$147$;
expr {
expr="0";
};
};
AssignExpr @[10] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[13]$148$;
expr {
expr="0";
};
};
AssignExpr @[11] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][17].vars[11]$149$;
expr {
expr="0";
};
};
ForLoop @[12] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$138$;
expr {
expr=".programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 0";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 0";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
ForLoop @[13] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$140$;
expr {
expr=" .programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 0";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 1";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
ForLoop @[14] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$139$;
expr {
expr=" .programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 1";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 0";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
ForLoop @[15] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$141$;
expr {
expr=" .programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 1";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 1";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
ForLoop @[16] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$142$;
expr {
expr=" .programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 0";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 2";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
ForLoop @[17] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$144$;
expr {
expr=" .programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 0";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 3";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
ForLoop @[18] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$143$;
expr {
expr=" .programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 1";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 2";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
ForLoop @[19] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
VarIncr @[0] {
desc=;
flags=;
var=$145$;
expr {
expr=" .programs.ActBasedRField.ActRFData.Input.GetValAsFloatM(i,j)";
};
};
};
init {
expr="j = 1";
};
test {
expr="j < 20";
};
iter {
expr="j=j+5";
};
};
};
init {
expr="i = 3";
};
test {
expr="i < 36";
};
iter {
expr="i=i+4";
};
};
AssignExpr @[20] {
desc=;
flags=;
result_var=$147$;
expr {
expr="(A_GoR1 -  A_NoGoR1) + (B_GoR2 - B_NoGoR2)";
};
};
AssignExpr @[21] {
desc=;
flags=;
result_var=$149$;
expr {
expr="(B_GoR1 -  B_NoGoR1) + (A_GoR2 - A_NoGoR2)";
};
};
AssignExpr @[22] {
desc=;
flags=;
result_var=$146$;
expr {
expr="(A_GoR1 -  A_NoGoR1)";
};
};
AssignExpr @[23] {
desc=;
flags=;
result_var=$148$;
expr {
expr="B_GoR1 -  B_NoGoR1";
};
};
AddNewDataRow @[24] {
desc=;
flags=;
data_var=$137$;
};
DataVarProg @[25] {
desc=;
flags=;
data_var=$137$;
set_data=1;
row_spec=CUR_ROW;
row_var=NULL;
var_1=$147$;
var_2=$149$;
var_3=$146$;
var_4=$148$;
};
DoneWritingDataRow @[26] {
desc=;
flags=;
data_var=$137$;
};
};
};
};
};
viewers {
name=;
el_typ=TopLevelViewer;
el_def=0;
MainWindowViewer @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_lft";
value 6 0=0.02202381007373333;
};
UserDataItem @[1] {
name="view_win_top";
value 6 0=0;
};
UserDataItem @[2] {
name="view_win_wd";
value 6 0=1;
};
UserDataItem @[3] {
name="view_win_ht";
value 6 0=0.8306772708892822;
};
UserDataItem @[4] {
name="view_win_iconified";
value 1 0=0;
};
UserDataItem @[5] {
name="view_splitter_state";
value 9 0="AAAA/wAAAAAAAAADAAAAyQAAAlkAAAL6AQAAAAYBAAAAAQ==";
};
};
m_data=.projects[0]$150$;
name="Browser";
visible=1;
m_is_root=0;
m_is_viewer_xor_browser=0;
m_is_proj_viewer=1;
m_is_dialog=0;
toolbars {
name=;
el_typ=ToolBar;
el_def=0;
ToolBar @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_visible";
value 1 0=1;
};
};
m_data=NULL;
name="Application";
visible=0;
lft=0;
top=0.03087649;
o=Horizontal;
};
};
frames {
name=;
el_typ=FrameViewer;
el_def=0;
tabBrowseViewer @[0] {
m_data=NULL;
name="Tree";
visible=1;
root_typ=LeabraProject;
root_md=NULL;
m_root=$150$;
};
PanelViewer @[1] {
m_data=NULL;
name="Panels";
visible=1;
};
T3DataViewer @[2] {
m_data=NULL;
name="T3Frames";
visible=1;
frames {
name=;
el_typ=T3DataViewFrame;
el_def=0;
T3DataViewFrame @[0] {
m_data=NULL;
name="Frame2";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
NetView @[0] {
m_data=$10$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
lay_disp_modes{ Input=0;Striatum=0;SNc=0;GP_Int=0;GP_Ext=0;Thalamus=0;Motor_Cortex=0;Output=0;STN=0;};
scale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=1;
zero=0;
spec=.colorspecs[0]$151$;
auto_scale=0;
};
scale_ranges {
name=;
el_typ=ScaleRange;
el_def=0;
ScaleRange @[0] {
name="act";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[1] {
name="r.wt";
auto_scale=0;
min=-0.8099999;
max=0.8099999;
};
ScaleRange @[2] {
name="act_m";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[3] {
name="act_p";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[4] {
name="ext";
auto_scale=1;
min=-10;
max=10;
};
ScaleRange @[5] {
name="net";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[6] {
name="act_eq";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[7] {
name="act_avg";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[8] {
name="act_dif";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[9] {
name="da";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[10] {
name="vcb.hyst";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[11] {
name="vcb.acc";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[12] {
name="s.wt";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[13] {
name="targ";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[14] {
name="r.pdw";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[15] {
name="wt_prjn";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[16] {
name="bias.pdw";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[17] {
name="bias.wt";
auto_scale=0;
min=-1;
max=1;
};
};
display=0;
lay_mv=1;
ordered_uvg_list{ act;};
unit_disp_mode=UDM_CYLINDER;
unit_text_disp=UTD_NONE;
max_size {x=14: y=9: z=3: };
font_sizes {
net_name=0.05;
net_vals=0.05;
layer=0.045;
layer_vals=0.03;
prjn=0.01;
unit=0.0185;
un_nm_len=3;
};
view_params {
xy_square=0;
unit_spacing=0.05;
prjn_disp=L_R_F;
prjn_name=0;
prjn_width=0.0014;
prjn_trans=0.5;
lay_trans=0.5;
unit_trans=0.6;
};
wt_line_disp=1;
wt_line_width=3;
wt_line_thr=0.5;
wt_line_swt=0;
wt_prjn_lay=NULL;
snap_bord_disp=0;
snap_bord_width=4;
};
};
};
camera_pos {x=0.6829265: y=0.6909528: z=1.383185: };
camera_orient {x=-0.6972873: y=0.6364666: z=0.3297047: rot=0.1707297: };
camera_focdist=1.827415;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[1] {
m_data=NULL;
name="CycleOutputData";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=$115$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[1][2].data[0]$152$;
m_transform=NULL;
name="batch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[1][2].data[1]$153$;
m_transform=NULL;
name="epoch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[1][2].data[2]$154$;
m_transform=NULL;
name="trial";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[1][2].data[3]$155$;
m_transform=NULL;
name="trial_name";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[1][2].data[4]$156$;
m_transform=NULL;
name="group_name";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[1][2].data[5]$157$;
m_transform=NULL;
name="phase_no";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[6] {
m_data=.projects[0].data.gp[1][2].data[6]$158$;
m_transform=NULL;
name="cycle";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=19: };
data_range {min=0: max=0: };
};
GraphColView @[7] {
m_data=.projects[0].data.gp[1][2].data[7]$159$;
m_transform=NULL;
name="sse";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[8] {
m_data=.projects[0].data.gp[1][2].data[8]$160$;
m_transform=NULL;
name="ext_rew";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[9] {
m_data=.projects[0].data.gp[1][2].data[9]$161$;
m_transform=NULL;
name="STN_acts_avg";
visible=1;
fixed_range {fix_min=0: min=7.40291e-07: fix_max=0: max=0.489291: };
data_range {min=0: max=0: };
};
GraphColView @[10] {
m_data=.projects[0].data.gp[1][2].data[10]$162$;
m_transform=NULL;
name="Motor__acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0.653348: };
data_range {min=0: max=0: };
};
GraphColView @[11] {
m_data=.projects[0].data.gp[1][2].data[11]$163$;
m_transform=NULL;
name="Thalam_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0.973635: };
data_range {min=0: max=0: };
};
GraphColView @[12] {
m_data=.projects[0].data.gp[1][2].data[12]$164$;
m_transform=NULL;
name="GP_Int_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0.558051: fix_max=0: max=0.955363: };
data_range {min=0: max=0: };
};
GraphColView @[13] {
m_data=.projects[0].data.gp[1][2].data[13]$165$;
m_transform=NULL;
name="GP_Ext_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0.992537: };
data_range {min=0: max=0: };
};
GraphColView @[14] {
m_data=.projects[0].data.gp[1][2].data[14]$166$;
m_transform=NULL;
name="Output_act";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[15] {
m_data=.projects[0].data.gp[1][2].data[15]$167$;
m_transform=NULL;
name="Output_units_0_act";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=-1: };
display_on=0;
manip_ctrl_on=1;
graph_type=XY;
plot_style=LINE;
negative_draw=0;
negative_draw_z=1;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
label_spacing=-1;
width=1;
depth=1;
axis_font_size=0.05;
label_font_size=0.04;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="cycle";
fixed_range {fix_min=0: min=0: fix_max=0: max=19: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=19: };
range {min=0: max=19: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Z;
col_name="batch";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=-6e-19: max=6e-19: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="STN_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=-6e-19: max=6e-19: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="Motor__acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0.653348: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0.6533477: };
range {min=0: max=0.6533477: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
alt_y=0;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="GP_Int_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=0: };
range {min=-6e-19: max=6e-19: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
alt_y=0;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="GP_Ext_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0.992537: };
color {name="green": r=0: g=1: b=0: a=1: desc="": };
data_range {min=0: max=0.9925367: };
range {min=0: max=0.9925367: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
alt_y=0;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="Thalam_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0.973635: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=0.9736346: };
range {min=0: max=0.9736346: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
alt_y=0;
};
alt_y_1=0;
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
err_1 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_spacing=1;
err_bar_width=0.02;
color_mode=VALUE_COLOR;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$151$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.37625: y=0.4125: z=1.389598: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=1.899598;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[2] {
m_data=NULL;
name="EpochOutputData";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=$19$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[1][1].data[0]$168$;
m_transform=NULL;
name="batch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[1][1].data[1]$169$;
m_transform=NULL;
name="epoch";
visible=1;
fixed_range {fix_min=0: min=1: fix_max=0: max=60: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[1][1].data[2]$170$;
m_transform=NULL;
name="avg_sse";
visible=1;
fixed_range {fix_min=1: min=0: fix_max=1: max=13: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[1][1].data[3]$171$;
m_transform=NULL;
name="avg_ext_rew";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[1][1].data[4]$172$;
m_transform=NULL;
name="avg_cycles";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[1][1].data[5]$173$;
m_transform=NULL;
name="cnt_err";
visible=1;
fixed_range {fix_min=1: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=-1: };
display_on=0;
manip_ctrl_on=1;
graph_type=XY;
plot_style=LINE;
negative_draw=0;
negative_draw_z=1;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
label_spacing=-1;
width=1;
depth=1;
axis_font_size=0.05;
label_font_size=0.04;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="epoch";
fixed_range {fix_min=0: min=10: fix_max=0: max=10: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=10: max=10: };
range {min=10: max=10: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name="batch";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="cnt_err";
fixed_range {fix_min=1: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=6e-19: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
alt_y=0;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
alt_y=0;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
alt_y=0;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
alt_y=0;
};
alt_y_1=0;
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
err_1 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_spacing=1;
err_bar_width=0.02;
color_mode=VALUE_COLOR;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$151$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.465: y=0.445: z=1.522513: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=2.032513;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[3] {
m_data=NULL;
name="Go_NoGo";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=$21$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[2][0].data[0]$174$;
m_transform=NULL;
name="gn_pos";
visible=1;
fixed_range {fix_min=0: min=-4: fix_max=0: max=12: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[2][0].data[1]$175$;
m_transform=NULL;
name="gn_neg";
visible=1;
fixed_range {fix_min=0: min=-20: fix_max=0: max=7.999999: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[2][0].data[2]$176$;
m_transform=NULL;
name="gn_A_R1";
visible=1;
fixed_range {fix_min=0: min=-4: fix_max=0: max=8: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[2][0].data[3]$177$;
m_transform=NULL;
name="gn_B_R1";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=-1: };
display_on=1;
manip_ctrl_on=1;
graph_type=XY;
plot_style=POINTS;
negative_draw=0;
negative_draw_z=1;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
label_spacing=-1;
width=1;
depth=1;
axis_font_size=0.05;
label_font_size=0.04;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="gn_neg";
fixed_range {fix_min=0: min=0: fix_max=0: max=-1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=-1: max=0: };
range {min=-1: max=0: };
n_ticks=10;
axis_length=1;
row_num=1;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name="gn_A_R1";
fixed_range {fix_min=0: min=-4: fix_max=0: max=8: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=-4: max=7.999999: };
range {min=-4: max=7.999999: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_pos";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=20: };
range {min=0: max=20: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_neg";
fixed_range {fix_min=0: min=0: fix_max=1: max=20: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=20: };
range {min=0: max=20: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
alt_y=0;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
alt_y=0;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
alt_y=0;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
alt_y=0;
};
alt_y_1=0;
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
err_1 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="gn_neg";
fixed_range {fix_min=0: min=-20: fix_max=0: max=8: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="gn_pos";
fixed_range {fix_min=0: min=-4: fix_max=0: max=12: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_spacing=1;
err_bar_width=0.02;
color_mode=FIXED_COLOR;
color_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_neg";
fixed_range {fix_min=0: min=-20: fix_max=0: max=7.999999: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=-20: max=7.999999: };
range {min=-20: max=7.999999: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1e-10;
max=1e-10;
range=1e-10;
zero=0;
spec=$151$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_pos";
fixed_range {fix_min=0: min=-4: fix_max=0: max=12: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=-4: max=12: };
range {min=-4: max=12: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.515: y=0.445: z=1.730968: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=1.743468;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[4] {
m_data=NULL;
name="Go_NoGo_Group";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=.projects[0].data.gp[2][1]$178$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[2][1].data[0]$179$;
m_transform=NULL;
name="gn_pos_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[2][1].data[1]$180$;
m_transform=NULL;
name="gn_pos_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[2][1].data[2]$181$;
m_transform=NULL;
name="gn_neg_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[2][1].data[3]$182$;
m_transform=NULL;
name="gn_neg_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[2][1].data[4]$183$;
m_transform=NULL;
name="gn_A_R1_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[2][1].data[5]$184$;
m_transform=NULL;
name="gn_A_R1_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[6] {
m_data=.projects[0].data.gp[2][1].data[6]$185$;
m_transform=NULL;
name="gn_B_R1_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[7] {
m_data=.projects[0].data.gp[2][1].data[7]$186$;
m_transform=NULL;
name="gn_B_R1_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=0: };
display_on=1;
manip_ctrl_on=1;
graph_type=BAR;
plot_style=LINE;
negative_draw=0;
negative_draw_z=1;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
label_spacing=-1;
width=1;
depth=1;
axis_font_size=0.05;
label_font_size=0.04;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="gn_pos_mean";
fixed_range {fix_min=1: min=-1: fix_max=1: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=-1: max=1: };
range {min=-1: max=1: };
n_ticks=10;
axis_length=1;
row_num=1;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_pos_mean";
fixed_range {fix_min=1: min=-10: fix_max=1: max=10: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=-10: max=10: };
range {min=-10: max=10: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_neg_mean";
fixed_range {fix_min=0: min=-0.4766051: fix_max=0: max=-0.4766051: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=-0.4766051: max=-0.4766051: };
range {min=-0.4766051: max=-0.4766051: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
alt_y=0;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
alt_y=0;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
alt_y=0;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
alt_y=0;
};
alt_y_1=0;
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
err_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_pos_sem";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_neg_sem";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
alt_y=0;
};
err_spacing=1;
err_bar_width=0.02;
color_mode=FIXED_COLOR;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$151$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="gn_pos_mean";
fixed_range {fix_min=0: min=3.2: fix_max=0: max=3.2: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=3.2: max=3.2: };
range {min=3.1998: max=3.2002: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.431658: y=0.445: z=1.67843: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=1.69093;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
};
};
};
docks {
name=;
el_typ=DockViewer;
el_def=0;
ToolBoxDockViewer @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_lft";
value 6 0=0;
};
UserDataItem @[1] {
name="view_win_top";
value 6 0=0.06474103778600693;
};
UserDataItem @[2] {
name="view_win_wd";
value 6 0=0.0535714291036129;
};
UserDataItem @[3] {
name="view_win_ht";
value 6 0=0.7131474018096924;
};
UserDataItem @[4] {
name="view_win_iconified";
value 1 0=0;
};
UserDataItem @[5] {
name="view_visible";
value 1 0=1;
};
};
m_data=NULL;
name="Tools";
visible=1;
dock_flags=DV_MOVABLE|DV_FLOATABLE;
dock_area=1;
};
};
};
};
use_change_log=0;
last_change_desc="
";
networks {
name=;
el_typ=LeabraNetwork;
el_def=0;
LeabraNetwork @[0] {
name="BGNet";
desc=;
specs {
name=;
el_typ=ConSpec;
el_def=0;
ConSpec @[0] {
name="ConSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=ConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0: var=0.5: par=1: };
wt_limits {type=NONE: min=-1: max=1: sym=0: };
};
UniformRndPrjnSpec @[1] {
name="STN_GPe_RndPrjnSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=UniformRndPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
p_con=1;
sym_self=1;
same_seed=0;
rndm_seed {
name=;
seed{ 1942590695;1834211083;377798523;839440218;-583226373;705799995;-1978402924;1154338458;-462115379;246653898;1399794034;-1499780727;-1523899271;930991332;1290781086;1827104268;-716397506;1983718083;1167094774;951783845;-409479048;-735831888;435869947;-904086293;2026496515;403361634;-1944445990;-1372202487;2126959386;162557442;1012427038;1588232218;-1146450552;-853562653;-1656209805;-1888253373;1759765356;1728652414;-337014879;-1280803374;-575509963;-1765188122;-384524531;-821312351;-1870977276;1513531657;1301908149;699607679;871722190;941230124;480719736;-879564786;-698046303;1521335322;-1447079851;-716252964;526031609;1993676142;1340787872;1530654116;-969427509;1134915315;2122089688;-994370515;560929468;389650548;-1122373860;166734577;-286623372;-120943880;891391534;1880819345;-178283282;540924398;-472340061;2110112996;-1254638769;1538060551;1673190834;691970619;-959237381;-1357813313;1768507679;-1214978919;785612098;1900739683;2119690407;432529262;1597777345;-76740981;1752989913;507595810;1970077571;2120922148;-975091467;-1195485087;-2116172007;-1448521787;-1611468311;1523616406;1943148525;-1864229143;-937095503;-909740123;1292237191;387974384;538406262;509446046;-1972547268;-1733600336;-62144424;-1546025606;-1876304799;1885604132;1402880751;-482628413;1554473651;267768126;-629382805;-1249311349;-1924387261;1461040170;509667270;-779074633;-17507771;918255996;-143015157;-2090640919;315301152;702021484;808635402;-2068859673;-1347883889;1693940293;1805057885;-1668427604;-2137413199;-1104482850;208495526;118430790;-722180698;-1217415633;-224256734;1932248267;-1065779137;-10863097;487580081;-196290919;680669227;1979774005;-2037050706;21949689;-156516075;1715173136;1755205487;1472371560;1309034448;-829238765;-135616049;-2013309212;-1082863329;-899363014;-1287869739;-870456151;581622390;-1908234714;-1126900746;764733716;-925858573;-1751091051;-463341148;644681747;-1914494877;373038127;1588478313;1485299105;661291536;-1180395328;-1144161539;94598643;-1088175949;1032986199;-1100837220;407686955;-1082470443;1911682705;1627415103;310787166;1264015414;424266369;-2027001547;-1752167701;-228113290;1600850810;-2083186300;-1987228633;2000848866;-1395386373;80656148;317238254;-1145747623;-511425939;1346724944;180295410;-544883384;1732680478;-1525854862;236088797;1630557266;1645104332;445726791;1077576696;-2008807651;-2004400849;1274587809;1448655060;1550063216;454064067;-221087611;-594550512;-1272829249;1417249337;463284529;432100395;1078285484;-959540334;21248325;-866258652;-1081481128;-1833368508;-1379133116;-1920337657;-1251994147;1350814969;1508926409;1457463506;-436457777;-104638987;-300707471;-917721278;-620891785;523732153;445406412;1634813528;463926328;1581054136;170598643;-416905380;-1864557289;-202014810;1443533836;-1579728646;-1569783365;398032325;603645793;1459091613;-89353942;-1032688516;-1615894428;-767185823;-1946032362;931360128;-836341533;-1238311242;26872554;-1198342849;223875202;1787898723;1347039535;1426899535;712166878;1007370589;-2121265931;1279068215;1048275580;665564878;-854576448;1115606454;-1938871068;437377701;1893989311;60057612;-1411480578;-1802660403;-1229197402;-1114162509;1246510289;-100045555;-771237462;-321537560;1645429527;876081854;-344012824;613155858;-58817405;150811542;-10210852;2112860797;-528954460;-50850354;-649972970;1499955930;1421666445;1351215729;-1262602010;-980699257;1941355339;-961944897;-413046848;-411502877;522743470;-1432644237;-1120760559;-776500101;-1809149014;2127519490;470896056;662683123;-567303983;121758873;-1581863489;-91906121;-996490915;1435662432;1657906168;-1808273636;-1008367748;1370467542;775127407;336430775;908983458;-1287820551;2018562582;684733517;1364159782;839309547;1634308483;-497817377;118348535;-1269053010;955697418;-461911650;286131813;-300370221;1037538534;2023161463;-259022712;-1784489335;970316778;1578200481;500283714;1165730615;1099858613;850929875;-122366113;1415506233;-119359212;-2033313111;2063284557;168272506;1014246244;1972611072;1049837341;2120277277;-1358473916;867839429;1548671628;375995816;335745466;-92761852;-1313606594;983851877;957484913;-786771928;1174167013;457619777;1577173252;29408666;-1853196004;-954511750;-9741238;1764765760;-1106091459;418868525;1218646124;244543749;1280742435;-1669454769;1391623016;-1782787888;1672996012;-660347923;1734104018;-70130822;-1181208948;-285723476;-1959961034;42073851;-1354695576;-548612189;-692983842;1398992433;-1954474622;-414265610;1827986420;-1740813210;392408431;812967600;306150025;1150550306;-1577525793;522329421;-1905599679;1183746118;1873227418;113271279;-118624832;2064640613;91279896;-1296994070;923686864;-1237563925;-671532219;432504743;376157897;-1964026811;-509307951;-1291095292;-92298376;-440266966;742491999;-363297213;907719292;-2097711796;-72292200;797405338;-902353499;-166246906;-943459407;-1618209704;296966888;276718739;881687730;-63517562;-481360418;-1200473828;-144528583;2055425204;425514158;-972984629;-437772543;955225817;-1571664087;1255280381;-1520917476;411210494;-1044569805;1196139168;1000345811;314304961;788619297;-1721237341;1855193732;-688848034;-560160224;110451616;205166806;1045130054;606457223;-106064310;-350539693;-1199925658;-1553567608;1827860289;-495518821;-289479856;-1888403873;66174658;-1741606928;-1734480553;1792669379;2112354548;649961546;-1072485902;1950021075;-145032130;-1448841129;-455451267;-1966366114;-1298920795;837046384;-1783493271;1554055716;544335337;-302006934;-149606522;2022999324;826072250;-549276476;1862748770;1989186214;1089115433;956552701;1745621701;-2034815611;614102796;1479888671;-146686913;-690079684;-1114868597;-2016690506;2090920277;-830594320;-1261017876;2072821639;194345641;-1605828714;484660319;-454560202;1794417171;511341824;-1255389158;-669363423;1164033229;-1107097310;828519990;1450362036;476068860;1972265003;-1879752310;1894610209;-2128722743;1301770305;-1624467838;-731973801;-337476939;-1809040191;1525193216;-2001741915;-2027225998;-1162995606;-717541281;2050620663;-1135005089;2015601957;-1661832271;334966618;-236871560;-2075212969;-2141684690;1078043241;1723366617;828122061;147352703;-1999649046;-903143402;-1024430520;1633016716;-1604804280;1647853874;1626223577;613437415;854959232;-1237163556;-230090669;-278438371;1723117265;500023237;-1216412905;1717506101;1373064296;1994723034;1814828511;2067592941;937637146;-1370177392;-1274587966;-48108349;-378201671;1262614325;62390688;164974972;-830307263;-1714046089;1359544797;2016161042;83584009;930716322;-497279679;2023049077;-206104661;1501245447;562523072;104611198;-46372430;298890283;2110698786;-1091302072;20052267;-1304541777;140132249;-1245355586;-727077616;-316829592;152731111;-154344094;1345278005;-558417490;1281066959;-1469762051;-383552934;199222085;413618054;1552260824;-576003758;105415137;2042323739;1646910169;1084993049;840296744;216680633;1409468883;-1555896089;734078106;};
mti=115;
};
};
UniformRndPrjnSpec @[2] {
name="GPe_STN_RndPrjnSpec_1";
desc=;
unique{ };
children {
name=;
el_typ=UniformRndPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
p_con=0.4;
sym_self=1;
same_seed=0;
rndm_seed {
name=;
seed{ 1942590695;1834211083;377798523;839440218;-583226373;705799995;-1978402924;1154338458;-462115379;246653898;1399794034;-1499780727;-1523899271;930991332;1290781086;1827104268;-716397506;1983718083;1167094774;951783845;-409479048;-735831888;435869947;-904086293;2026496515;403361634;-1944445990;-1372202487;2126959386;162557442;1012427038;1588232218;-1146450552;-853562653;-1656209805;-1888253373;1759765356;1728652414;-337014879;-1280803374;-575509963;-1765188122;-384524531;-821312351;-1870977276;1513531657;1301908149;699607679;871722190;941230124;480719736;-879564786;-698046303;1521335322;-1447079851;-716252964;526031609;1993676142;1340787872;1530654116;-969427509;1134915315;2122089688;-994370515;560929468;389650548;-1122373860;166734577;-286623372;-120943880;891391534;1880819345;-178283282;540924398;-472340061;2110112996;-1254638769;1538060551;1673190834;691970619;-959237381;-1357813313;1768507679;-1214978919;785612098;1900739683;2119690407;432529262;1597777345;-76740981;1752989913;507595810;1970077571;2120922148;-975091467;-1195485087;-2116172007;-1448521787;-1611468311;1523616406;1943148525;-1864229143;-937095503;-909740123;1292237191;387974384;538406262;509446046;-1972547268;-1733600336;-62144424;-1546025606;-1876304799;1885604132;1402880751;-482628413;1554473651;267768126;-629382805;-1249311349;-1924387261;1461040170;509667270;-779074633;-17507771;918255996;-143015157;-2090640919;315301152;702021484;808635402;-2068859673;-1347883889;1693940293;1805057885;-1668427604;-2137413199;-1104482850;208495526;118430790;-722180698;-1217415633;-224256734;1932248267;-1065779137;-10863097;487580081;-196290919;680669227;1979774005;-2037050706;21949689;-156516075;1715173136;1755205487;1472371560;1309034448;-829238765;-135616049;-2013309212;-1082863329;-899363014;-1287869739;-870456151;581622390;-1908234714;-1126900746;764733716;-925858573;-1751091051;-463341148;644681747;-1914494877;373038127;1588478313;1485299105;661291536;-1180395328;-1144161539;94598643;-1088175949;1032986199;-1100837220;407686955;-1082470443;1911682705;1627415103;310787166;1264015414;424266369;-2027001547;-1752167701;-228113290;1600850810;-2083186300;-1987228633;2000848866;-1395386373;80656148;317238254;-1145747623;-511425939;1346724944;180295410;-544883384;1732680478;-1525854862;236088797;1630557266;1645104332;445726791;1077576696;-2008807651;-2004400849;1274587809;1448655060;1550063216;454064067;-221087611;-594550512;-1272829249;1417249337;463284529;432100395;1078285484;-959540334;21248325;-866258652;-1081481128;-1833368508;-1379133116;-1920337657;-1251994147;1350814969;1508926409;1457463506;-436457777;-104638987;-300707471;-917721278;-620891785;523732153;445406412;1634813528;463926328;1581054136;170598643;-416905380;-1864557289;-202014810;1443533836;-1579728646;-1569783365;398032325;603645793;1459091613;-89353942;-1032688516;-1615894428;-767185823;-1946032362;931360128;-836341533;-1238311242;26872554;-1198342849;223875202;1787898723;1347039535;1426899535;712166878;1007370589;-2121265931;1279068215;1048275580;665564878;-854576448;1115606454;-1938871068;437377701;1893989311;60057612;-1411480578;-1802660403;-1229197402;-1114162509;1246510289;-100045555;-771237462;-321537560;1645429527;876081854;-344012824;613155858;-58817405;150811542;-10210852;2112860797;-528954460;-50850354;-649972970;1499955930;1421666445;1351215729;-1262602010;-980699257;1941355339;-961944897;-413046848;-411502877;522743470;-1432644237;-1120760559;-776500101;-1809149014;2127519490;470896056;662683123;-567303983;121758873;-1581863489;-91906121;-996490915;1435662432;1657906168;-1808273636;-1008367748;1370467542;775127407;336430775;908983458;-1287820551;2018562582;684733517;1364159782;839309547;1634308483;-497817377;118348535;-1269053010;955697418;-461911650;286131813;-300370221;1037538534;2023161463;-259022712;-1784489335;970316778;1578200481;500283714;1165730615;1099858613;850929875;-122366113;1415506233;-119359212;-2033313111;2063284557;168272506;1014246244;1972611072;1049837341;2120277277;-1358473916;867839429;1548671628;375995816;335745466;-92761852;-1313606594;983851877;957484913;-786771928;1174167013;457619777;1577173252;29408666;-1853196004;-954511750;-9741238;1764765760;-1106091459;418868525;1218646124;244543749;1280742435;-1669454769;1391623016;-1782787888;1672996012;-660347923;1734104018;-70130822;-1181208948;-285723476;-1959961034;42073851;-1354695576;-548612189;-692983842;1398992433;-1954474622;-414265610;1827986420;-1740813210;392408431;812967600;306150025;1150550306;-1577525793;522329421;-1905599679;1183746118;1873227418;113271279;-118624832;2064640613;91279896;-1296994070;923686864;-1237563925;-671532219;432504743;376157897;-1964026811;-509307951;-1291095292;-92298376;-440266966;742491999;-363297213;907719292;-2097711796;-72292200;797405338;-902353499;-166246906;-943459407;-1618209704;296966888;276718739;881687730;-63517562;-481360418;-1200473828;-144528583;2055425204;425514158;-972984629;-437772543;955225817;-1571664087;1255280381;-1520917476;411210494;-1044569805;1196139168;1000345811;314304961;788619297;-1721237341;1855193732;-688848034;-560160224;110451616;205166806;1045130054;606457223;-106064310;-350539693;-1199925658;-1553567608;1827860289;-495518821;-289479856;-1888403873;66174658;-1741606928;-1734480553;1792669379;2112354548;649961546;-1072485902;1950021075;-145032130;-1448841129;-455451267;-1966366114;-1298920795;837046384;-1783493271;1554055716;544335337;-302006934;-149606522;2022999324;826072250;-549276476;1862748770;1989186214;1089115433;956552701;1745621701;-2034815611;614102796;1479888671;-146686913;-690079684;-1114868597;-2016690506;2090920277;-830594320;-1261017876;2072821639;194345641;-1605828714;484660319;-454560202;1794417171;511341824;-1255389158;-669363423;1164033229;-1107097310;828519990;1450362036;476068860;1972265003;-1879752310;1894610209;-2128722743;1301770305;-1624467838;-731973801;-337476939;-1809040191;1525193216;-2001741915;-2027225998;-1162995606;-717541281;2050620663;-1135005089;2015601957;-1661832271;334966618;-236871560;-2075212969;-2141684690;1078043241;1723366617;828122061;147352703;-1999649046;-903143402;-1024430520;1633016716;-1604804280;1647853874;1626223577;613437415;854959232;-1237163556;-230090669;-278438371;1723117265;500023237;-1216412905;1717506101;1373064296;1994723034;1814828511;2067592941;937637146;-1370177392;-1274587966;-48108349;-378201671;1262614325;62390688;164974972;-830307263;-1714046089;1359544797;2016161042;83584009;930716322;-497279679;2023049077;-206104661;1501245447;562523072;104611198;-46372430;298890283;2110698786;-1091302072;20052267;-1304541777;140132249;-1245355586;-727077616;-316829592;152731111;-154344094;1345278005;-558417490;1281066959;-1469762051;-383552934;199222085;413618054;1552260824;-576003758;105415137;2042323739;1646910169;1084993049;840296744;216680633;1409468883;-1555896089;734078106;};
mti=115;
};
};
BaseSpec_Group @.gp[0] {
name="LeabraPrjns";
el_typ=LeabraUnitSpec;
el_def=0;
FullPrjnSpec @[0] {
name="FullPrjnSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=FullPrjnSpec;
el_def=0;
};
self_con=1;
init_wts=0;
};
OneToOnePrjnSpec @[1] {
name="OneToOne";
desc=;
unique{ self_con;};
children {
name=;
el_typ=OneToOnePrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
n_conns=-1;
recv_start=0;
send_start=0;
};
TesselPrjnSpec @[2] {
name="Striatum_GPext";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
TesselPrjnSpec @[0] {
name="PFC_Act_Deep";
desc=;
unique{ send_scale;};
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=0: };
send_border {x=1: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[12] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[13] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[14] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[15] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[16] {
send_off {x=1: y=8: };
wt_val=1;
};
TessEl @[17] {
send_off {x=1: y=8: };
wt_val=1;
};
};
};
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=1: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[12] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[13] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[14] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[15] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[16] {
send_off {x=1: y=8: };
wt_val=1;
};
TessEl @[17] {
send_off {x=1: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[3] {
name="dMatrosomesGP";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=0;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[5] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=6: };
wt_val=1;
};
TessEl @[7] {
send_off {x=0: y=7: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[4] {
name="SNc_GO";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=2: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
};
};
TesselPrjnSpec @[5] {
name="MotorCortex_Striatum";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
};
};
TesselPrjnSpec @[6] {
name="SNc_NOGO";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=2: y=0: };
recv_n {x=2: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
};
};
TesselPrjnSpec @[7] {
name="Striatum_GPInt";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=5: };
wrap=0;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[5] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=6: };
wt_val=1;
};
TessEl @[7] {
send_off {x=0: y=7: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[8] {
name="MotorCortex_NoGoStriatum";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=2: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
};
};
OneToOnePrjnSpec @[9] {
name="OneToOne_2";
desc=;
unique{ self_con;};
children {
name=;
el_typ=OneToOnePrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
n_conns=-1;
recv_start=0;
send_start=2;
};
};
BaseSpec_Group @.gp[1] {
name="Connections";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraBiasSpec @[0] {
name="LearnBias";
desc=;
unique{ rnd;wt_limits;wt_scale;wt_scale_init;};
children {
name=;
el_typ=LeabraBiasSpec;
el_def=0;
LeabraBiasSpec @[0] {
name="FixedBias";
desc=;
unique{ lrate;wt_limits;wt_scale;wt_scale_init;};
children {
name=;
el_typ=LeabraBiasSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
wt_limits {type=NONE: min=-1: max=5: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0: err=1: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
dwt_thresh=0.1;
};
};
rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
wt_limits {type=NONE: min=-1: max=5: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0.01;
cur_lrate=0.01;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0: err=1: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
dwt_thresh=0.1;
};
LeabraConSpec @[1] {
name="FixedFull";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=3: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[2] {
name="GPeGPiInhib";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
LeabraConSpec @[0] {
name="ThalInhib";
desc=;
unique{ wt_scale;wt_sig;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
learn_rule=LEABRA_CHL;
inhib=1;
wt_scale {abs=1: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[1] {
name="Inhib_Learn";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.35: var=0.1: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
learn_rule=LEABRA_CHL;
inhib=1;
wt_scale {abs=8: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=1e-05;
cur_lrate=1e-05;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
learn_rule=LEABRA_CHL;
inhib=1;
wt_scale {abs=1.75: rel=1.5: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[3] {
name="Fixed";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
LeabraConSpec @[0] {
name="STNcons";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.21: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=0.7: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[1] {
name="MotorCortex_Striatum";
desc=;
unique{ rnd;wt_limits;wt_scale;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.06: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=1.5: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[2] {
name="Motor_NoGo";
desc=;
unique{ rnd;wt_limits;wt_scale;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.06: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=0.5: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[3] {
name="Input_Motor_Prepotent_";
desc=;
unique{ rnd;wt_scale;lrate;lmix;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.35: var=0.005: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=3: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=1e-06;
cur_lrate=1e-06;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=1: err=0: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[4] {
name="InputStriatum";
desc=;
unique{ rnd;wt_scale;lrate;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.001: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[5] {
name="STN_GPi";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.21: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=0.55: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=1e-04;
cur_lrate=1e-04;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[6] {
name="Mtr_STNcons";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.65: var=0.2: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
rnd {name="": type=UNIFORM: mean=0.1: var=0.01: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0.001;
cur_lrate=0.0075;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[4] {
name="Dopamine_D1_";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=0;
wt_scale {abs=0.5: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[5] {
name="SNc_Inhib_D2_";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
learn_rule=LEABRA_CHL;
inhib=1;
wt_scale {abs=0.5: rel=0.75: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[6] {
name="Inhib";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.7: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
learn_rule=LEABRA_CHL;
inhib=1;
wt_scale {abs=3: rel=2.25: };
wt_scale_init {init=0: abs=1: rel=1: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=1;
};
wt_sig {gain=6: off=1.25: };
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
dwt_norm {
on=0;
norm_pct=1;
};
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
BaseSpec_Group @.gp[2] {
name="Units";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="FixedBiasUnitSpec";
desc=;
unique{ opt_thresh;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="GPExt_UnitSpec";
desc=;
unique{ bias_spec;act;opt_thresh;v_m_init;dt;g_bar;e_rev;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[0]$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.26: var=0: par=1: };
dt {vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=2.5: h=0.1: a=0.5: };
e_rev {e=1: l=0.255: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="OutputUnitSpec";
desc=;
unique{ bias_spec;act;opt_thresh;g_bar;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.2: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[2] {
name="Thalamus";
desc=;
unique{ bias_spec;opt_thresh;dt;g_bar;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.4: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=0.5: l=0.07: i=1.7: h=0.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[3] {
name="LearnBiasUnitSpec";
desc=;
unique{ bias_spec;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="matrisom_unitspec";
desc=;
unique{ bias_spec;act;opt_thresh;g_bar;act_reg;noise_type;noise;dt;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.26: gain=2500: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.5: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=1: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=VM_NOISE;
noise {name="": type=GAUSSIAN: mean=0.001: var=0: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=1;
};
};
LeabraUnitSpec @[1] {
name="Motor_Cortex_unitspec";
desc=;
unique{ bias_spec;opt_thresh;dt;acc;noise_type;noise;noise_sched;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.005: b_dec_dt=0.01: a_thr=0.25: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=VM_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.0015: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=32;
default_val=1;
interpolate=1;
cur_val=0.9363636;
SchedItem @[0] {
start_ctr=0;
start_val=1;
duration=25;
step=0;
};
SchedItem @[1] {
start_ctr=25;
start_val=1;
duration=55;
step=-0.009090909;
};
SchedItem @[2] {
start_ctr=80;
start_val=0.5;
duration=20;
step=-0.015;
};
SchedItem @[3] {
start_ctr=100;
start_val=0.2;
duration=1;
step=1;
};
};
};
LeabraUnitSpec @[2] {
name="STN_unitspec";
desc=;
unique{ bias_spec;act;opt_thresh;v_m_init;dt;g_bar;e_rev;noise_type;noise;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.25: var=0: par=1: };
dt {vm=0.045: net=0.17: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.2: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0]$188$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[4] {
name="GPInt_UnitSpec";
desc=;
unique{ bias_spec;opt_thresh;v_m_init;dt;g_bar;e_rev;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.26: var=0: par=1: };
dt {vm=0.2: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=3: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.275: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="SNc_UnitSpec";
desc=;
unique{ opt_thresh;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$187$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=100: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {g_gain=4: rise=1: decay=0.05: window=20: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
syn_delay {
on=0;
delay=4;
};
opt_thresh {send=0.1: delta=0.005: learn=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.95: net=1: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
act_reg {on=0: bias_only=0: min=0.001: max=0.35: dec_wt=0.2: inc_wt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NETIN_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.002: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=1;
};
};
};
BaseSpec_Group @.gp[3] {
name="LayerSpecs";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="LayerSpec_0";
desc=;
unique{ kwta;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="Matrisome_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;clamp;decay;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="GP_layerspec";
desc=;
unique{ kwta;compute_i;i_kwta_pt;clamp;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=0: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[2] {
name="Thalamus_layerspec";
desc=;
unique{ kwta;compute_i;decay;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[3] {
name="Output_layerspec";
desc=;
unique{ kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[4] {
name="PFC_Out_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=LAY_AND_GPS;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[5] {
name="InputLayer";
desc=;
unique{ kwta;compute_i;i_kwta_pt;clamp;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.25;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[6] {
name="SNc_layerspec";
desc=;
unique{ kwta;compute_i;clamp;inhib;decay;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=0: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="NoDecayLayers";
desc=;
unique{ };
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="STN";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="PFCIn_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=LAY_AND_GPS;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=5: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.25;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
ct_inhib_mod {
use_sin=0;
burst_i=0.02;
trough_i=0.02;
use_fin=0;
inhib_i=0;
};
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
};
layers {
name=;
el_typ=LeabraLayer;
el_def=0;
pos {x=0: y=0: z=0: };
LeabraLayer @[0] {
name="Input";
flags=;
layer_type=INPUT;
pos {x=1: y=0: z=2: };
un_geom {x=5: y=5: n_not_xy=0: n=25: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=5: y=5: n_not_xy=0: n=25: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[6].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=5: y=5: n_not_xy=0: n=25: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0]$189$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.1524: max=0.95: max_i=1: };
acts_m {avg=0.1524: max=0.95: max_i=1: };
phase_dif_ratio=1;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=1: pct=0.04: pct_c=0.96: adth_k=1: k_ithr=-0.1: k1_ithr=-0.1: ithr_r=0: ithr_diff=-0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.04: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[5]$190$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[1] {
name="Striatum";
flags=;
layer_type=HIDDEN;
pos {x=1: y=0: z=1: };
un_geom {x=4: y=9: n_not_xy=0: n=36: };
unit_groups=0;
gp_geom {x=2: y=2: n_not_xy=0: n=4: };
gp_spc {x=0: y=0: };
act_geom {x=4: y=9: n_not_xy=0: n=36: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Input";
from_type=CUSTOM;
from=.projects[0].networks[0].layers[0]$191$;
spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][0]$192$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[4]$193$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_SNc";
from_type=CUSTOM;
from=$40$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][4]$194$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][4]$195$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[2] {
name="Fm_SNc";
from_type=CUSTOM;
from=$40$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][6]$196$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][5]$197$: };
recv_idx=2;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[3] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$111$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][8]$198$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[2]$199$: };
recv_idx=3;
send_idx=4;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[4] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$111$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][5]$200$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[1]$201$: };
recv_idx=4;
send_idx=5;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[0];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=4: y=9: n_not_xy=0: n=36: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=$41$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="Go-R1";
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.07499253: max=0.8553549: max_i=19: };
acts_m {avg=0.100952: max=0.8515428: max_i=5: };
phase_dif_ratio=1.346161;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=3: pct=0.08333334: pct_c=0.9166667: adth_k=1: k_ithr=5.17522: k1_ithr=5.059398: ithr_r=0.02263426: ithr_diff=0.02238008: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.08333334: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=1: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[0]$202$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[2] {
name="SNc";
flags=;
layer_type=INPUT;
pos {x=2: y=0: z=0: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[1].projections[2];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][1]$203$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0: max=0: max_i=0: };
acts_m {avg=0.6499065: max=0.7069085: max_i=0: };
phase_dif_ratio=1;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[6]$204$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[3] {
name="GP_Int";
flags=;
layer_type=HIDDEN;
pos {x=6: y=0: z=0: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Striatum";
from_type=CUSTOM;
from=$11$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][7]$205$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2].children[1]$206$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_GP_Ext";
from_type=CUSTOM;
from=$114$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][2]$207$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2]$208$: };
recv_idx=1;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[2] {
name="Fm_STN";
from_type=CUSTOM;
from=$110$;
spec {type=FullPrjnSpec: spec=$192$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[5]$209$: };
recv_idx=2;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[5].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[4]$210$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R2";
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.2917129: max=0.6120189: max_i=2: };
acts_m {avg=0.4582863: max=0.9269085: max_i=2: };
phase_dif_ratio=1.571018;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=1.09251: k1_ithr=1.09251: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.25: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=3: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[1]$211$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[4] {
name="GP_Ext";
flags=;
layer_type=HIDDEN;
pos {x=6: y=4: z=0: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Striatum";
from_type=CUSTOM;
from=$11$;
spec {type=TesselPrjnSpec: spec=$207$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][6]$212$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_STN";
from_type=CUSTOM;
from=$110$;
spec {type=UniformRndPrjnSpec: spec=.projects[0].networks[0].specs[1]$213$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[0]$214$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[8].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[0]$215$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.4866218: max=0.9478751: max_i=0: };
acts_m {avg=0.9774159: max=0.9799542: max_i=0: };
phase_dif_ratio=2.008574;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0.0999999: k1_ithr=0.0999999: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.5: i_kwta_pt=0.5: g_bar_i=2.5: g_bar_l=1: };
maxda=0;
spec {type=LeabraLayerSpec: spec=$211$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[5] {
name="Thalamus";
flags=;
layer_type=HIDDEN;
pos {x=12: y=0: z=1: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_GP_Int";
from_type=CUSTOM;
from=$113$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][3]$216$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2].children[0]$217$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$111$;
spec {type=TesselPrjnSpec: spec=$216$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][1]$218$: };
recv_idx=1;
send_idx=3;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[6].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[2]$219$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.4950864: max=0.9901728: max_i=1: };
acts_m {avg=0.4947112: max=0.9894224: max_i=1: };
phase_dif_ratio=0.9992422;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0.979331: k1_ithr=0.746659: ithr_r=0.271261: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.5: i_kwta_pt=0.6: g_bar_i=1.7: g_bar_l=0.07: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[2]$220$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[6] {
name="Motor_Cortex";
flags=NO_ADD_SSE|NO_ADD_COMP_SSE;
layer_type=TARGET;
pos {x=10: y=0: z=2: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Thalamus";
from_type=CUSTOM;
from=$112$;
spec {type=TesselPrjnSpec: spec=$216$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$218$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Input";
from_type=CUSTOM;
from=$191$;
spec {type=FullPrjnSpec: spec=$192$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[3]$221$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[5].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[7].projections[0];
Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[7].projections[1];
Projection_Group @. = [3] = LeabraPrjn .projects[0].networks[0].layers[8].projections[0];
Projection_Group @. = [4] = LeabraPrjn .projects[0].networks[0].layers[1].projections[3];
Projection_Group @. = [5] = LeabraPrjn .projects[0].networks[0].layers[1].projections[4];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[3].children[1]$222$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.4847139: max=0.9699549: max_i=1: };
acts_m {avg=0.4726377: max=0.9458604: max_i=1: };
phase_dif_ratio=0.975086;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=3: pct=0.75: pct_c=0.25: adth_k=1: k_ithr=7.382177: k1_ithr=7.319876: ithr_r=0.00847517: ithr_diff=0.008439338: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.75: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0]$223$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[7] {
name="Output";
flags=;
layer_type=TARGET;
pos {x=8: y=6: z=2: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$111$;
spec {type=TesselPrjnSpec: spec=$205$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$218$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$111$;
spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[0][9]$224$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$218$: };
recv_idx=1;
send_idx=2;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[1]$225$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=1.985029;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.475: max=0.95: max_i=0: };
acts_m {avg=0.496243: max=0.9924861: max_i=1: };
phase_dif_ratio=1.044722;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=2.332253: k1_ithr=1.185901: ithr_r=0.6763322: ithr_diff=0.4915214: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.5: i_kwta_pt=0: g_bar_i=1: g_bar_l=1: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[3]$226$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[8] {
name="STN";
flags=;
layer_type=HIDDEN;
pos {x=7: y=1: z=1: };
un_geom {x=3: y=3: n_not_xy=0: n=9: };
unit_groups=0;
gp_geom {x=2: y=1: n_not_xy=0: n=2: };
gp_spc {x=0: y=0: };
act_geom {x=3: y=3: n_not_xy=0: n=9: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$111$;
spec {type=FullPrjnSpec: spec=$192$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[6]$227$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_GP_Ext";
from_type=CUSTOM;
from=$114$;
spec {type=UniformRndPrjnSpec: spec=.projects[0].networks[0].specs[2]$228$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$212$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[2];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=3: y=3: n_not_xy=0: n=9: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[3].children[2]$229$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0: max=0: max_i=-1: };
acts_p {avg=0.01802806: max=0.1488344: max_i=6: };
acts_m {avg=0.2878762: max=0.9212248: max_i=6: };
phase_dif_ratio=15.96823;
acts_p2 {avg=0: max=0: max_i=-1: };
acts_m2 {avg=0: max=0: max_i=-1: };
kwta {k=2: pct=0.2222222: pct_c=0.7777778: adth_k=1: k_ithr=1.60686: k1_ithr=1.38061: ithr_r=0.151759: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.2222222: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=1: };
maxda=0;
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][1].children[0]$230$: };
stm_gain=0.5;
hard_clamped=0;
sravg_sum=0;
sravg_nrm=0;
maxda_sum=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
};
view_objs {
name=;
el_typ=NetViewObj;
el_def=0;
};
flags=;
auto_build=AUTO_BUILD;
train_mode=TRAIN;
wt_update=ON_LINE;
small_batch_n=10;
batch=0;
epoch=0;
group=0;
trial=0;
tick=0;
cycle=0;
time=0;
group_name=;
trial_name="20vs80";
output_name=;
sse_unit_avg=0;
sse_sqrt=0;
sse=0;
sum_sse=0;
avg_sse=0;
cnt_err_tol=0.75;
cnt_err=0;
cur_sum_sse=0;
avg_sse_n=0;
cur_cnt_err=0;
train_time {name="train_time": start={usr=74937: sys=49925: tot=445183688: }: end={usr=74916: sys=49919: tot=445183660: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
epoch_time {name="epoch_time": start={usr=75792: sys=50536: tot=445185173: }: end={usr=75792: sys=50536: tot=445185173: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
dmem_sync_level=DMEM_SYNC_NETWORK;
dmem_nprocs=1;
usr1_save_fmt=FULL_NET;
wt_save_fmt=TEXT;
lay_layout=THREE_D;
n_units=88;
n_cons=1427;
max_size {x=14: y=9: z=3: };
font_sizes {
net_name=0.05;
net_vals=0.05;
layer=0.04;
layer_vals=0.03;
prjn=0.01;
unit=0.02;
un_nm_len=3;
};
view_params {
xy_square=0;
unit_spacing=0.05;
prjn_disp=L_R_F;
prjn_name=0;
prjn_width=0.002;
prjn_trans=0.5;
lay_trans=0.5;
unit_trans=0.6;
};
learn_rule=LEABRA_CHL;
phase_order=MINUS_PLUS;
no_plus_test=1;
trial_init=DECAY_STATE;
sequence_init=DO_NOTHING;
phase=MINUS_PHASE;
nothing_phase=0;
phase_no=0;
phase_max=2;
ct_cycle=33;
cycle_max=100;
min_cycles=15;
min_cycles_phase2=35;
ct_time {
minus=50;
plus=20;
inhib=1;
total_cycles=71;
inhib_start=70;
};
ct_sravg {
start=30;
end=1;
interval=5;
min_da_thr=0;
};
ct_sin_i {
start=30;
duration=20;
n_pi=2;
burst_i=0.02;
trough_i=0.02;
};
ct_fin_i {
start=20;
end=25;
inhib_i=0;
};
minus_cycles=0;
avg_cycles=0;
avg_cycles_sum=0;
avg_cycles_n=0;
minus_output_name=;
net_misc {
cyc_syn_dep=0;
syn_dep_int=20;
};
netin_mod=1;
send_delta=0;
send_pct=0;
send_pct_n=0;
send_pct_tot=0;
avg_send_pct=0;
avg_send_pct_sum=0;
avg_send_pct_n=0;
maxda_stopcrit=0.005;
maxda=0;
trg_max_act_stopcrit=1;
trg_max_act=0;
ext_rew=0;
avg_ext_rew=0;
avg_ext_rew_sum=0;
avg_ext_rew_n=0;
};
};
};
