// ta_Dump File v2.0
LeabraProject .projects[0] { 
Doc_Group @.docs = [1] {
taDoc @[0] { };
};

Wizard_Group @.wizards = [1] {
LeabraWizard @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};

LayerWizElList @.layer_cfg = [3] {
LayerWizEl @[0] { };
LayerWizEl @[1] { };
LayerWizEl @[2] { };
};
};
};

SelectEdit_Group @.edits = [1] {
SelectEdit @[0] { 
EditMbrItem_Group @.mbrs = [5] {
EditMbrItem @[0] { };
EditMbrItem @[1] { };
EditMbrItem @[2] { };
EditMbrItem @[3] { };
EditMbrItem @[4] { };
};
};
};

DataTable_Group @.data = [0] {
DataTable_Group @.gp[0] = [4] { 
DataTable @[0] { 
DataTableCols @.data = [5] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
};
};
DataTable @[1] { 
DataTableCols @.data = [4] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
};
};
DataTable @[2] { 
DataTableCols @.data = [6] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
float_Data @[5] { };
};
};
DataTable @[3] { 
DataTableCols @.data = [6] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
float_Data @[5] { };
};
};
};
DataTable_Group @.gp[1] = [3] { 
DataTable @[0] { 
DataTableCols @.data = [10] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
String_Data @[3] { };
String_Data @[4] { };
int_Data @[5] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[6] { };
float_Data @[7] { };
float_Data @[8] { };
float_Data @[9] { };
};
};
DataTable @[1] { 
DataTableCols @.data = [6] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
float_Data @[5] { };
};
};
DataTable @[2] { 
DataTableCols @.data = [16] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
String_Data @[3] { };
String_Data @[4] { };
int_Data @[5] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[6] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[7] { };
float_Data @[8] { };
float_Data @[9] { };
float_Data @[10] { };
float_Data @[11] { };
float_Data @[12] { };
float_Data @[13] { };
float_Data @[14] { };
float_Data @[15] { };
};
};
};
DataTable_Group @.gp[2] = [1] { 
DataTable @[0] { 
DataTableCols @.data = [11] {
int_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
float_Data @[5] { };
float_Data @[6] { };
float_Data @[7] { };
float_Data @[8] { };
float_Data @[9] { };
float_Data @[10] { };
};
};
};
};

taBase_Group @.data_proc = [4] {
taDataProc @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taDataAnal @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taDataGen @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taImageProc @[3] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};

Program_Group @.programs = [0] {
Program_Group @.gp[0] = [17] { 
Program @[0] { 
ProgVar_List @.args = [5] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [2] {
NetCounterInit @[0] { };
WhileLoop @[1] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [5] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
ProgArg @[4] { };
};
};
NetCounterIncr @[1] { };
};
};
};
};
Program @[1] { 
ProgObjList @.objs = [1] {
RndSeed @[0] { };
};

ProgType_List @.types = [1] {
DynEnumType @[0] { 
DynEnumItem_List @.enums = [2] {
DynEnumItem @[0] { };
DynEnumItem @[1] { };
};
};
};

ProgVar_List @.args = [5] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
};

ProgVar_List @.vars = [15] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
};

ProgEl_List @.init_code = [6] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
AssignExpr @[2] { };
NetCounterInit @[3] { };
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};

ProgEl_List @.false_code = [1] {
MethodCall @[0] { };
};
};
IfGuiPrompt @[5] { 
ProgEl_List @.yes_code = [2] {
MethodCall @[0] { };
PrintExpr @[1] { };
};
};
};

ProgEl_List @.prog_code = [13] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
NetCounterInit @[2] { };
MemberAssign @[3] { };
IfElse @[4] { 
ProgEl_List @.true_code = [2] {
MethodCall @[0] { };
PrintExpr @[1] { };
};
};
AssignExpr @[5] { };
ForLoop @[6] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
UserScript @[0] { };
};
};
};
};
MemberAssign @[7] { };
OtherProgramVar @[8] { };
OtherProgramVar @[9] { };
ProgramCall @[10] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
WhileLoop @[11] { 
ProgEl_List @.loop_code = [6] {
MemberAssign @[0] { };
ProgramCall @[1] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[2] { };
IfBreak @[3] { };
MemberAssign @[4] { };
ProgramCall @[5] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
MethodCall @[12] { };
};
};
Program @[2] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [5] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
};

ProgEl_List @.init_code = [2] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
};

ProgEl_List @.prog_code = [9] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[3] { };
NetDataLoop @[4] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
};
};
IfElse @[5] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
MethodCall @[6] { };
ProgramCall @[7] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[8] { };
};
};
Program @[3] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [9] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
};

ProgEl_List @.init_code = [2] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
};

ProgEl_List @.prog_code = [11] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
AssignExpr @[3] { };
MethodCall @[4] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[5] { };
NetDataLoop @[6] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
};
};
IfElse @[7] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
MethodCall @[8] { };
ProgramCall @[9] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[10] { };
};
};
Program @[4] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [6] {
NetCounterInit @[0] { };
MethodCall @[1] { };
WhileLoop @[2] { 
ProgEl_List @.loop_code = [3] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[1] { };
MethodCall @[2] { };
};
};
MethodCall @[3] { };
ProgramCall @[4] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetUpdateView @[5] { };
};
};
Program @[5] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [6] {
NetCounterInit @[0] { };
MethodCall @[1] { };
WhileLoop @[2] { 
ProgEl_List @.loop_code = [3] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[1] { };
MethodCall @[2] { };
};
};
MethodCall @[3] { };
ProgramCall @[4] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetUpdateView @[5] { };
};
};
Program @[6] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [12] {
NetCounterInit @[0] { };
MethodCall @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
ProgramCall @[3] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MemberAssign @[0] { };
};

ProgEl_List @.false_code = [1] {
MemberAssign @[0] { };
};
};
MethodCall @[5] { };
IfElse @[6] { 
ProgEl_List @.true_code = [1] {
AssignExpr @[0] { };
};

ProgEl_List @.false_code = [1] {
AssignExpr @[0] { };
};
};
WhileLoop @[7] { 
ProgEl_List @.loop_code = [4] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetCounterIncr @[1] { };
IfContinue @[2] { };
IfBreak @[3] { };
};
};
MethodCall @[8] { };
IfElse @[9] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
IfElse @[10] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
NetUpdateView @[11] { };
};
};
Program @[7] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [12] {
NetCounterInit @[0] { };
MethodCall @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
ProgramCall @[3] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MemberAssign @[0] { };
};

ProgEl_List @.false_code = [1] {
MemberAssign @[0] { };
};
};
MethodCall @[5] { };
IfElse @[6] { 
ProgEl_List @.true_code = [1] {
AssignExpr @[0] { };
};

ProgEl_List @.false_code = [1] {
AssignExpr @[0] { };
};
};
WhileLoop @[7] { 
ProgEl_List @.loop_code = [4] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetCounterIncr @[1] { };
IfContinue @[2] { };
IfBreak @[3] { };
};
};
MethodCall @[8] { };
IfElse @[9] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
IfElse @[10] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
NetUpdateView @[11] { };
};
};
Program @[8] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.prog_code = [3] {
MethodCall @[0] { };
NetUpdateView @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
};
};
Program @[9] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.prog_code = [3] {
MethodCall @[0] { };
NetUpdateView @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
};
};
Program @[10] { 
ProgObjList @.objs = [1] {
LayerWriter @[0] { 
LayerDataEl_List @.layer_data = [5] {
LayerWriterEl @[0] { };
LayerWriterEl @[1] { };
LayerWriterEl @[2] { };
LayerWriterEl @[3] { };
LayerWriterEl @[4] { };
};
};
};

ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.init_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [1] {
MethodCall @[0] { };
};
};
Program @[11] { 
ProgObjList @.objs = [1] {
LayerWriter @[0] { 
LayerDataEl_List @.layer_data = [5] {
LayerWriterEl @[0] { };
LayerWriterEl @[1] { };
LayerWriterEl @[2] { };
LayerWriterEl @[3] { };
LayerWriterEl @[4] { };
};
};
};

ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.init_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [1] {
MethodCall @[0] { };
};
};
Program @[12] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [10] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
NetMonItem @[6] { };
NetMonItem @[7] { };
NetMonItem @[8] { };
NetMonItem @[9] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [3] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [4] {
MethodCall @[0] { };
MethodCall @[1] { };
MethodCall @[2] { };
MethodCall @[3] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[13] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [16] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
NetMonItem @[6] { };
NetMonItem @[7] { };
NetMonItem @[8] { };
NetMonItem @[9] { };
NetMonItem @[10] { };
NetMonItem @[11] { };
NetMonItem @[12] { };
NetMonItem @[13] { };
NetMonItem @[14] { };
NetMonItem @[15] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [3] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [5] {
IfReturn @[0] { };
MethodCall @[1] { };
MethodCall @[2] { };
MethodCall @[3] { };
MethodCall @[4] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[14] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [6] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgEl_List @.init_code = [4] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[3] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [4] {
MethodCall @[0] { };
MethodCall @[1] { };
AssignExpr @[2] { };
MethodCall @[3] { };
};
};
Program @[15] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [6] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
};

ProgEl_List @.prog_code = [6] {
IfReturn @[0] { };
MiscCall @[1] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[2] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
AssignExpr @[3] { };
MethodCall @[4] { 
ProgArg_List @.meth_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
MethodCall @[5] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[16] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [15] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
};

ProgEl_List @.prog_code = [4] {
AssignExpr @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
IfElse @[3] { 
ProgEl_List @.true_code = [4] {
IfElse @[0] { 
ProgEl_List @.true_code = [2] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
MemberAssign @[0] { };
};
};
MemberAssign @[1] { };
};

ProgEl_List @.false_code = [2] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
MemberAssign @[0] { };
};
};
MemberAssign @[1] { };
};
};
AssignExpr @[1] { };
AssignExpr @[2] { };
IfElse @[3] { 
ProgEl_List @.true_code = [4] {
MemberAssign @[0] { };
MemberAssign @[1] { };
MemberAssign @[2] { };
MemberAssign @[3] { };
};

ProgEl_List @.false_code = [4] {
MemberAssign @[0] { };
MemberAssign @[1] { };
MemberAssign @[2] { };
MemberAssign @[3] { };
};
};
};

ProgEl_List @.false_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [2] {
MemberAssign @[0] { };
MemberAssign @[1] { };
};
};
};
};
};
};
};
};

DataViewer_List @.viewers = [1] {
MainWindowViewer @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
UserDataItem @[1] { };
UserDataItem @[2] { };
UserDataItem @[3] { };
UserDataItem @[4] { };
UserDataItem @[5] { };
};

ToolBar_List @.toolbars = [1] {
ToolBar @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};

FrameViewer_List @.frames = [3] {
tabBrowseViewer @[0] { };
PanelViewer @[1] { };
T3DataViewer @[2] { 
T3DataViewFrame_List @.frames = [4] {
T3DataViewFrame @[0] { 
T3DataView_List @.children = [1] {
NetView @[0] { 
ScaleRange_List @.scale_ranges = [23] {
ScaleRange @[0] { };
ScaleRange @[1] { };
ScaleRange @[2] { };
ScaleRange @[3] { };
ScaleRange @[4] { };
ScaleRange @[5] { };
ScaleRange @[6] { };
ScaleRange @[7] { };
ScaleRange @[8] { };
ScaleRange @[9] { };
ScaleRange @[10] { };
ScaleRange @[11] { };
ScaleRange @[12] { };
ScaleRange @[13] { };
ScaleRange @[14] { };
ScaleRange @[15] { };
ScaleRange @[16] { };
ScaleRange @[17] { };
ScaleRange @[18] { };
ScaleRange @[19] { };
ScaleRange @[20] { };
ScaleRange @[21] { };
ScaleRange @[22] { };
};
};
};
};
T3DataViewFrame @[1] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [16] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
GraphColView @[6] { };
GraphColView @[7] { };
GraphColView @[8] { };
GraphColView @[9] { };
GraphColView @[10] { };
GraphColView @[11] { };
GraphColView @[12] { };
GraphColView @[13] { };
GraphColView @[14] { };
GraphColView @[15] { };
};
};
};
};
T3DataViewFrame @[2] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [6] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
};
};
};
};
T3DataViewFrame @[3] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [11] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
GraphColView @[6] { };
GraphColView @[7] { };
GraphColView @[8] { };
GraphColView @[9] { };
GraphColView @[10] { };
};
};
};
};
};
};
};

DockViewer_List @.docks = [1] {
ToolBoxDockViewer @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
UserDataItem @[1] { };
UserDataItem @[2] { };
UserDataItem @[3] { };
UserDataItem @[4] { };
UserDataItem @[5] { };
};
};
};
};
};

Network_Group @.networks = [1] {
LeabraNetwork @[0] { 
BaseSpec_Group @.specs = [3] {
ConSpec @[0] { };
UniformRndPrjnSpec @[1] { };
UniformRndPrjnSpec @[2] { };
BaseSpec_Group @.gp[0] = [10] { 
FullPrjnSpec @[0] { };
OneToOnePrjnSpec @[1] { };
TesselPrjnSpec @[2] { 
BaseSpec_Group @.children = [1] {
TesselPrjnSpec @[0] { 
TessEl_List @.send_offs = [18] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
TessEl @[12] { };
TessEl @[13] { };
TessEl @[14] { };
TessEl @[15] { };
TessEl @[16] { };
TessEl @[17] { };
};
};
};

TessEl_List @.send_offs = [18] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
TessEl @[12] { };
TessEl @[13] { };
TessEl @[14] { };
TessEl @[15] { };
TessEl @[16] { };
TessEl @[17] { };
};
};
TesselPrjnSpec @[3] { 
TessEl_List @.send_offs = [9] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
};
};
TesselPrjnSpec @[4] { 
TessEl_List @.send_offs = [12] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
};
};
TesselPrjnSpec @[5] { 
TessEl_List @.send_offs = [2] {
TessEl @[0] { };
TessEl @[1] { };
};
};
TesselPrjnSpec @[6] { 
TessEl_List @.send_offs = [12] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
};
};
TesselPrjnSpec @[7] { 
TessEl_List @.send_offs = [9] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
};
};
TesselPrjnSpec @[8] { 
TessEl_List @.send_offs = [4] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
};
};
OneToOnePrjnSpec @[9] { };
};
BaseSpec_Group @.gp[1] = [7] { 
LeabraBiasSpec @[0] { 
BaseSpec_Group @.children = [1] {
LeabraBiasSpec @[0] { };
};
};
LeabraConSpec @[1] { };
LeabraConSpec @[2] { 
BaseSpec_Group @.children = [2] {
LeabraConSpec @[0] { };
LeabraConSpec @[1] { };
};
};
LeabraConSpec @[3] { 
BaseSpec_Group @.children = [7] {
LeabraConSpec @[0] { };
LeabraConSpec @[1] { };
LeabraConSpec @[2] { };
LeabraConSpec @[3] { };
LeabraConSpec @[4] { };
LeabraConSpec @[5] { };
LeabraConSpec @[6] { };
};
};
LeabraConSpec @[4] { };
LeabraConSpec @[5] { };
LeabraConSpec @[6] { };
};
BaseSpec_Group @.gp[2] = [2] { 
LeabraUnitSpec @[0] { 
BaseSpec_Group @.children = [5] {
LeabraUnitSpec @[0] { };
LeabraUnitSpec @[1] { };
LeabraUnitSpec @[2] { };
LeabraUnitSpec @[3] { 
BaseSpec_Group @.children = [3] {
LeabraUnitSpec @[0] { };
LeabraUnitSpec @[1] { 
Schedule @.noise_sched = [4] {
SchedItem @[0] { };
SchedItem @[1] { };
SchedItem @[2] { };
SchedItem @[3] { };
};
};
LeabraUnitSpec @[2] { };
};
};
LeabraUnitSpec @[4] { };
};
};
LeabraUnitSpec @[1] { };
};
BaseSpec_Group @.gp[3] = [2] { 
LeabraLayerSpec @[0] { 
BaseSpec_Group @.children = [7] {
LeabraLayerSpec @[0] { };
LeabraLayerSpec @[1] { };
LeabraLayerSpec @[2] { };
LeabraLayerSpec @[3] { };
LeabraLayerSpec @[4] { };
LeabraLayerSpec @[5] { };
LeabraLayerSpec @[6] { };
};
};
LeabraLayerSpec @[1] { 
BaseSpec_Group @.children = [2] {
LeabraLayerSpec @[0] { };
LeabraLayerSpec @[1] { };
};
};
};
};

Layer_Group @.layers = [9] {
LeabraLayer @[0] { 
Unit_Group @.units = [25] {
};
};
LeabraLayer @[1] { 
Projection_Group @.projections = [5] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
LeabraPrjn @[2] { };
LeabraPrjn @[3] { };
LeabraPrjn @[4] { };
};

Unit_Group @.units = [36] {
};
};
LeabraLayer @[2] { 
Unit_Group @.units = [4] {
};
};
LeabraLayer @[3] { 
Projection_Group @.projections = [3] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
LeabraPrjn @[2] { };
};

Unit_Group @.units = [4] {
};
};
LeabraLayer @[4] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[5] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[6] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [4] {
};
};
LeabraLayer @[7] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[8] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [9] {
};
};
};
};
};
};
LeabraProject .projects[0] {
name="Project_0";
desc=;
tags=;
templates {
name=;
el_typ=taBase;
el_def=0;
};
docs {
name=;
el_typ=taDoc;
el_def=0;
taDoc @[0] {
name="ProjectDocs";
auto_open=1;
text="<html>
<head></head>
<body>
= Probabilistic Classification Learning in the Basal Ganglia =


* GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in
the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  If your screen is small, you may also want to make this new window \"Always on Top\": e.g., in Linux, <code>Emergent-logo-at-top-left-></code> <code> Advanced-> Keep Above Others</code>).   Alternatively, you can always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.


This project replicates the effect described in Frank (2005), in which a basal ganglia network can learn via pure reinforcement learning to select between complex probabilistic stimulus-response mappings in the \"weather prediction\" task, while networks with simulated Parkinson's disease are impaired.

Each of the four possible 'cues' in the task are represented by a column of  units in the Input layer, and anywhere from one to three cues are presented at a time. 
The relationship between particular cues present and probability of a given response (sun or rain, represented by R1 and R2 in the model) is highly probabilistic and combinatorial. For those interested in the specific probabilistic weather prediction input-output mappings and the frequency of occurrence of each cue, see  Knowlton et al (1994) <i>Learning & Memory</i>
which is represented in the \"Train_WeatherPred\" input data table in the tree on the left.

The project is set up to run four epochs, consisting of one hundred trials each, for a total of 400 trials. Networks are tested before training, and after each epoch of training, by testing for optimal performance 
(using the TestWP_Optimal InputData). Performance on this test is monitored in the [[.T3Tab.EpochOutputData]] graph, counting the number of errors made out of a total of 12 possible (so chance performance of 50% is 6 errors). In this measure, errors are counted not as a function of feedback in each trial during training itself (which is probabilistic) but rather in terms of the best (most optimal) choice. 

Note that this test is also administered to the model at the very beginning, prior to any training, as a measure of baseline performance (should be chance on average), and that during this test there is no 'feedback' (DA bursts or dips which would otherwise drive learning).

 
For intact network performance, make sure the number of intact SNc units is set to 4 (out of 4 units), the DA burst value is set to 1 (corresponding to maximal phasic burst firing rate) and the DA dip value is set to 0 (minimum phasic dip DA firing rate). These values are set in the  [[.PanelTab.MasterControl]] control panel.

To monitor performance across multiple networks, first save a Data Log file to store the data. Open the <code>data->OutputData subgroup</code> tree in the '''Tree''' window (far left) and click on <code>EpochOutputData</code> to display the data table (which is where the raw data is stored that is then plotted in the graph on the right). Click on <code>Object->Save Data Log</code>). Make sure to name this logfile with some reference to the current dopamine settings, so that you can properly interpret the data (e.g., name this 'Intact_epc.dat').  To run a set of networks on the task, expand the <code> programs</code> tab int the \"Tree\" window on the fat left, and then under <code> LeabraAll_Std_subgrpup</code>, click on the <code.LeabraBatch</code> object. Hit Init and Run on the bottom of the resulting [[.PanelTab.LeabraBatch]] panel that will open. This  will run a set of 25 networks, and store the data in the logfile you just created.  

(To speed things up when running a batch of networks, turn off the display of the network by clicking on the appropriate tab that you want to view and check off the <code>Display!</code> box on the top left.)


The output in the cnt_err column of the [[.PanelTab.EpochOutputData]] log file is the number of errors (out of 12) made in the optimal test environment, plotted as a function of epoch number, for each run of the network in the batch. Because the data are noisy (probabilistic rewards combined with random input weights which could by chance lead to particularly good or bad performance), we need to average across multiple networks with different sets of initial weights. To analyze the data, in the [[.PanelTab.EpochOutputData]] tab, click on  <code>DataProc->Group Mean SEM</code>. In the dialog box that pops up, make sure the   <code>dest_data</code> is set to <code>NULL</code>; this will create a new output data log under the AnalysisData_subgroup in the left frame, called <code>EpochOutputData_Group</code>. Also set  the first <code>gp_col1</code> to \"epoch\" so that the script can analyze performance as a function of each epoch, averaged across all networks. Set all other fields to <code>NULL</code> and click <code>Ok</code>. Now open the new analysis  <code>EpochOutputData_Group</code> log. You should see the statistics (mean, standard error) for each variable that was monitored in the EpochOutputData log. The relevant ones are cnt_err_mean and cnt_err_sem.  You should see that intact networks learn to discriminate between the complex probabilistic contingencies in the weather prediction task as training progresses (error decreases within 2-4 epochs, corresponding to 200-400 trials of training). They usually don't achieve perfectly optimal performance in the task, still making on average 20-25% errors, but this is also the case for healthy humans performing the task! (Also remember the network is learning using pure reinforcement learning and not error-driven learning).

To simulate PD, set the number of intact DA units to 1 in the  [[.PanelTab.MasterControl]] control panel. This sets the number of SNc units that are connected to the Striatum to 1 (out of 4). Note that the units themselves are not actually lesioned, because leabra applies a normalization factor when computing net input to layers that depends on the number of units in the sending layer --  so that it would treat a single unit layer as effectively four times greater input to other layers compared with a four unit layer. This makes sense for many general neural net applications (so that the total number of units in a region doesn't parametrically affect downstream processing), but is not useful when we want to simulate partial lesion effects!  To circumvent this problem we simply eliminate the synaptic weights from 3 out of the 4 DA units to Striatum (test this by pressing r.wt and clicking on striatal units in a PD network -- you should see connectivity to only one out of four SNc units). Don't be misled by the activation of all DA units after making this manipulation -- only the connected ones actually influence processing in the BG. This reduction in number of intact DA units  leads to effectively reduced tonic and phasic DA levels in the Striatum. 

Set a new log file name in the [[.PanelTab.EpochOutputData]] object, and give it a new name (e.g, with a PD descriptor). Hit Init and Run on the [[.PanelTab.LeabraBatch]] panel. When it's done, analyze the group mean and standard error as above. You should see that Parkinson's networks are impaired at learning compared with intact networks, due to a reduced dynamic range of DA signals for resolving Go/NoGo differences in stimulus-response-reward probabilities. 
 

Note that the Parkinson's deficit can also be captured with other ways of reducing the fidelity of DA signals. For example, if you set the number of intact DA units to 2 instead of 1 in the [[.PanelTab.MasterControl]] you should see that performance with 50% DA damage is relatively intact. consistent with the existence of redundancy in the DA system, whereby PD symptoms do not arise until a substantial proportion (~75%) of DA cells are damaged. But in this condition, the system is more dependent on having maximal DA bursting during rewards. To see this, reduce the \"DA burst real val\" to 0.04 instead of 1. (This value is the net input applied externally to the DA units and does NOT reflect the activation of the unit itself, which is a nonlinear function of this input. A net input of .04 corresponds to a phasic firing rate of roughly 0.8, which is still a burst relative to the tonic level (.03 net input, 0.5 firing rate) but represents a reduction in phasic bursting compared to the maximal firing rate value of 1.0). When this reduction in phasic DA is combined with DA unit damage, you should see more reliable probabilistic learning deficits relative to intact networks. Finally, set the number of intact DA units back to 4, and run another batch while maintaining the reduced phasic DA levels. You should see that with fully intact DA units, networks are still able to learn this complex probabilistic learning task with reduced phasic DA signals -- again showing robustness of the system to fluctuations in DA, which only become critical when combined with DA unit damage.
 

Finally, it was shown in Frank (2005) that the indirect \"NoGo\" pathway is critical for robust learning, in that networks without this pathway, even controlling for other parameters in the resulting network, were reliably impaired compared to the full model. These results demonstrate that the combined Go/NoGo learning system is required for learning from the full dynamic range of DA signals and for enhancing the contrast between subtly different probabilistic reinforcement values in this complex task. 


= PD Tremor, and Oscillations =
With very low DA levels, you may also see  some oscillations in STN and GP layers on some trials (these correspond to Parkinson's tremor; see Frank, 2006 for detailed discussion). You can look at these more carefully in the [[.T3Tab.CycleOutputData]]  graph logs where activity levels of the various layers are recorded. The easiest way to see this is to set the tonic DA value to 0 instead of the default .03. This will eliminate all DA unit activity during response selection (note this would not work for simulating PD in general because it still allows for maximal DA burst firing during rewards). Then increase the number of cycles that the network processes in each test trial so that you have more room to see oscillations -- change the \"test cycles expr\" value from 100 to 200. Now  Run a few trials using the <code>LeabraTestEpoch</code> process, and watch the activity levels of the STN and GP in the [[.T3Tab.CycleOutputData]] graph log. You might have to run more than one trial to see the oscillations, which should not (or only rarely) be seen at all in the intact state.  (Note that the same oscillations will be seen in the standard way of simulating PD above, by reducing the num_intact_snc_units to 1, but in that case you have to first Init and step through a trial in the Batch or Train process, which is where the removal of DA connections is executed, before running the Test trials to observe unit activity across cycles in the CycleOutputData graph -- which is configured to plot only test activity).
 

</body>
</html>
";
};
};
wizards {
name=;
el_typ=LeabraWizard;
el_def=0;
LeabraWizard @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="LeabraWizard_2";
auto_open=0;
n_layers=3;
layer_cfg {
name=;
el_typ=LayerWizEl;
el_def=0;
LayerWizEl @[0] {
name="LayerWizEl";
n_units=25;
io_type=76;
};
LayerWizEl @[1] {
name="LayerWizEl";
n_units=25;
io_type=INPUT;
};
LayerWizEl @[2] {
name="LayerWizEl";
n_units=25;
io_type=7274496;
};
};
connectivity=BIDIRECTIONAL;
default_net_type=LeabraNetwork;
};
};
edits {
name=;
el_typ=SelectEdit;
el_def=0;
SelectEdit @[0] {
name="MasterControl";
auto_edit=1;
desc=;
mbrs {
name=;
el_typ=EditMbrItem;
el_def=0;
EditMbrItem @[0] {
label="tonic DA real_val";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[11]$0$;
mbr=ProgVar::real_val;
};
EditMbrItem @[1] {
label="DA burst real_val";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[14]$1$;
mbr=ProgVar::real_val;
};
EditMbrItem @[2] {
label="DA dip real_val";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[13]$2$;
mbr=ProgVar::real_val;
};
EditMbrItem @[3] {
label="num intact snc units ";
desc=" integer value (also for enum types)";
base=.projects[0].programs.gp[0][1].vars[11]$3$;
mbr=ProgVar::int_val;
};
EditMbrItem @[4] {
label="test cycles  ";
desc=" the expression to compute and assign to the member<br>  :  enter the expression here -- you can just type in names of program variables or literal values. enclose strings in double quotes. variable names will be checked and automatically updated<br>  var lookup!:  lookup a program variable and add it to the current expression (this field then returns to empty/NULL)<br>  enum lookup!:  lookup a dynamic enum variable and add it to the current expression (this field then returns to empty/NULL)";
base=.projects[0].programs.gp[0][7].prog_code[4].false_code[0]$4$;
mbr=MemberAssign::expr;
};
};
mths {
name=;
el_typ=EditMthItem;
el_def=0;
group_type=GT_BUTTONS;
};
};
};
data {
name=;
el_typ=DataTable;
el_def=0;
DataTable_Group @.gp[0] {
name="InputData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="Train_Freq";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[40] "80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"40vs60";"40vs60";"40vs60";"80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"40vs60";"40vs60";"40vs60";"40vs60";"40vs60";"40vs60";"40vs60";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";"60vs40";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 40] 1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0.0099999998;0;0;0;1;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0.0099999998;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 40] 1;0;1;0;1;0;1;0;0;1;0;1;0;1;1;0;1;0;1;0;1;0;1;0;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 40] 100;100;100;100;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0;0;0;0;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;100;100;100;100;100;100;100;100;0;0;0;0;0;0;0;0;100;100;100;100;100;100;100;100;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 40] 1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[1] {
name="TestFreq";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[4] "80";"60";"80";"60";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 4] 1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 4] 1;0;0;1;0;1;1;0;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 4] 0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[2] {
name="Train_WeatherPred";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[100] "Event_1";"Event_2";"Event_3";"Event_4";"Event_5";"Event_6";"Event_7";"Event_8";"Event_9";"Event_10";"Event_11";"Event_12";"Event_13";"Event_14";"Event_15";"Event_16";"Event_17";"Event_18";"Event_19";"Event_20";"Event_21";"Event_22";"Event_23";"Event_24";"Event_25";"Event_26";"Event_27";"Event_28";"Event_29";"Event_30";"Event_31";"Event_32";"Event_33";"Event_34";"Event_35";"Event_36";"Event_37";"Event_38";"Event_39";"Event_40";"Event_41";"Event_42";"Event_43";"Event_44";"Event_45";"Event_46";"Event_47";"Event_48";"Event_49";"Event_50";"Event_51";"Event_52";"Event_53";"Event_54";"Event_55";"Event_56";"Event_57";"Event_58";"Event_59";"Event_60";"Event_61";"Event_62";"Event_63";"Event_64";"Event_65";"Event_66";"Event_67";"Event_68";"Event_69";"Event_70";"Event_71";"Event_72";"Event_73";"Event_74";"Event_75";"Event_76";"Event_77";"Event_78";"Event_79";"Event_80";"Event_81";"Event_82";"Event_83";"Event_84";"Event_85";"Event_86";"Event_87";"Event_88";"Event_89";"Event_90";"Event_91";"Event_92";"Event_93";"Event_94";"Event_95";"Event_96";"Event_97";"Event_98";"Event_99";"Event_1";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 100] 0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 100] 1;0;0;1;1;0;1;0;1;0;0;1;1;0;0;1;0;1;1;0;1;0;0;1;1;0;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;1;0;1;0;0;1;1;0;1;0;1;0;1;0;0;1;1;0;1;0;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;0;1;0;1;1;0;0;1;0;1;1;0;1;0;1;0;1;0;0;1;1;0;1;0;0;1;1;0;0;1;1;0;0;1;1;0;0;1;0;1;0;1;0;1;0;1;0;1;1;0;0;1;0;1;0;1;1;0;0;1;0;1;1;0;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;0;1;0;1;0;1;0;1;1;0;0;1;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 100] 0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;0;0;0;0;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 100] 0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;1;0;0;1;1;0;0;1;0;1;1;0;0;1;1;0;0;1;0;1;0;1;0;1;1;0;0;1;1;0;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;1;0;1;0;0;1;};
};
float_Data @[5] {
name="GP_Int";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 100] 0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[3] {
name="TestWP_Optimal";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[12] "0001_14_143";"0010_08_375";"0011_09_111";"0100_08_625";"0101_06_167";"0111_04_250";"1000_14_857";"1010_06_833";"1011_03_333";"1100_09_889";"1101_03_667";"1110_04_750";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 12] 0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;0;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;0;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;0;1;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;1;1;1;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 12] 1;0;1;0;1;0;0;1;1;0;1;0;0;1;0;1;1;0;0;1;0;1;0;1;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 12] 0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;2000;2000;2000;2000;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 12] 0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;0;1;0;1;};
};
float_Data @[5] {
name="GP_Int";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 12] 0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
DataTable_Group @.gp[1] {
name="OutputData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="TrialOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="trial";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
String_Data @[3] {
name="trial_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
String_Data @[4] {
name="group_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[5] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="phase_no";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[6] {
name="minus_cycles";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[7] {
name="sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[8] {
name="ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[9] {
name="Output_sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[1] {
name="EpochOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[2] {
name="avg_sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[3] {
name="cnt_err";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[4] {
name="avg_ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[5] {
name="Output_sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[2] {
name="CycleOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="trial";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
String_Data @[3] {
name="trial_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
String_Data @[4] {
name="group_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[5] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="phase_no";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[6] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="cycle";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[7] {
name="sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[8] {
name="ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[9] {
name="STN_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[10] {
name="Motor__acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[11] {
name="Thalam_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[12] {
name="GP_Int_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[13] {
name="GP_Ext_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[14] {
name="Output_act";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
};
float_Data @[15] {
name="Output_units_0_act";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
};
};
data_flags=AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
DataTable_Group @.gp[2] {
name="AnalysisData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="EpochOutputData_Group";
desc=;
data {
name="data";
el_typ=DataColTp;
el_def=0;
int_Data @[0] {
name="epoch_group";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0;1;2;3;4;};
};
float_Data @[1] {
name="batch_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 12;12;12;12;12;};
};
float_Data @[2] {
name="batch_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 1.4422204;1.4422204;1.4422204;1.4422204;1.4422204;};
};
float_Data @[3] {
name="avg_sse_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0.85226071;0.68605095;0.42930219;0.36634642;0.32019389;};
};
float_Data @[4] {
name="avg_sse_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0.050845664;0.049731813;0.038850818;0.03262366;0.03938181;};
};
float_Data @[5] {
name="cnt_err_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 5.48;5.04;3.6400001;3.3199999;3.2;};
};
float_Data @[6] {
name="cnt_err_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0.31556934;0.42513055;0.38316578;0.36097646;0.4039802;};
};
float_Data @[7] {
name="avg_ext_rew_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0;0;0;0;0;};
};
float_Data @[8] {
name="avg_ext_rew_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0;0;0;0;0;};
};
float_Data @[9] {
name="Output_sse_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0.613289;0.90176368;0.5320006;0.37883657;0.21367583;};
};
float_Data @[10] {
name="Output_sse_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[5] 0.17472716;0.18528508;0.16630226;0.1144864;0.087352477;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
};
data_proc {
name=;
el_typ=taDataProc;
el_def=0;
taDataProc @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_base";
};
taDataAnal @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_anal";
};
taDataGen @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_gen";
};
taImageProc @[3] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="image_proc";
};
};
programs {
name=;
el_typ=Program;
el_def=0;
step_prog=NULL;
tags=;
desc=;
Program_Group @.gp[0] {
name="LeabraAll_Std";
el_typ=Program;
el_def=0;
step_prog=.projects[0].programs.gp[0][4]$5$;
tags="Leabra, Std, All";
desc="The full set of programs for training a standard Leabra network";
Program @[0] {
name="LeabraBatch";
tags="Leabra, Std";
desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=.projects[0].networks[0]$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to operate on -- updates batch counter on network and passes it to train program";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][2]$7$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
ProgVar @[2] {
name="max_batch";
var_type=T_Int;
int_val=25;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="maximum number of batch runs to perform";
};
ProgVar @[3] {
name="TrainWP";
var_type=T_Object;
object_type=DataTable;
object_val=$7$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
ProgVar @[4] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][3]$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="batch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="batch counter";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initializes local batch counter and batch field on network";
flags=;
network_var=.projects[0].programs.gp[0][0].args[0]$9$;
local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$10$;
counter=Network::batch;
};
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
NetCounterInit @[0] {
desc="initializes local batch counter and batch field on network";
flags=;
network_var=$9$;
local_ctr_var=$10$;
counter=Network::batch;
};
WhileLoop @[1] {
desc="the main loop over training runs";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc="run the training program -- sets the network and input_data args";
flags=;
target=.projects[0].programs.gp[0][1]$11$;
targ_ld_init="*LeabraTrain*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=DataTable;
type="DataTable*";
name="TrainWP";
required=1;
def_val=;
expr {
expr="TrainWP";
var_expr="$#0#$";
vars {
};
var_names{ TrainWP;};
bad_vars{ };
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="no_prompts";
required=1;
def_val=;
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[4] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment the local batch counter and copy to network";
flags=;
network_var=$9$;
local_ctr_var=$10$;
counter=Network::batch;
};
};
test {
expr="batch < max_batch";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ batch;max_batch;};
bad_vars{ };
};
};
};
};
Program @[1] {
name="LeabraTrain";
tags="Leabra, Std";
desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
flags=SHOW_STEP;
objs {
name=;
el_typ=RndSeed;
el_def=0;
RndSeed @[0] {
name="rnd_seed";
seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;};
mti=156;
};
};
types {
name=;
el_typ=DynEnumType;
el_def=0;
DynEnumType @[0] {
name="RndInitType";
desc=;
enums {
name=;
el_typ=DynEnumItem;
el_def=0;
DynEnumItem @[0] {
name="OLD_SEED";
value=0;
desc="use stored random seed value (recreates same sequence every time)";
};
DynEnumItem @[1] {
name="NEW_SEED";
value=1;
desc="generate new random seed (new sequence of random numbers)";
};
};
bits=0;
};
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to train";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$7$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
ProgVar @[2] {
name="TrainWP";
var_type=T_Object;
object_type=DataTable;
object_val=$7$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
ProgVar @[3] {
name="no_prompts";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
};
ProgVar @[4] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="max_epoch";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="maximum number of epochs to run";
};
ProgVar @[1] {
name="train_mode";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=Network::TrainMode;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
};
ProgVar @[2] {
name="test_mode";
var_type=T_HardEnum;
int_val=0;
hard_enum_type=Network::TrainMode;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
};
ProgVar @[3] {
name="rnd_init";
var_type=T_DynEnum;
dyn_enum_val {
enum_type=.projects[0].programs.gp[0][1].types[0]$12$;
value=0;
};
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="how to initialize the random numbers when the Init button is pressed";
};
ProgVar @[4] {
name="epoch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current epoch -- local copy, which is used to update network's epoch counter";
};
ProgVar @[5] {
name="err_stopcrit";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
};
ProgVar @[6] {
name="rnd_seed";
var_type=T_Object;
object_type=RndSeed;
object_val=.projects[0].programs.gp[0][1].objs[0]$13$;
objs_ptr=1;
flags=NULL_CHECK;
desc="random seed that is used at start of training -- if OldSeed is called";
};
ProgVar @[7] {
name="train_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=.projects[0].networks[0].train_time$14$;
objs_ptr=0;
flags=NULL_CHECK;
desc="records time used to train network (object lives on network -- this is a pointer to it)";
};
ProgVar @[8] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][1]$15$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[9] {
name="j";
var_type=T_Int;
int_val=18;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[10] {
name="i";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[11] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[12] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[13] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=.projects[0].networks[0].layers[2]$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[14] {
name="Striatum";
var_type=T_Object;
object_type=LeabraLayer;
object_val=.projects[0].networks[0].layers[1]$17$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][1].args[3]$18$;
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
MethodCall @[1] {
desc="check network to make sure it is ready to be run";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][1].args[0]$19$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
AssignExpr @[2] {
desc="get our pointer to the network training time object";
flags=;
result_var=.projects[0].programs.gp[0][1].vars[7]$20$;
expr {
expr="network.train_time";
var_expr="$#0#$.train_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
NetCounterInit @[3] {
desc="initialize epoch counter ";
flags=;
network_var=$19$;
local_ctr_var=.projects[0].programs.gp[0][1].vars[4]$21$;
counter=Network::epoch;
};
IfElse @[4] {
desc="initialize random seed (either old or new)";
flags=;
cond {
expr="rnd_init == OLD_SEED";
var_expr="$#0#$ == OLD_SEED";
vars {
};
var_names{ rnd_init;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="restore previous random seed (all runs produce same results)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][1].vars[6]$22$;
method=RndSeed::OldSeed;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="new random numbers each time";
flags=;
result_var=NULL;
obj=$22$;
method=RndSeed::NewSeed;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
IfGuiPrompt @[5] {
desc="don't initialize weights without checking";
flags=;
prompt="Do you want to Initialize Network Weights";
yes_label="Yes";
no_label="No";
yes_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="initialize network weights: could also load pre-set weights or something else here";
flags=;
result_var=NULL;
obj=$19$;
method=Network::Init_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
PrintExpr @[1] {
desc=;
flags=;
expr {
expr="network.name << \" Weights Initialized\"";
var_expr="$#0#$.name << \" Weights Initialized\"";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc="get our pointer to the network training time object";
flags=;
result_var=$20$;
expr {
expr="network.train_time";
var_expr="$#0#$.train_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[1] {
desc="start timer to keep track of how long it takes to run entire training run";
flags=;
result_var=NULL;
obj=$20$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
NetCounterInit @[2] {
desc="initialize epoch counter (both our local copy and network's epoch counter)";
flags=;
network_var=$19$;
local_ctr_var=$21$;
counter=Network::epoch;
};
MemberAssign @[3] {
desc="set network's training mode to our local value";
flags=;
obj=$19$;
path="train_mode";
expr {
expr="train_mode";
var_expr="$#0#$";
vars {
};
var_names{ train_mode;};
bad_vars{ };
};
update_after=0;
};
IfElse @[4] {
desc=;
flags=;
cond {
expr="no_prompts";
var_expr="$#0#$";
vars {
};
var_names{ no_prompts;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="initialize network weights: could also load pre-set weights or something else here";
flags=;
result_var=NULL;
obj=$19$;
method=Network::Init_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
PrintExpr @[1] {
desc=;
flags=;
expr {
expr="network.name << \" Weights Initialized\"";
var_expr="$#0#$.name << \" Weights Initialized\"";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
AssignExpr @[5] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][1].vars[12]$23$;
expr {
expr="SNc.units.size";
var_expr="$#0#$.units.size";
vars {
};
var_names{ SNc;};
bad_vars{ };
};
};
ForLoop @[6] {
desc="only connect intact snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over striatal units (Go units for D1 projection and NoGo units for D2 projection)";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
UserScript @[0] {
desc="zero out weights for non-intact snc units";
flags=;
script {
expr="SNc.units[i].send[0].Cn(j).wt=0; SNc.units[i].send[1].Cn(j).wt=0;  ";
var_expr="$#0#$.units[$#1#$].send[0].Cn($#2#$).wt=0; $#0#$.units[$#1#$].send[1].Cn($#2#$).wt=0;  ";
vars {
};
var_names{ SNc;i;j;};
bad_vars{ };
};
};
};
init {
expr="j = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ j;};
bad_vars{ };
};
test {
expr="j <  (Striatum.units.size)/2";
var_expr="$#0#$ <  ($#1#$.units.size)/2";
vars {
};
var_names{ j;Striatum;};
bad_vars{ };
};
iter {
expr="j++";
var_expr="$#0#$++";
vars {
};
var_names{ j;};
bad_vars{ };
};
};
};
init {
expr="i = num_intact_snc_units";
var_expr="$#0#$ = $#1#$";
vars {
};
var_names{ i;num_intact_snc_units;};
bad_vars{ };
};
test {
expr="i <  snc_size";
var_expr="$#0#$ <  $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
MemberAssign @[7] {
desc="set network's training mode to our local value";
flags=;
obj=$19$;
path="train_mode";
expr {
expr="test_mode";
var_expr="$#0#$";
vars {
};
var_names{ test_mode;};
bad_vars{ };
};
update_after=0;
};
OtherProgramVar @[8] {
desc=;
flags=;
other_prog=.projects[0].programs.gp[0][16]$24$;
set_other=1;
var_1=$3$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
OtherProgramVar @[9] {
desc=;
flags=;
other_prog=.projects[0].programs.gp[0][3]$25$;
set_other=1;
var_1=$3$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
ProgramCall @[10] {
desc="run the epoch program (one epoch), passes our network and input_data";
flags=;
target=$25$;
targ_ld_init="*LeabraTestEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
WhileLoop @[11] {
desc="main loop over epochs of training";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
MemberAssign @[0] {
desc="set network's training mode to our local value";
flags=;
obj=$19$;
path="train_mode";
expr {
expr="train_mode";
var_expr="$#0#$";
vars {
};
var_names{ train_mode;};
bad_vars{ };
};
update_after=0;
};
ProgramCall @[1] {
desc="run the epoch program (one epoch), passes our network and input_data";
flags=;
target=.projects[0].programs.gp[0][2]$26$;
targ_ld_init="*LeabraEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[2] {
desc="increment the epoch counter (locally and on network)";
flags=;
network_var=$19$;
local_ctr_var=$21$;
counter=Network::epoch;
};
IfBreak @[3] {
desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
flags=;
cond {
expr="network.cnt_err <= err_stopcrit";
var_expr="$#0#$.cnt_err <= $#1#$";
vars {
};
var_names{ network;err_stopcrit;};
bad_vars{ };
};
};
MemberAssign @[4] {
desc="set network's training mode to our local value";
flags=;
obj=$19$;
path="train_mode";
expr {
expr="test_mode";
var_expr="$#0#$";
vars {
};
var_names{ test_mode;};
bad_vars{ };
};
update_after=0;
};
ProgramCall @[5] {
desc=;
flags=;
target=$25$;
targ_ld_init="*LeabraTestEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
};
test {
expr="epoch < max_epoch";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ epoch;max_epoch;};
bad_vars{ };
};
};
MethodCall @[12] {
desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
flags=;
result_var=NULL;
obj=$20$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[2] {
name="LeabraEpoch";
tags="Leabra, Std";
desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to operate on";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$7$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="table of patterns to present to the network, one row at a time";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="data_loop_order";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=DataLoop::Order;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
};
ProgVar @[1] {
name="trial";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current trial (event) within the epoch -- increments automatically";
};
ProgVar @[2] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[1][0]$27$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
};
ProgVar @[3] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=.projects[0].networks[0].epoch_time$28$;
objs_ptr=0;
flags=NULL_CHECK;
desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
};
ProgVar @[4] {
name="data_loop_index";
var_type=T_Int;
int_val=100;
objs_ptr=0;
flags=NULL_CHECK;
desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=.projects[0].programs.gp[0][2].args[0]$29$;
local_ctr_var=.projects[0].programs.gp[0][2].vars[1]$30$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=.projects[0].programs.gp[0][2].vars[3]$31$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=$29$;
local_ctr_var=$30$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=$31$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[2] {
desc="start the epoch timer to record computation time per epoch";
flags=;
result_var=NULL;
obj=$31$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[3] {
desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][2].vars[2]$32$;
method=DataTable::ResetData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetDataLoop @[4] {
desc="iterates over the events/rows of input_data, according to data_loop_order variable";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the trial program, passing network and input_data";
flags=;
target=$5$;
targ_ld_init="*LeabraTrial*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
IfElse @[1] {
desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
flags=;
cond {
expr="network.Compute_Weights_Test(trial+1)";
var_expr="$#0#$.Compute_Weights_Test($#1#$+1)";
vars {
};
var_names{ network;trial;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="update the weight values based on changes computed by trial program";
flags=;
result_var=NULL;
obj=$29$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
};
data_var=.projects[0].programs.gp[0][2].args[1]$33$;
index_var=.projects[0].programs.gp[0][2].vars[4]$34$;
order_var=.projects[0].programs.gp[0][2].vars[0]$35$;
order=PERMUTED;
item_idx_list{ 43;21;90;13;50;17;77;74;45;1;42;94;24;10;15;64;84;91;23;87;83;99;72;86;28;40;52;9;48;97;57;54;3;37;6;51;27;75;12;67;56;5;7;65;31;44;98;11;33;61;63;39;0;76;4;22;59;26;92;49;41;95;19;60;93;38;66;35;58;89;73;46;53;30;79;82;69;18;36;81;62;80;25;71;85;29;34;68;96;14;8;20;88;78;16;55;32;47;2;70;};
dmem_nprocs=1;
dmem_this_proc=0;
};
IfElse @[5] {
desc="if full batch mode, update only at end of epoch";
flags=;
cond {
expr="network.wt_update == Network::BATCH";
var_expr="$#0#$.wt_update == Network::BATCH";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="final update of weights based on accumulated changes";
flags=;
result_var=NULL;
obj=$29$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
MethodCall @[6] {
desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
flags=;
result_var=NULL;
obj=$29$;
method=LeabraNetwork::Compute_EpochStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[7] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=OFF;
target=.projects[0].programs.gp[0][14]$36$;
targ_ld_init="*LeabraEpochMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[8] {
desc="done with the computation in the epoch -- record time it took";
flags=;
result_var=NULL;
obj=$31$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[3] {
name="LeabraTestEpoch";
tags=;
desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to operate on";
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="data_loop_order";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=DataLoop::Order;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
};
ProgVar @[1] {
name="trial";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current trial (event) within the epoch -- increments automatically";
};
ProgVar @[2] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$27$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
};
ProgVar @[3] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=$28$;
objs_ptr=0;
flags=NULL_CHECK;
desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
};
ProgVar @[4] {
name="data_loop_index";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=NULL_CHECK;
desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
};
ProgVar @[5] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[6] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[7] {
name="k";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[8] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=.projects[0].programs.gp[0][3].args[0]$37$;
local_ctr_var=.projects[0].programs.gp[0][3].vars[1]$38$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=.projects[0].programs.gp[0][3].vars[3]$39$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=$37$;
local_ctr_var=$38$;
counter=Network::trial;
};
AssignExpr @[1] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[6]$40$;
expr {
expr="SNc.units.size";
var_expr="$#0#$.units.size";
vars {
};
var_names{ SNc;};
bad_vars{ };
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[7]$41$;
expr {
expr="(float)num_intact_snc_units/ snc_size";
var_expr="(float)$#0#$/ $#1#$";
vars {
};
var_names{ num_intact_snc_units;snc_size;};
bad_vars{ };
};
};
AssignExpr @[3] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=$39$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[4] {
desc="start the epoch timer to record computation time per epoch";
flags=;
result_var=NULL;
obj=$39$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[5] {
desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][3].vars[2]$42$;
method=DataTable::ResetData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetDataLoop @[6] {
desc="iterates over the events/rows of input_data, according to data_loop_order variable";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the trial program, passing network and input_data";
flags=;
target=.projects[0].programs.gp[0][5]$43$;
targ_ld_init="*LeabraTestTrial*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
IfElse @[1] {
desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
flags=;
cond {
expr="network.Compute_Weights_Test(trial+1)";
var_expr="$#0#$.Compute_Weights_Test($#1#$+1)";
vars {
};
var_names{ network;trial;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="update the weight values based on changes computed by trial program";
flags=;
result_var=NULL;
obj=$37$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
};
data_var=.projects[0].programs.gp[0][3].args[1]$44$;
index_var=.projects[0].programs.gp[0][3].vars[4]$45$;
order_var=.projects[0].programs.gp[0][3].vars[0]$46$;
order=PERMUTED;
item_idx_list{ 9;4;2;7;5;6;11;8;1;0;3;10;};
dmem_nprocs=1;
dmem_this_proc=0;
};
IfElse @[7] {
desc="if full batch mode, update only at end of epoch";
flags=;
cond {
expr="network.wt_update == Network::BATCH";
var_expr="$#0#$.wt_update == Network::BATCH";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="final update of weights based on accumulated changes";
flags=;
result_var=NULL;
obj=$37$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
MethodCall @[8] {
desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
flags=;
result_var=NULL;
obj=$37$;
method=LeabraNetwork::Compute_EpochStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[9] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=;
target=$36$;
targ_ld_init="*LeabraEpochMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[10] {
desc="done with the computation in the epoch -- record time it took";
flags=;
result_var=NULL;
obj=$39$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[4] {
name="LeabraTrial";
tags="Leabra, Std";
desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to operate on -- typically set by higher-level calling programs";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$7$;
objs_ptr=0;
flags=NULL_CHECK;
desc="datatable containing training input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="phase_no";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
};
ProgVar @[1] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether to update any network view displays after trial is completed";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=.projects[0].programs.gp[0][4].args[0]$47$;
local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$48$;
counter=LeabraNetwork::phase_no;
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=$47$;
local_ctr_var=$48$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[1] {
desc="initializes various counters at start of trial";
flags=;
result_var=NULL;
obj=$47$;
method=LeabraNetwork::Trial_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
WhileLoop @[2] {
desc="loop over phases of settling in the network";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
flags=;
target=.projects[0].programs.gp[0][6]$49$;
targ_ld_init="*LeabraSettle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment the phase number (also on network)";
flags=;
network_var=$47$;
local_ctr_var=$48$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[2] {
desc="increments other phase state information to prepare for the next phase of settling";
flags=;
result_var=NULL;
obj=$47$;
method=LeabraNetwork::Trial_UpdatePhase;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
test {
expr="phase_no < network.phase_max";
var_expr="$#0#$ < $#1#$.phase_max";
vars {
};
var_names{ phase_no;network;};
bad_vars{ };
};
};
MethodCall @[3] {
desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
flags=;
result_var=NULL;
obj=$47$;
method=LeabraNetwork::Trial_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[4] {
desc="records data about the trial-level processing to a datatable for graphing/processing";
flags=OFF;
target=.projects[0].programs.gp[0][12]$50$;
targ_ld_init="*LeabraTrialMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetUpdateView @[5] {
desc="update the network view(s) (only if update_net_view is true)";
flags=;
network_var=$47$;
update_var=.projects[0].programs.gp[0][4].vars[1]$51$;
};
};
};
Program @[5] {
name="LeabraTestTrial";
tags=;
desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to operate on -- typically set by higher-level calling programs";
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc="datatable containing training input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="phase_no";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
};
ProgVar @[1] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether to update any network view displays after trial is completed";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=.projects[0].programs.gp[0][5].args[0]$52$;
local_ctr_var=.projects[0].programs.gp[0][5].vars[0]$53$;
counter=LeabraNetwork::phase_no;
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=$52$;
local_ctr_var=$53$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[1] {
desc="initializes various counters at start of trial";
flags=;
result_var=NULL;
obj=$52$;
method=LeabraNetwork::Trial_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
WhileLoop @[2] {
desc="loop over phases of settling in the network";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
flags=;
target=.projects[0].programs.gp[0][7]$54$;
targ_ld_init="*LeabraTestSettle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment the phase number (also on network)";
flags=;
network_var=$52$;
local_ctr_var=$53$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[2] {
desc="increments other phase state information to prepare for the next phase of settling";
flags=;
result_var=NULL;
obj=$52$;
method=LeabraNetwork::Trial_UpdatePhase;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
test {
expr="phase_no < network.phase_max";
var_expr="$#0#$ < $#1#$.phase_max";
vars {
};
var_names{ phase_no;network;};
bad_vars{ };
};
};
MethodCall @[3] {
desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
flags=;
result_var=NULL;
obj=$52$;
method=LeabraNetwork::Trial_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[4] {
desc="records data about the trial-level processing to a datatable for graphing/processing";
flags=;
target=$50$;
targ_ld_init="*LeabraTrialMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetUpdateView @[5] {
desc="update the network view(s) (only if update_net_view is true)";
flags=;
network_var=$52$;
update_var=.projects[0].programs.gp[0][5].vars[1]$55$;
};
};
};
Program @[6] {
name="LeabraSettle";
tags="Leabra, Std";
desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$7$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current cycle of settling (local loop counter)";
};
ProgVar @[1] {
name="min_cycles";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=NULL_CHECK;
desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
};
ProgVar @[2] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="if true, will update network views at end of settling";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=.projects[0].programs.gp[0][6].args[0]$56$;
local_ctr_var=.projects[0].programs.gp[0][6].vars[0]$57$;
counter=Network::cycle;
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=$56$;
local_ctr_var=$57$;
counter=Network::cycle;
};
MethodCall @[1] {
desc="resets input data, before getting new external inputs data from apply inputs call";
flags=;
result_var=NULL;
obj=$56$;
method=Network::Init_InputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[2] {
desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
flags=;
target=.projects[0].programs.gp[0][10]$58$;
targ_ld_init="*ApplyInputs*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
ProgramCall @[3] {
desc=;
flags=;
target=$24$;
targ_ld_init="*DA_Rew_Punish*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
IfElse @[4] {
desc=;
flags=;
cond {
expr="network.phase == LeabraNetwork::PLUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::PLUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=;
flags=;
obj=$56$;
path="cycle_max";
expr {
expr="30";
var_expr="30";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="number of cycles to run in minus phase";
flags=;
obj=$56$;
path="cycle_max";
expr {
expr="100";
var_expr="100";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
};
MethodCall @[5] {
desc="initializes various counters at start of settling";
flags=;
result_var=NULL;
obj=$56$;
method=LeabraNetwork::Settle_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[6] {
desc="get appropriate min_cycles value depending on which phase we're in";
flags=;
cond {
expr="network.phase_no <= 1";
var_expr="$#0#$.phase_no <= 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=.projects[0].programs.gp[0][6].vars[1]$59$;
expr {
expr="network.min_cycles";
var_expr="$#0#$.min_cycles";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=$59$;
expr {
expr="network.min_cycles_phase2";
var_expr="$#0#$.min_cycles_phase2";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
WhileLoop @[7] {
desc="the main loop over cycles of updating";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the cycle program, which computes one cycle of activations";
flags=;
target=.projects[0].programs.gp[0][8]$60$;
targ_ld_init="*LeabraCycle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment cycle counter (also on network)";
flags=;
network_var=$56$;
local_ctr_var=$57$;
counter=Network::cycle;
};
IfContinue @[2] {
desc="avoid subsequent stopping criteria if below min_cycles";
flags=;
cond {
expr="cycle < min_cycles";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ cycle;min_cycles;};
bad_vars{ };
};
};
IfBreak @[3] {
desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
flags=;
cond {
expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
var_expr="($#0#$.maxda < $#0#$.maxda_stopcrit) ||
 ($#0#$.trg_max_act > $#0#$.trg_max_act_stopcrit)";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
test {
expr="cycle < network.cycle_max";
var_expr="$#0#$ < $#1#$.cycle_max";
vars {
};
var_names{ cycle;network;};
bad_vars{ };
};
};
MethodCall @[8] {
desc="perform final operations at end of settling (storing final activations, etc)";
flags=;
result_var=NULL;
obj=$56$;
method=LeabraNetwork::Settle_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[9] {
desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
flags=;
cond {
expr="network.phase == LeabraNetwork::MINUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::MINUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="compute trial-level statistics";
flags=;
result_var=NULL;
obj=$56$;
method=LeabraNetwork::Compute_TrialStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
IfElse @[10] {
desc="this stat must be called in plus phase when reward information is avail";
flags=;
cond {
expr="network.phase_no == 1";
var_expr="$#0#$.phase_no == 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="get external reward information";
flags=;
result_var=NULL;
obj=$56$;
method=LeabraNetwork::Compute_ExtRew;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
NetUpdateView @[11] {
desc="update network views, if update_net_view == true";
flags=;
network_var=$56$;
update_var=.projects[0].programs.gp[0][6].vars[2]$61$;
};
};
};
Program @[7] {
name="LeabraTestSettle";
tags=;
desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle";
var_type=T_Int;
int_val=77;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current cycle of settling (local loop counter)";
};
ProgVar @[1] {
name="min_cycles";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=NULL_CHECK;
desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
};
ProgVar @[2] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="if true, will update network views at end of settling";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=.projects[0].programs.gp[0][7].args[0]$62$;
local_ctr_var=.projects[0].programs.gp[0][7].vars[0]$63$;
counter=Network::cycle;
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=$62$;
local_ctr_var=$63$;
counter=Network::cycle;
};
MethodCall @[1] {
desc="resets input data, before getting new external inputs data from apply inputs call";
flags=;
result_var=NULL;
obj=$62$;
method=Network::Init_InputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[2] {
desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
flags=;
target=.projects[0].programs.gp[0][11]$64$;
targ_ld_init="*ApplyInputsTest*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
ProgramCall @[3] {
desc=;
flags=;
target=$24$;
targ_ld_init="*DA_Rew_Punish*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
IfElse @[4] {
desc=;
flags=;
cond {
expr="network.phase == LeabraNetwork::PLUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::PLUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=;
flags=;
obj=$62$;
path="cycle_max";
expr {
expr="30";
var_expr="30";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="number of cycles to run in minus phase";
flags=;
obj=$62$;
path="cycle_max";
expr {
expr="100";
var_expr="100";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
};
MethodCall @[5] {
desc="initializes various counters at start of settling";
flags=;
result_var=NULL;
obj=$62$;
method=LeabraNetwork::Settle_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[6] {
desc="get appropriate min_cycles value depending on which phase we're in";
flags=;
cond {
expr="network.phase_no <= 1";
var_expr="$#0#$.phase_no <= 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=.projects[0].programs.gp[0][7].vars[1]$65$;
expr {
expr="network.min_cycles";
var_expr="$#0#$.min_cycles";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=$65$;
expr {
expr="network.min_cycles_phase2";
var_expr="$#0#$.min_cycles_phase2";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
WhileLoop @[7] {
desc="the main loop over cycles of updating";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the cycle program, which computes one cycle of activations";
flags=;
target=.projects[0].programs.gp[0][9]$66$;
targ_ld_init="*LeabraTestCycle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment cycle counter (also on network)";
flags=;
network_var=$62$;
local_ctr_var=$63$;
counter=Network::cycle;
};
IfContinue @[2] {
desc="avoid subsequent stopping criteria if below min_cycles";
flags=;
cond {
expr="cycle < min_cycles";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ cycle;min_cycles;};
bad_vars{ };
};
};
IfBreak @[3] {
desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
flags=;
cond {
expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
var_expr="($#0#$.maxda < $#0#$.maxda_stopcrit) ||
 ($#0#$.trg_max_act > $#0#$.trg_max_act_stopcrit)";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
test {
expr="cycle < network.cycle_max";
var_expr="$#0#$ < $#1#$.cycle_max";
vars {
};
var_names{ cycle;network;};
bad_vars{ };
};
};
MethodCall @[8] {
desc="perform final operations at end of settling (storing final activations, etc)";
flags=;
result_var=NULL;
obj=$62$;
method=LeabraNetwork::Settle_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[9] {
desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
flags=;
cond {
expr="network.phase == LeabraNetwork::MINUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::MINUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="compute trial-level statistics";
flags=;
result_var=NULL;
obj=$62$;
method=LeabraNetwork::Compute_TrialStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
IfElse @[10] {
desc="this stat must be called in plus phase when reward information is avail";
flags=;
cond {
expr="network.phase_no == 1";
var_expr="$#0#$.phase_no == 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="get external reward information";
flags=;
result_var=NULL;
obj=$62$;
method=LeabraNetwork::Compute_ExtRew;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
NetUpdateView @[11] {
desc="update network views, if update_net_view == true";
flags=;
network_var=$62$;
update_var=.projects[0].programs.gp[0][7].vars[2]$67$;
};
};
};
Program @[8] {
name="LeabraCycle";
tags="Leabra, Std";
desc="runs one cycle of leabra processing (updating net inputs and activations)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="this does all the standard leabra processing for one cycle of activation updating";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][8].args[0]$68$;
method=LeabraNetwork::Cycle_Run;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetUpdateView @[1] {
desc="update network views if update_net_view == true";
flags=;
network_var=$68$;
update_var=.projects[0].programs.gp[0][8].vars[0]$69$;
};
ProgramCall @[2] {
desc=;
flags=NON_STD;
target=.projects[0].programs.gp[0][13]$70$;
targ_ld_init="*Cycle_Monitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
};
};
Program @[9] {
name="LeabraTestCycle";
tags=;
desc="runs one cycle of leabra processing (updating net inputs and activations)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="this does all the standard leabra processing for one cycle of activation updating";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][9].args[0]$71$;
method=LeabraNetwork::Cycle_Run;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetUpdateView @[1] {
desc="update network views if update_net_view == true";
flags=;
network_var=$71$;
update_var=.projects[0].programs.gp[0][9].vars[0]$72$;
};
ProgramCall @[2] {
desc=;
flags=NON_STD;
target=$70$;
targ_ld_init="*Cycle_Monitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
};
};
Program @[10] {
name="ApplyInputs";
tags="Network, InputData, Apply";
desc="apply the current input data to the network as external input and target values";
flags=;
objs {
name=;
el_typ=LayerWriter;
el_def=0;
LayerWriter @[0] {
name="LayerWriter_0";
data=$7$;
network=$6$;
layer_data {
name=;
el_typ=LayerWriterEl;
el_def=0;
LayerWriterEl @[0] {
chan_name="Input";
net_target=LAYER;
layer_name="Input";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[1] {
chan_name="Output";
net_target=LAYER;
layer_name="Output";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[2] {
chan_name="SNc";
net_target=LAYER;
layer_name="SNc";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[3] {
chan_name="Motor_Cortex";
net_target=LAYER;
layer_name="Motor_Cortex";
offset {x=0: y=0: };
use_layer_type=0;
ext_flags=COMP;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[4] {
chan_name="Name";
net_target=TRIAL_NAME;
layer_name="Name";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
};
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to apply inputs to -- typically set by calling program";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$7$;
objs_ptr=0;
flags=NULL_CHECK;
desc="input datatable containing input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=.projects[0].programs.gp[0][10].objs[0]$73$;
objs_ptr=1;
flags=CTRL_PANEL|NULL_CHECK;
desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][10].vars[0]$74$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
flags=;
result_var=NULL;
obj=$74$;
method=taList_impl::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="apply inputs to the network!  layer writer has all the key specs";
flags=;
result_var=NULL;
obj=$74$;
method=LayerWriter::ApplyInputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[11] {
name="ApplyInputsTest";
tags=;
desc="apply the current input data to the network as external input and target values";
flags=;
objs {
name=;
el_typ=LayerWriter;
el_def=0;
LayerWriter @[0] {
name="LayerWriter_0";
data=$8$;
network=$6$;
layer_data {
name=;
el_typ=LayerWriterEl;
el_def=0;
LayerWriterEl @[0] {
chan_name="Input";
net_target=LAYER;
layer_name="Input";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[1] {
chan_name="Output";
net_target=LAYER;
layer_name="Output";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[2] {
chan_name="SNc";
net_target=LAYER;
layer_name="SNc";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[3] {
chan_name="Motor_Cortex";
net_target=LAYER;
layer_name="Motor_Cortex";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[4] {
chan_name="Name";
net_target=TRIAL_NAME;
layer_name="Name";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
};
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$6$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to apply inputs to -- typically set by calling program";
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc="input datatable containing input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=.projects[0].programs.gp[0][11].objs[0]$75$;
objs_ptr=1;
flags=CTRL_PANEL|NULL_CHECK;
desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][11].vars[0]$76$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
flags=;
result_var=NULL;
obj=$76$;
method=taList_impl::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="apply inputs to the network!  layer writer has all the key specs";
flags=;
result_var=NULL;
obj=$76$;
method=LayerWriter::ApplyInputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[12] {
name="LeabraTrialMonitor";
tags="Leabra, Std, Monitor";
desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="trial_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="trial";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="trial";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="trial_name";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="trial_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="group_name";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="group_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="phase_no";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="phase_no";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[6] {
name="minus_cycles";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="minus_cycles";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[7] {
name="sse";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[8] {
name="ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[9] {
name="Output_sse";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[7]$77$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$6$;
data=$27$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to record data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$27$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="data table to record trial-level data to (this program writes new data to this table!)";
};
ProgVar @[1] {
name="trial_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][12].objs[0]$78$;
objs_ptr=1;
flags=NULL_CHECK;
desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="set the network and datatable for the NetMonitor";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].vars[1]$79$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="trial_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ trial_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
flags=;
result_var=NULL;
obj=$79$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[2] {
desc="update the monitor items and data schema based on current settings of the NetMonitor object";
flags=;
result_var=NULL;
obj=$79$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].vars[0]$80$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[1] {
desc="get the new monitor data from the network and other sources -- this does the main work";
flags=;
result_var=NULL;
obj=$79$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[2] {
desc="update views and other things after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$80$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[3] {
desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].args[0]$81$;
method=Network::DMem_ShareTrialData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=1;
def_val=;
expr {
expr="trial_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ trial_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="n_rows";
required=0;
def_val="1";
expr {
expr="1";
var_expr="1";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
};
Program @[13] {
name="Cycle_Monitor";
tags=;
desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="cycle_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="trial";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="trial";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="trial_name";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="trial_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="group_name";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="group_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="phase_no";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="phase_no";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[6] {
name="cycle";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="cycle";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[7] {
name="sse";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[8] {
name="ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[9] {
name="STN_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[8]$82$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[10] {
name="Motor__acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[6]$83$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[11] {
name="Thalam_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[5]$84$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[12] {
name="GP_Int_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[3]$85$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[13] {
name="GP_Ext_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[4]$86$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[14] {
name="Output_act";
computed=0;
object_type=LeabraLayer;
object=$77$;
variable="act";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[15] {
name="Output_units_0_act";
computed=0;
object_type=LeabraLayer;
object=$77$;
variable="units[0].act";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$6$;
data=.projects[0].data.gp[1][2]$87$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to record data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$87$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="data table to record trial-level data to (this program writes new data to this table!)";
};
ProgVar @[1] {
name="cycle_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][13].objs[0]$88$;
objs_ptr=1;
flags=NULL_CHECK;
desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="set the network and datatable for the NetMonitor";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].vars[1]$89$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="cycle_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ cycle_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
flags=;
result_var=NULL;
obj=$89$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[2] {
desc="update the monitor items and data schema based on current settings of the NetMonitor object";
flags=;
result_var=NULL;
obj=$89$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
IfReturn @[0] {
desc=;
flags=;
cond {
expr="network.phase_no>0";
var_expr="$#0#$.phase_no>0";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[1] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].vars[0]$90$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[2] {
desc="get the new monitor data from the network and other sources -- this does the main work";
flags=;
result_var=NULL;
obj=$89$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[3] {
desc="update views and other things after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$90$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[4] {
desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].args[0]$91$;
method=Network::DMem_ShareTrialData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=1;
def_val=;
expr {
expr="cycle_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ cycle_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="n_rows";
required=0;
def_val="1";
expr {
expr="1";
var_expr="1";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
};
Program @[14] {
name="LeabraEpochMonitor";
tags="Leabra, Std, Monitor";
desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="epoch_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="avg_sse";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="avg_sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="cnt_err";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="cnt_err";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="avg_ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$6$;
variable="avg_ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="Output_sse";
computed=0;
object_type=LeabraLayer;
object=$77$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$6$;
data=.projects[0].data.gp[1][1]$92$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to get data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="epoch_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$92$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="data table to write the epoch data to";
};
ProgVar @[1] {
name="epoch_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][14].objs[0]$93$;
objs_ptr=1;
flags=NULL_CHECK;
desc="network monitor object that contains full specs for what to record and where to get it";
};
ProgVar @[2] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=$28$;
objs_ptr=0;
flags=NULL_CHECK;
desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=AssignExpr;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc="get the epoch timer from current network";
flags=;
result_var=.projects[0].programs.gp[0][14].vars[2]$94$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[1] {
desc="set data and network on NetMonitor object";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][14].vars[1]$95$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="epoch_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ epoch_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[2] {
desc="check configuration and emit errors/warnings for problems";
flags=;
result_var=NULL;
obj=$95$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[3] {
desc="update the monitor items and data schema based on current settings of NetMonitor";
flags=;
result_var=NULL;
obj=$95$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][14].vars[0]$96$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[1] {
desc="get the new monitor data and stor it into the data table -- this does the main job here";
flags=;
result_var=NULL;
obj=$95$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
AssignExpr @[2] {
desc="get the epoch timer from current network";
flags=;
result_var=$94$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[3] {
desc="update after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$96$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[15] {
name="SaveWeights";
tags="Network, Weights";
desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=NULL;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="tag";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="user-provided tag (startup script will set this!)";
};
ProgVar @[1] {
name="wts_subdir";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="user-provided subdirectory to save weights in";
};
ProgVar @[2] {
name="fname";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="final generated file name -- do not edit!";
};
ProgVar @[3] {
name="epoch_str";
var_type=T_String;
string_val="0036";
objs_ptr=0;
flags=NULL_CHECK;
desc="string rep of epoch with leading zeros";
};
ProgVar @[4] {
name="batch_str";
var_type=T_String;
string_val="03";
objs_ptr=0;
flags=NULL_CHECK;
desc="string rep of batch with leading zeros";
};
ProgVar @[5] {
name="final_tag";
var_type=T_String;
string_val=".03_0036";
objs_ptr=0;
flags=NULL_CHECK;
desc="batch + epoch";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
IfReturn @[0] {
desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
flags=;
cond {
expr="taMisc::dmem_proc > 0";
var_expr="taMisc::dmem_proc > 0";
vars {
};
var_names{ };
bad_vars{ };
};
};
MiscCall @[1] {
desc="get current batch counter for file name, with leading zeros to length 3";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[4]$97$;
object_type=taMisc;
method=taMisc::LeadingZeros;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=int;
type="int";
name="num";
required=0;
def_val=;
expr {
expr="network.batch";
var_expr="$#0#$.batch";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="len";
required=0;
def_val=;
expr {
expr="2";
var_expr="2";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[2] {
desc="get current epoch counter with leading zeros to length 4";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[3]$98$;
object_type=taMisc;
method=taMisc::LeadingZeros;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=int;
type="int";
name="num";
required=0;
def_val=;
expr {
expr="network.epoch";
var_expr="$#0#$.epoch";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="len";
required=0;
def_val=;
expr {
expr="4";
var_expr="4";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
AssignExpr @[3] {
desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[5]$99$;
expr {
expr="tag + \".\" + batch_str + \"_\" + epoch_str";
var_expr="$#0#$ + \".\" + $#1#$ + \"_\" + $#2#$";
vars {
};
var_names{ tag;batch_str;epoch_str;};
bad_vars{ };
};
};
MethodCall @[4] {
desc="get a file name based on the project's current file name, for saving the weights";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[2]$100$;
obj=.projects[0].programs.gp[0][15].args[0]$101$;
method=taBase::GetFileNameFmProject;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="ext";
required=1;
def_val=;
expr {
expr="\".wts.gz\"";
var_expr="\".wts.gz\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="tag";
required=0;
def_val="\"\"";
expr {
expr="final_tag";
var_expr="$#0#$";
vars {
};
var_names{ final_tag;};
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=const_taString_ref;
type="const taString&";
name="subdir";
required=0;
def_val="\"\"";
expr {
expr="wts_subdir";
var_expr="$#0#$";
vars {
};
var_names{ wts_subdir;};
bad_vars{ };
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="dmem_proc_no";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[5] {
desc="save the weights to that file name";
flags=;
result_var=NULL;
obj=$101$;
method=Network::SaveWeights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="fname";
required=0;
def_val="\"\"";
expr {
expr="fname";
var_expr="$#0#$";
vars {
};
var_names{ fname;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network::WtSaveFormat;
type="Network::WtSaveFormat";
name="fmt";
required=0;
def_val="Network::NET_FMT";
expr {
expr="Network::NET_FMT";
var_expr="Network::NET_FMT";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
};
Program @[16] {
name="DA_Rew_Punish";
tags=;
desc=;
flags=;
objs {
name=;
el_typ=taNBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$6$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to train";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[1] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[2] {
name="k";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[3] {
name="sse";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[4] {
name="act0";
var_type=T_Real;
real_val=2.585929053111613e-07;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[5] {
name="act1";
var_type=T_Real;
real_val=0.9375092387199402;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[6] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$16$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[7] {
name="Output";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$77$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[8] {
name="Motor_Cortex";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$83$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[9] {
name="matrisom_unitspec";
var_type=T_Object;
object_type=LeabraUnitSpec;
object_val=.projects[0].networks[0].specs.gp[2][0].children[3].children[0]$102$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[10] {
name="i";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[11] {
name="tonic_DA";
var_type=T_Real;
real_val=0.03;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[12] {
name="op_sse";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[13] {
name="DA_dip_val";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[14] {
name="DA_burst_val";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=Function;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[1]$103$;
expr {
expr="SNc.units.size";
var_expr="$#0#$.units.size";
vars {
};
var_names{ SNc;};
bad_vars{ };
};
};
AssignExpr @[1] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[2]$104$;
expr {
expr="(float)num_intact_snc_units/ snc_size";
var_expr="(float)$#0#$/ $#1#$";
vars {
};
var_names{ num_intact_snc_units;snc_size;};
bad_vars{ };
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[3]$105$;
expr {
expr="network.sse";
var_expr="$#0#$.sse";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
IfElse @[3] {
desc="apply phasic DA in plus phase";
flags=;
cond {
expr="network.phase==LeabraNetwork::PLUS_PHASE";
var_expr="$#0#$.phase==LeabraNetwork::PLUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
IfElse @[0] {
desc="if error is  below threshold, given DA burst";
flags=;
cond {
expr="k>0&&Output.sse<0.5";
var_expr="$#0#$>0&&$#1#$.sse<0.5";
vars {
};
var_names{ k;Output;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set external input on SNC to high value for DA burst";
flags=;
obj=.projects[0].programs.gp[0][16].vars[6]$106$;
path="units[i].ext";
expr {
expr="DA_burst_val";
var_expr="$#0#$";
vars {
};
var_names{ DA_burst_val;};
bad_vars{ };
};
update_after=0;
};
};
init {
expr="i = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ i;};
bad_vars{ };
};
test {
expr="i < snc_size";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
MemberAssign @[1] {
desc="set striatal gain in proportion to DA and # intact Snc units";
flags=;
obj=.projects[0].programs.gp[0][16].vars[9]$107$;
path="act.gain";
expr {
expr="k*10000";
var_expr="$#0#$*10000";
vars {
};
var_names{ k;};
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set DA units to 0 for DA dip";
flags=;
obj=$106$;
path="units[i].ext";
expr {
expr="DA_dip_val";
var_expr="$#0#$";
vars {
};
var_names{ DA_dip_val;};
bad_vars{ };
};
update_after=0;
};
};
init {
expr="i = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ i;};
bad_vars{ };
};
test {
expr="i < snc_size";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
MemberAssign @[1] {
desc="set striatal gain to be lower for DA dip (less D1 contrast enhancement)";
flags=;
obj=$107$;
path="act.gain";
expr {
expr="600-k*300";
var_expr="600-$#0#$*300";
vars {
};
var_names{ k;};
bad_vars{ };
};
update_after=0;
};
};
};
AssignExpr @[1] {
desc="store minus phase activation of motor ctx unit 0";
flags=;
result_var=.projects[0].programs.gp[0][16].vars[4]$108$;
expr {
expr="Motor_Cortex.units[0].act_m";
var_expr="$#0#$.units[0].act_m";
vars {
};
var_names{ Motor_Cortex;};
bad_vars{ };
};
};
AssignExpr @[2] {
desc="store minus phase act of motor unit 1";
flags=;
result_var=.projects[0].programs.gp[0][16].vars[5]$109$;
expr {
expr="Motor_Cortex.units[1].act_m";
var_expr="$#0#$.units[1].act_m";
vars {
};
var_names{ Motor_Cortex;};
bad_vars{ };
};
};
IfElse @[3] {
desc="if model selected R1";
flags=;
cond {
expr="act0>act1";
var_expr="$#0#$>$#1#$";
vars {
};
var_names{ act0;act1;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=.projects[0].programs.gp[0][16].vars[8]$110$;
path="units[0].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[1] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$110$;
path="units[1].ext";
expr {
expr="0.0";
var_expr="0.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[2] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$110$;
path="units[2].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[3] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$110$;
path="units[3].ext";
expr {
expr="0";
var_expr="0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$110$;
path="units[0].ext";
expr {
expr="0";
var_expr="0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[1] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$110$;
path="units[1].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[2] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$110$;
path="units[2].ext";
expr {
expr="0";
var_expr="0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[3] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$110$;
path="units[3].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set tonic DA val";
flags=;
obj=$106$;
path="units[i].ext";
expr {
expr="tonic_DA";
var_expr="$#0#$";
vars {
};
var_names{ tonic_DA;};
bad_vars{ };
};
update_after=0;
};
MemberAssign @[1] {
desc="set striatal gain in proportion to DA and # intact Snc units";
flags=;
obj=$107$;
path="act.gain";
expr {
expr="k*2500";
var_expr="$#0#$*2500";
vars {
};
var_names{ k;};
bad_vars{ };
};
update_after=0;
};
};
init {
expr="i = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ i;};
bad_vars{ };
};
test {
expr="i < snc_size";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
};
};
};
};
};
};
viewers {
name=;
el_typ=TopLevelViewer;
el_def=0;
MainWindowViewer @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_lft";
value 6 0=0;
};
UserDataItem @[1] {
name="view_win_top";
value 6 0=0;
};
UserDataItem @[2] {
name="view_win_wd";
value 6 0=1;
};
UserDataItem @[3] {
name="view_win_ht";
value 6 0=0.8306772708892822;
};
UserDataItem @[4] {
name="view_win_iconified";
value 1 0=0;
};
UserDataItem @[5] {
name="view_splitter_state";
value 9 0="AAAA/wAAAAAAAAADAAAAyQAAAhkAAAM6AQAAAAYBAAAAAQ==";
};
};
m_data=.projects[0]$111$;
name="Browser";
visible=1;
m_is_root=0;
m_is_viewer_xor_browser=0;
m_is_proj_viewer=1;
m_is_dialog=0;
toolbars {
name=;
el_typ=ToolBar;
el_def=0;
ToolBar @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_visible";
value 1 0=1;
};
};
m_data=NULL;
name="Application";
visible=0;
lft=0;
top=0.03087649;
o=Horizontal;
};
};
frames {
name=;
el_typ=FrameViewer;
el_def=0;
tabBrowseViewer @[0] {
m_data=NULL;
name="Tree";
visible=1;
root_typ=LeabraProject;
root_md=NULL;
m_root=$111$;
};
PanelViewer @[1] {
m_data=NULL;
name="Panels";
visible=1;
};
T3DataViewer @[2] {
m_data=NULL;
name="T3Frames";
visible=1;
frames {
name=;
el_typ=T3DataViewFrame;
el_def=0;
T3DataViewFrame @[0] {
m_data=NULL;
name="Frame2";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
NetView @[0] {
m_data=$6$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
lay_disp_modes{ Input=0;Striatum=0;SNc=0;GP_Int=0;GP_Ext=0;Thalamus=0;Motor_Cortex=0;Output=0;STN=0;};
scale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=1;
zero=0;
spec=.colorspecs[0]$112$;
auto_scale=0;
};
scale_ranges {
name=;
el_typ=ScaleRange;
el_def=0;
ScaleRange @[0] {
name="act";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[1] {
name="r.wt";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[2] {
name="net";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[3] {
name="vcb.hyst";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[4] {
name="spk_amp";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[5] {
name="s.pdw";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[6] {
name="r.pdw";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[7] {
name="s.wt";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[8] {
name="i_thr";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[9] {
name="v_m";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[10] {
name="I_net";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[11] {
name="gc.a";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[12] {
name="gc.h";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[13] {
name="gc.i";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[14] {
name="gc.l";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[15] {
name="vcb.acc";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[16] {
name="da";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[17] {
name="act_dif";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[18] {
name="act_p";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[19] {
name="act_m";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[20] {
name="act_avg";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[21] {
name="act_eq";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[22] {
name="wt_prjn";
auto_scale=0;
min=-1;
max=1;
};
};
display=1;
lay_mv=1;
ordered_uvg_list{ act;};
unit_disp_mode=UDM_CYLINDER;
unit_text_disp=UTD_NONE;
max_size {x=14: y=9: z=3: };
font_sizes {
net_name=0.05;
net_vals=0.05;
layer=0.04;
layer_vals=0.03;
prjn=0.01;
unit=0.02;
un_nm_len=3;
};
view_params {
xy_square=0;
unit_spacing=0.05;
prjn_disp=L_R_F;
prjn_name=0;
prjn_width=0.002;
prjn_trans=0.5;
lay_trans=0.5;
unit_trans=0.6;
};
wt_line_disp=0;
wt_line_width=4;
wt_line_thr=0.5;
wt_line_swt=0;
wt_prjn_lay=NULL;
};
};
};
camera_pos {x=0.402234: y=0.6367046: z=1.43305: };
camera_orient {x=-0.8865634: y=-0.412627: z=-0.2091311: rot=0.1436121: };
camera_focdist=1.874225;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[1] {
m_data=NULL;
name="CycleOutputData";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=$87$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[1][2].data[0]$113$;
m_transform=NULL;
name="batch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[1][2].data[1]$114$;
m_transform=NULL;
name="epoch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[1][2].data[2]$115$;
m_transform=NULL;
name="trial";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[1][2].data[3]$116$;
m_transform=NULL;
name="trial_name";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[1][2].data[4]$117$;
m_transform=NULL;
name="group_name";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[1][2].data[5]$118$;
m_transform=NULL;
name="phase_no";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[6] {
m_data=.projects[0].data.gp[1][2].data[6]$119$;
m_transform=NULL;
name="cycle";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[7] {
m_data=.projects[0].data.gp[1][2].data[7]$120$;
m_transform=NULL;
name="sse";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[8] {
m_data=.projects[0].data.gp[1][2].data[8]$121$;
m_transform=NULL;
name="ext_rew";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[9] {
m_data=.projects[0].data.gp[1][2].data[9]$122$;
m_transform=NULL;
name="STN_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[10] {
m_data=.projects[0].data.gp[1][2].data[10]$123$;
m_transform=NULL;
name="Motor__acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[11] {
m_data=.projects[0].data.gp[1][2].data[11]$124$;
m_transform=NULL;
name="Thalam_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[12] {
m_data=.projects[0].data.gp[1][2].data[12]$125$;
m_transform=NULL;
name="GP_Int_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[13] {
m_data=.projects[0].data.gp[1][2].data[13]$126$;
m_transform=NULL;
name="GP_Ext_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[14] {
m_data=.projects[0].data.gp[1][2].data[14]$127$;
m_transform=NULL;
name="Output_act";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[15] {
m_data=.projects[0].data.gp[1][2].data[15]$128$;
m_transform=NULL;
name="Output_units_0_act";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=-1: };
display_on=0;
manip_ctrl_on=1;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="cycle";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name="batch";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="STN_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=-6e-07: max=6e-07: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="Motor__acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0.588618: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0.5886178: };
range {min=0: max=0.5886178: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="GP_Int_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="GP_Ext_acts_avg";
fixed_range {fix_min=0: min=5.69961e-10: fix_max=0: max=0.986826: };
color {name="green": r=0: g=1: b=0: a=1: desc="": };
data_range {min=5.699612e-10: max=0.9868261: };
range {min=5.699612e-10: max=0.9868261: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="Thalam_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0.4855: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=0.4854995: };
range {min=0: max=0.4854995: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
};
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
graph_type=XY;
plot_style=LINE;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
color_mode=VALUE_COLOR;
negative_draw=0;
axis_font_size=0.05;
label_font_size=0.04;
label_spacing=-1;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
err_1 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_spacing=1;
err_bar_width=0.02;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$112$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
width=1;
depth=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.37625: y=0.4125: z=1.389598: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=1.899598;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[2] {
m_data=NULL;
name="EpochOutputData";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=$92$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[1][1].data[0]$129$;
m_transform=NULL;
name="batch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[1][1].data[1]$130$;
m_transform=NULL;
name="epoch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=4: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[1][1].data[2]$131$;
m_transform=NULL;
name="avg_sse";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[1][1].data[3]$132$;
m_transform=NULL;
name="cnt_err";
visible=1;
fixed_range {fix_min=1: min=0: fix_max=1: max=13: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[1][1].data[4]$133$;
m_transform=NULL;
name="avg_ext_rew";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[1][1].data[5]$134$;
m_transform=NULL;
name="Output_sse";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=-1: };
display_on=0;
manip_ctrl_on=1;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="epoch";
fixed_range {fix_min=0: min=0: fix_max=0: max=4: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=4: };
range {min=0: max=4: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name="batch";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="cnt_err";
fixed_range {fix_min=1: min=0: fix_max=1: max=13: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=13: };
range {min=0: max=13: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
};
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
graph_type=XY;
plot_style=LINE;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
color_mode=VALUE_COLOR;
negative_draw=0;
axis_font_size=0.05;
label_font_size=0.04;
label_spacing=-1;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
err_1 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_spacing=1;
err_bar_width=0.02;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$112$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
width=1;
depth=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.4275: y=1.095: z=2.27914: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=2.76914;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[3] {
m_data=NULL;
name="EpochOutputData_Group";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=.projects[0].data.gp[2][0]$135$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[2][0].data[0]$136$;
m_transform=NULL;
name="epoch_group";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=4: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[2][0].data[1]$137$;
m_transform=NULL;
name="batch_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[2][0].data[2]$138$;
m_transform=NULL;
name="batch_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[2][0].data[3]$139$;
m_transform=NULL;
name="avg_sse_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[2][0].data[4]$140$;
m_transform=NULL;
name="avg_sse_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[2][0].data[5]$141$;
m_transform=NULL;
name="cnt_err_mean";
visible=1;
fixed_range {fix_min=1: min=0: fix_max=1: max=7: };
data_range {min=0: max=0: };
};
GraphColView @[6] {
m_data=.projects[0].data.gp[2][0].data[6]$142$;
m_transform=NULL;
name="cnt_err_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[7] {
m_data=.projects[0].data.gp[2][0].data[7]$143$;
m_transform=NULL;
name="avg_ext_rew_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[8] {
m_data=.projects[0].data.gp[2][0].data[8]$144$;
m_transform=NULL;
name="avg_ext_rew_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[9] {
m_data=.projects[0].data.gp[2][0].data[9]$145$;
m_transform=NULL;
name="Output_sse_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[10] {
m_data=.projects[0].data.gp[2][0].data[10]$146$;
m_transform=NULL;
name="Output_sse_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=4: };
display_on=1;
manip_ctrl_on=1;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="epoch_group";
fixed_range {fix_min=0: min=0: fix_max=0: max=4: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=4: };
range {min=0: max=4: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="cnt_err_mean";
fixed_range {fix_min=1: min=0: fix_max=1: max=7: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=7: };
range {min=0: max=7: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
};
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
graph_type=XY;
plot_style=LINE;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
color_mode=FIXED_COLOR;
negative_draw=0;
axis_font_size=0.05;
label_font_size=0.04;
label_spacing=-1;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
err_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="cnt_err_sem";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_spacing=1;
err_bar_width=0.02;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$112$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
width=1;
depth=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.406748: y=0.445: z=1.648402: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=1.660902;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
};
};
};
docks {
name=;
el_typ=DockViewer;
el_def=0;
ToolBoxDockViewer @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_lft";
value 6 0=0;
};
UserDataItem @[1] {
name="view_win_top";
value 6 0=0.06474103778600693;
};
UserDataItem @[2] {
name="view_win_wd";
value 6 0=0.0535714291036129;
};
UserDataItem @[3] {
name="view_win_ht";
value 6 0=0.7131474018096924;
};
UserDataItem @[4] {
name="view_win_iconified";
value 1 0=0;
};
UserDataItem @[5] {
name="view_visible";
value 1 0=1;
};
};
m_data=NULL;
name="Tools";
visible=1;
dock_flags=DV_MOVABLE|DV_FLOATABLE;
dock_area=1;
};
};
};
};
use_change_log=0;
last_change_desc="
";
networks {
name=;
el_typ=LeabraNetwork;
el_def=0;
LeabraNetwork @[0] {
name="IntactNet";
desc=;
specs {
name=;
el_typ=ConSpec;
el_def=0;
ConSpec @[0] {
name="ConSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=ConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0: var=0.5: par=1: };
wt_limits {type=NONE: min=-1: max=1: sym=0: };
};
UniformRndPrjnSpec @[1] {
name="STN_GPe_RndPrjnSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=UniformRndPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
p_con=1;
sym_self=1;
same_seed=0;
rndm_seed {
name=;
seed{ 1942590695;1834211083;377798523;839440218;-583226373;705799995;-1978402924;1154338458;-462115379;246653898;1399794034;-1499780727;-1523899271;930991332;1290781086;1827104268;-716397506;1983718083;1167094774;951783845;-409479048;-735831888;435869947;-904086293;2026496515;403361634;-1944445990;-1372202487;2126959386;162557442;1012427038;1588232218;-1146450552;-853562653;-1656209805;-1888253373;1759765356;1728652414;-337014879;-1280803374;-575509963;-1765188122;-384524531;-821312351;-1870977276;1513531657;1301908149;699607679;871722190;941230124;480719736;-879564786;-698046303;1521335322;-1447079851;-716252964;526031609;1993676142;1340787872;1530654116;-969427509;1134915315;2122089688;-994370515;560929468;389650548;-1122373860;166734577;-286623372;-120943880;891391534;1880819345;-178283282;540924398;-472340061;2110112996;-1254638769;1538060551;1673190834;691970619;-959237381;-1357813313;1768507679;-1214978919;785612098;1900739683;2119690407;432529262;1597777345;-76740981;1752989913;507595810;1970077571;2120922148;-975091467;-1195485087;-2116172007;-1448521787;-1611468311;1523616406;1943148525;-1864229143;-937095503;-909740123;1292237191;387974384;538406262;509446046;-1972547268;-1733600336;-62144424;-1546025606;-1876304799;1885604132;1402880751;-482628413;1554473651;267768126;-629382805;-1249311349;-1924387261;1461040170;509667270;-779074633;-17507771;918255996;-143015157;-2090640919;315301152;702021484;808635402;-2068859673;-1347883889;1693940293;1805057885;-1668427604;-2137413199;-1104482850;208495526;118430790;-722180698;-1217415633;-224256734;1932248267;-1065779137;-10863097;487580081;-196290919;680669227;1979774005;-2037050706;21949689;-156516075;1715173136;1755205487;1472371560;1309034448;-829238765;-135616049;-2013309212;-1082863329;-899363014;-1287869739;-870456151;581622390;-1908234714;-1126900746;764733716;-925858573;-1751091051;-463341148;644681747;-1914494877;373038127;1588478313;1485299105;661291536;-1180395328;-1144161539;94598643;-1088175949;1032986199;-1100837220;407686955;-1082470443;1911682705;1627415103;310787166;1264015414;424266369;-2027001547;-1752167701;-228113290;1600850810;-2083186300;-1987228633;2000848866;-1395386373;80656148;317238254;-1145747623;-511425939;1346724944;180295410;-544883384;1732680478;-1525854862;236088797;1630557266;1645104332;445726791;1077576696;-2008807651;-2004400849;1274587809;1448655060;1550063216;454064067;-221087611;-594550512;-1272829249;1417249337;463284529;432100395;1078285484;-959540334;21248325;-866258652;-1081481128;-1833368508;-1379133116;-1920337657;-1251994147;1350814969;1508926409;1457463506;-436457777;-104638987;-300707471;-917721278;-620891785;523732153;445406412;1634813528;463926328;1581054136;170598643;-416905380;-1864557289;-202014810;1443533836;-1579728646;-1569783365;398032325;603645793;1459091613;-89353942;-1032688516;-1615894428;-767185823;-1946032362;931360128;-836341533;-1238311242;26872554;-1198342849;223875202;1787898723;1347039535;1426899535;712166878;1007370589;-2121265931;1279068215;1048275580;665564878;-854576448;1115606454;-1938871068;437377701;1893989311;60057612;-1411480578;-1802660403;-1229197402;-1114162509;1246510289;-100045555;-771237462;-321537560;1645429527;876081854;-344012824;613155858;-58817405;150811542;-10210852;2112860797;-528954460;-50850354;-649972970;1499955930;1421666445;1351215729;-1262602010;-980699257;1941355339;-961944897;-413046848;-411502877;522743470;-1432644237;-1120760559;-776500101;-1809149014;2127519490;470896056;662683123;-567303983;121758873;-1581863489;-91906121;-996490915;1435662432;1657906168;-1808273636;-1008367748;1370467542;775127407;336430775;908983458;-1287820551;2018562582;684733517;1364159782;839309547;1634308483;-497817377;118348535;-1269053010;955697418;-461911650;286131813;-300370221;1037538534;2023161463;-259022712;-1784489335;970316778;1578200481;500283714;1165730615;1099858613;850929875;-122366113;1415506233;-119359212;-2033313111;2063284557;168272506;1014246244;1972611072;1049837341;2120277277;-1358473916;867839429;1548671628;375995816;335745466;-92761852;-1313606594;983851877;957484913;-786771928;1174167013;457619777;1577173252;29408666;-1853196004;-954511750;-9741238;1764765760;-1106091459;418868525;1218646124;244543749;1280742435;-1669454769;1391623016;-1782787888;1672996012;-660347923;1734104018;-70130822;-1181208948;-285723476;-1959961034;42073851;-1354695576;-548612189;-692983842;1398992433;-1954474622;-414265610;1827986420;-1740813210;392408431;812967600;306150025;1150550306;-1577525793;522329421;-1905599679;1183746118;1873227418;113271279;-118624832;2064640613;91279896;-1296994070;923686864;-1237563925;-671532219;432504743;376157897;-1964026811;-509307951;-1291095292;-92298376;-440266966;742491999;-363297213;907719292;-2097711796;-72292200;797405338;-902353499;-166246906;-943459407;-1618209704;296966888;276718739;881687730;-63517562;-481360418;-1200473828;-144528583;2055425204;425514158;-972984629;-437772543;955225817;-1571664087;1255280381;-1520917476;411210494;-1044569805;1196139168;1000345811;314304961;788619297;-1721237341;1855193732;-688848034;-560160224;110451616;205166806;1045130054;606457223;-106064310;-350539693;-1199925658;-1553567608;1827860289;-495518821;-289479856;-1888403873;66174658;-1741606928;-1734480553;1792669379;2112354548;649961546;-1072485902;1950021075;-145032130;-1448841129;-455451267;-1966366114;-1298920795;837046384;-1783493271;1554055716;544335337;-302006934;-149606522;2022999324;826072250;-549276476;1862748770;1989186214;1089115433;956552701;1745621701;-2034815611;614102796;1479888671;-146686913;-690079684;-1114868597;-2016690506;2090920277;-830594320;-1261017876;2072821639;194345641;-1605828714;484660319;-454560202;1794417171;511341824;-1255389158;-669363423;1164033229;-1107097310;828519990;1450362036;476068860;1972265003;-1879752310;1894610209;-2128722743;1301770305;-1624467838;-731973801;-337476939;-1809040191;1525193216;-2001741915;-2027225998;-1162995606;-717541281;2050620663;-1135005089;2015601957;-1661832271;334966618;-236871560;-2075212969;-2141684690;1078043241;1723366617;828122061;147352703;-1999649046;-903143402;-1024430520;1633016716;-1604804280;1647853874;1626223577;613437415;854959232;-1237163556;-230090669;-278438371;1723117265;500023237;-1216412905;1717506101;1373064296;1994723034;1814828511;2067592941;937637146;-1370177392;-1274587966;-48108349;-378201671;1262614325;62390688;164974972;-830307263;-1714046089;1359544797;2016161042;83584009;930716322;-497279679;2023049077;-206104661;1501245447;562523072;104611198;-46372430;298890283;2110698786;-1091302072;20052267;-1304541777;140132249;-1245355586;-727077616;-316829592;152731111;-154344094;1345278005;-558417490;1281066959;-1469762051;-383552934;199222085;413618054;1552260824;-576003758;105415137;2042323739;1646910169;1084993049;840296744;216680633;1409468883;-1555896089;734078106;};
mti=115;
};
};
UniformRndPrjnSpec @[2] {
name="GPe_STN_RndPrjnSpec_1";
desc=;
unique{ };
children {
name=;
el_typ=UniformRndPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
p_con=0.4;
sym_self=1;
same_seed=0;
rndm_seed {
name=;
seed{ 1942590695;1834211083;377798523;839440218;-583226373;705799995;-1978402924;1154338458;-462115379;246653898;1399794034;-1499780727;-1523899271;930991332;1290781086;1827104268;-716397506;1983718083;1167094774;951783845;-409479048;-735831888;435869947;-904086293;2026496515;403361634;-1944445990;-1372202487;2126959386;162557442;1012427038;1588232218;-1146450552;-853562653;-1656209805;-1888253373;1759765356;1728652414;-337014879;-1280803374;-575509963;-1765188122;-384524531;-821312351;-1870977276;1513531657;1301908149;699607679;871722190;941230124;480719736;-879564786;-698046303;1521335322;-1447079851;-716252964;526031609;1993676142;1340787872;1530654116;-969427509;1134915315;2122089688;-994370515;560929468;389650548;-1122373860;166734577;-286623372;-120943880;891391534;1880819345;-178283282;540924398;-472340061;2110112996;-1254638769;1538060551;1673190834;691970619;-959237381;-1357813313;1768507679;-1214978919;785612098;1900739683;2119690407;432529262;1597777345;-76740981;1752989913;507595810;1970077571;2120922148;-975091467;-1195485087;-2116172007;-1448521787;-1611468311;1523616406;1943148525;-1864229143;-937095503;-909740123;1292237191;387974384;538406262;509446046;-1972547268;-1733600336;-62144424;-1546025606;-1876304799;1885604132;1402880751;-482628413;1554473651;267768126;-629382805;-1249311349;-1924387261;1461040170;509667270;-779074633;-17507771;918255996;-143015157;-2090640919;315301152;702021484;808635402;-2068859673;-1347883889;1693940293;1805057885;-1668427604;-2137413199;-1104482850;208495526;118430790;-722180698;-1217415633;-224256734;1932248267;-1065779137;-10863097;487580081;-196290919;680669227;1979774005;-2037050706;21949689;-156516075;1715173136;1755205487;1472371560;1309034448;-829238765;-135616049;-2013309212;-1082863329;-899363014;-1287869739;-870456151;581622390;-1908234714;-1126900746;764733716;-925858573;-1751091051;-463341148;644681747;-1914494877;373038127;1588478313;1485299105;661291536;-1180395328;-1144161539;94598643;-1088175949;1032986199;-1100837220;407686955;-1082470443;1911682705;1627415103;310787166;1264015414;424266369;-2027001547;-1752167701;-228113290;1600850810;-2083186300;-1987228633;2000848866;-1395386373;80656148;317238254;-1145747623;-511425939;1346724944;180295410;-544883384;1732680478;-1525854862;236088797;1630557266;1645104332;445726791;1077576696;-2008807651;-2004400849;1274587809;1448655060;1550063216;454064067;-221087611;-594550512;-1272829249;1417249337;463284529;432100395;1078285484;-959540334;21248325;-866258652;-1081481128;-1833368508;-1379133116;-1920337657;-1251994147;1350814969;1508926409;1457463506;-436457777;-104638987;-300707471;-917721278;-620891785;523732153;445406412;1634813528;463926328;1581054136;170598643;-416905380;-1864557289;-202014810;1443533836;-1579728646;-1569783365;398032325;603645793;1459091613;-89353942;-1032688516;-1615894428;-767185823;-1946032362;931360128;-836341533;-1238311242;26872554;-1198342849;223875202;1787898723;1347039535;1426899535;712166878;1007370589;-2121265931;1279068215;1048275580;665564878;-854576448;1115606454;-1938871068;437377701;1893989311;60057612;-1411480578;-1802660403;-1229197402;-1114162509;1246510289;-100045555;-771237462;-321537560;1645429527;876081854;-344012824;613155858;-58817405;150811542;-10210852;2112860797;-528954460;-50850354;-649972970;1499955930;1421666445;1351215729;-1262602010;-980699257;1941355339;-961944897;-413046848;-411502877;522743470;-1432644237;-1120760559;-776500101;-1809149014;2127519490;470896056;662683123;-567303983;121758873;-1581863489;-91906121;-996490915;1435662432;1657906168;-1808273636;-1008367748;1370467542;775127407;336430775;908983458;-1287820551;2018562582;684733517;1364159782;839309547;1634308483;-497817377;118348535;-1269053010;955697418;-461911650;286131813;-300370221;1037538534;2023161463;-259022712;-1784489335;970316778;1578200481;500283714;1165730615;1099858613;850929875;-122366113;1415506233;-119359212;-2033313111;2063284557;168272506;1014246244;1972611072;1049837341;2120277277;-1358473916;867839429;1548671628;375995816;335745466;-92761852;-1313606594;983851877;957484913;-786771928;1174167013;457619777;1577173252;29408666;-1853196004;-954511750;-9741238;1764765760;-1106091459;418868525;1218646124;244543749;1280742435;-1669454769;1391623016;-1782787888;1672996012;-660347923;1734104018;-70130822;-1181208948;-285723476;-1959961034;42073851;-1354695576;-548612189;-692983842;1398992433;-1954474622;-414265610;1827986420;-1740813210;392408431;812967600;306150025;1150550306;-1577525793;522329421;-1905599679;1183746118;1873227418;113271279;-118624832;2064640613;91279896;-1296994070;923686864;-1237563925;-671532219;432504743;376157897;-1964026811;-509307951;-1291095292;-92298376;-440266966;742491999;-363297213;907719292;-2097711796;-72292200;797405338;-902353499;-166246906;-943459407;-1618209704;296966888;276718739;881687730;-63517562;-481360418;-1200473828;-144528583;2055425204;425514158;-972984629;-437772543;955225817;-1571664087;1255280381;-1520917476;411210494;-1044569805;1196139168;1000345811;314304961;788619297;-1721237341;1855193732;-688848034;-560160224;110451616;205166806;1045130054;606457223;-106064310;-350539693;-1199925658;-1553567608;1827860289;-495518821;-289479856;-1888403873;66174658;-1741606928;-1734480553;1792669379;2112354548;649961546;-1072485902;1950021075;-145032130;-1448841129;-455451267;-1966366114;-1298920795;837046384;-1783493271;1554055716;544335337;-302006934;-149606522;2022999324;826072250;-549276476;1862748770;1989186214;1089115433;956552701;1745621701;-2034815611;614102796;1479888671;-146686913;-690079684;-1114868597;-2016690506;2090920277;-830594320;-1261017876;2072821639;194345641;-1605828714;484660319;-454560202;1794417171;511341824;-1255389158;-669363423;1164033229;-1107097310;828519990;1450362036;476068860;1972265003;-1879752310;1894610209;-2128722743;1301770305;-1624467838;-731973801;-337476939;-1809040191;1525193216;-2001741915;-2027225998;-1162995606;-717541281;2050620663;-1135005089;2015601957;-1661832271;334966618;-236871560;-2075212969;-2141684690;1078043241;1723366617;828122061;147352703;-1999649046;-903143402;-1024430520;1633016716;-1604804280;1647853874;1626223577;613437415;854959232;-1237163556;-230090669;-278438371;1723117265;500023237;-1216412905;1717506101;1373064296;1994723034;1814828511;2067592941;937637146;-1370177392;-1274587966;-48108349;-378201671;1262614325;62390688;164974972;-830307263;-1714046089;1359544797;2016161042;83584009;930716322;-497279679;2023049077;-206104661;1501245447;562523072;104611198;-46372430;298890283;2110698786;-1091302072;20052267;-1304541777;140132249;-1245355586;-727077616;-316829592;152731111;-154344094;1345278005;-558417490;1281066959;-1469762051;-383552934;199222085;413618054;1552260824;-576003758;105415137;2042323739;1646910169;1084993049;840296744;216680633;1409468883;-1555896089;734078106;};
mti=115;
};
};
BaseSpec_Group @.gp[0] {
name="LeabraPrjns";
el_typ=LeabraUnitSpec;
el_def=0;
FullPrjnSpec @[0] {
name="FullPrjnSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=FullPrjnSpec;
el_def=0;
};
self_con=1;
init_wts=0;
};
OneToOnePrjnSpec @[1] {
name="OneToOne";
desc=;
unique{ self_con;};
children {
name=;
el_typ=OneToOnePrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
n_conns=-1;
recv_start=0;
send_start=0;
};
TesselPrjnSpec @[2] {
name="Striatum_GPext";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
TesselPrjnSpec @[0] {
name="PFC_Act_Deep";
desc=;
unique{ send_scale;};
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=0: };
send_border {x=1: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[12] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[13] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[14] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[15] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[16] {
send_off {x=1: y=8: };
wt_val=1;
};
TessEl @[17] {
send_off {x=1: y=8: };
wt_val=1;
};
};
};
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=1: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[12] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[13] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[14] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[15] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[16] {
send_off {x=1: y=8: };
wt_val=1;
};
TessEl @[17] {
send_off {x=1: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[3] {
name="dMatrosomesGP";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=0;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[5] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=6: };
wt_val=1;
};
TessEl @[7] {
send_off {x=0: y=7: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[4] {
name="SNc_GO";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=2: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
};
};
TesselPrjnSpec @[5] {
name="MotorCortex_Striatum";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
};
};
TesselPrjnSpec @[6] {
name="SNc_NOGO";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=2: y=0: };
recv_n {x=2: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
};
};
TesselPrjnSpec @[7] {
name="Striatum_GPInt";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=5: };
wrap=0;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[5] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=6: };
wt_val=1;
};
TessEl @[7] {
send_off {x=0: y=7: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[8] {
name="MotorCortex_NoGoStriatum";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=2: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
};
};
OneToOnePrjnSpec @[9] {
name="OneToOne_2";
desc=;
unique{ self_con;};
children {
name=;
el_typ=OneToOnePrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
n_conns=-1;
recv_start=0;
send_start=2;
};
};
BaseSpec_Group @.gp[1] {
name="Connections";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraBiasSpec @[0] {
name="LearnBias";
desc=;
unique{ rnd;wt_limits;wt_scale;wt_scale_init;};
children {
name=;
el_typ=LeabraBiasSpec;
el_def=0;
LeabraBiasSpec @[0] {
name="FixedBias";
desc=;
unique{ lrate;wt_limits;wt_scale;wt_scale_init;};
children {
name=;
el_typ=LeabraBiasSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
wt_limits {type=NONE: min=-1: max=5: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0: err=1: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
dwt_thresh=0.1;
};
};
rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
wt_limits {type=NONE: min=-1: max=5: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.01;
cur_lrate=0.01;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0: err=1: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
dwt_thresh=0.1;
};
LeabraConSpec @[1] {
name="FixedFull";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=3: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[2] {
name="GPeGPiInhib";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
LeabraConSpec @[0] {
name="ThalInhib";
desc=;
unique{ wt_scale;wt_sig;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=1: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[1] {
name="Inhib_Learn";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.35: var=0.1: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=8: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=1e-05;
cur_lrate=1e-05;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=1.75: rel=1.5: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[3] {
name="Fixed";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
LeabraConSpec @[0] {
name="STNcons";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.21: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=0.7: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[1] {
name="MotorCortex_Striatum";
desc=;
unique{ rnd;wt_limits;wt_scale;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.06: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=0;
wt_scale {abs=1: rel=1.5: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[2] {
name="Motor_NoGo";
desc=;
unique{ rnd;wt_limits;wt_scale;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.06: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=0;
wt_scale {abs=1: rel=0.5: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[3] {
name="Input_Motor_Prepotent_";
desc=;
unique{ rnd;wt_scale;lrate;lmix;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.35: var=0.005: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=3: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=1e-06;
cur_lrate=1e-06;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=1: err=0: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[4] {
name="InputStriatum";
desc=;
unique{ rnd;wt_scale;lrate;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.001: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[5] {
name="STN_GPi";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.21: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=0.55: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=1e-04;
cur_lrate=1e-04;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[6] {
name="Mtr_STNcons";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.65: var=0.2: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
rnd {name="": type=UNIFORM: mean=0.1: var=0.01: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.0075;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[4] {
name="Dopamine_D1_";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=0.5: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[5] {
name="SNc_Inhib_D2_";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=1;
wt_scale {abs=0.5: rel=0.75: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[6] {
name="Inhib";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.7: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=3: rel=2.25: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
BaseSpec_Group @.gp[2] {
name="Units";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="FixedBiasUnitSpec";
desc=;
unique{ opt_thresh;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="GPExt_UnitSpec";
desc=;
unique{ bias_spec;act;opt_thresh;v_m_init;dt;g_bar;e_rev;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[0]$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.26: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=2.5: h=0.1: a=0.5: };
e_rev {e=1: l=0.255: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="OutputUnitSpec";
desc=;
unique{ bias_spec;act;opt_thresh;g_bar;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.2: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[2] {
name="Thalamus";
desc=;
unique{ bias_spec;opt_thresh;dt;g_bar;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.4: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=0.5: l=0.07: i=1.7: h=0.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[3] {
name="LearnBiasUnitSpec";
desc=;
unique{ bias_spec;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="matrisom_unitspec";
desc=;
unique{ bias_spec;act;opt_thresh;g_bar;act_reg;noise_type;noise;dt;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.26: gain=2500: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.5: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=1: min=0.001: max=0.35: wt_dt=0.1: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=VM_NOISE;
noise {name="": type=GAUSSIAN: mean=0.001: var=0: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="Motor_Cortex_unitspec";
desc=;
unique{ bias_spec;opt_thresh;dt;acc;noise_type;noise;noise_sched;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.005: b_dec_dt=0.01: a_thr=0.25: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=VM_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.0015: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
SchedItem @[0] {
start_ctr=0;
start_val=1;
duration=25;
step=0;
};
SchedItem @[1] {
start_ctr=25;
start_val=1;
duration=55;
step=-0.009090909;
};
SchedItem @[2] {
start_ctr=80;
start_val=0.5;
duration=20;
step=-0.015;
};
SchedItem @[3] {
start_ctr=100;
start_val=0.2;
duration=1;
step=1;
};
};
};
LeabraUnitSpec @[2] {
name="STN_unitspec";
desc=;
unique{ bias_spec;act;opt_thresh;v_m_init;dt;g_bar;e_rev;noise_type;noise;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.25: var=0: par=1: };
dt {vm=0.045: net=0.17: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.2: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0]$148$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[4] {
name="GPInt_UnitSpec";
desc=;
unique{ bias_spec;opt_thresh;v_m_init;dt;g_bar;e_rev;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.26: var=0: par=1: };
dt {vm=0.2: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=3: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.275: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="SNc_UnitSpec";
desc=;
unique{ opt_thresh;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$147$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=100: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.95: net=1: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NETIN_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.002: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
BaseSpec_Group @.gp[3] {
name="LayerSpecs";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="LayerSpec_0";
desc=;
unique{ kwta;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="Matrisome_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;clamp;decay;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="GP_layerspec";
desc=;
unique{ kwta;compute_i;i_kwta_pt;clamp;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=0: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[2] {
name="Thalamus_layerspec";
desc=;
unique{ kwta;compute_i;decay;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[3] {
name="Output_layerspec";
desc=;
unique{ kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[4] {
name="PFC_Out_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=LAY_AND_GPS;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[5] {
name="InputLayer";
desc=;
unique{ kwta;compute_i;i_kwta_pt;clamp;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.25;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[6] {
name="SNc_layerspec";
desc=;
unique{ kwta;compute_i;clamp;inhib;decay;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=0: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="NoDecayLayers";
desc=;
unique{ };
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="STN";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="PFCIn_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=LAY_AND_GPS;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=5: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.25;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
};
layers {
name=;
el_typ=LeabraLayer;
el_def=0;
pos {x=0: y=0: z=0: };
LeabraLayer @[0] {
name="Input";
flags=;
layer_type=INPUT;
pos {x=1: y=0: z=2: };
un_geom {x=5: y=5: n_not_xy=0: n=25: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=5: y=5: n_not_xy=0: n=25: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[6].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=5: y=5: n_not_xy=0: n=25: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0]$149$: };
ext_flag=EXT;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0.38: max=0.95: max_i=0: };
acts_p {avg=0.38: max=0.95: max_i=1: };
acts_m {avg=0.38: max=0.95: max_i=1: };
phase_dif_ratio=1;
kwta {k=1: pct=0.04: pct_c=0.96: adth_k=1: k_ithr=-0.1: k1_ithr=-0.1: ithr_r=0: ithr_diff=-0: tie_brk=0: };
i_val {kwta=0: g_i=0.25: gp_g_i=0: g_i_orig=0.25: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.04: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[5]$150$: };
stm_gain=0.5;
hard_clamped=1;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[1] {
name="Striatum";
flags=;
layer_type=HIDDEN;
pos {x=1: y=0: z=1: };
un_geom {x=4: y=9: n_not_xy=0: n=36: };
unit_groups=0;
gp_geom {x=2: y=2: n_not_xy=0: n=4: };
gp_spc {x=0: y=0: };
act_geom {x=4: y=9: n_not_xy=0: n=36: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Input";
from_type=CUSTOM;
from=.projects[0].networks[0].layers[0]$151$;
spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][0]$152$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[4]$153$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_SNc";
from_type=CUSTOM;
from=$16$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][4]$154$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][4]$155$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[2] {
name="Fm_SNc";
from_type=CUSTOM;
from=$16$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][6]$156$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][5]$157$: };
recv_idx=2;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[3] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$83$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][8]$158$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[2]$159$: };
recv_idx=3;
send_idx=4;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[4] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$83$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][5]$160$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[1]$161$: };
recv_idx=4;
send_idx=5;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[0];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=4: y=9: n_not_xy=0: n=36: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=$102$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="Go-R1";
sse=0;
icon_value=0;
netin {avg=1.510151: max=1.842934: max_i=29: };
i_thrs {avg=9.159199: max=11.39792: max_i=29: };
acts {avg=0.0782505: max=0.7843618: max_i=29: };
acts_p {avg=0.08607803: max=0.7926073: max_i=13: };
acts_m {avg=0.08607803: max=0.7926073: max_i=13: };
phase_dif_ratio=1;
kwta {k=3: pct=0.08333334: pct_c=0.9166667: adth_k=1: k_ithr=11.0303: k1_ithr=10.9997: ithr_r=0.002778362: ithr_diff=0.002774485: tie_brk=0: };
i_val {kwta=11.015: g_i=11.015: gp_g_i=0: g_i_orig=11.015: };
un_g_i {avg=11.01501: max=11.015: max_i=0: };
adapt_i {avg_avg=0.08333334: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[0]$162$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[2] {
name="SNc";
flags=;
layer_type=INPUT;
pos {x=2: y=0: z=0: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[1].projections[2];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][1]$163$: };
ext_flag=EXT;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0.01537416: max=0.01731166: max_i=3: };
i_thrs {avg=0.01530618: max=0.02983745: max_i=3: };
acts {avg=0.647215: max=0.6955121: max_i=3: };
acts_p {avg=0.6431079: max=0.6897681: max_i=1: };
acts_m {avg=0.6431079: max=0.6897681: max_i=1: };
phase_dif_ratio=1;
kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=0: };
adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[6]$164$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[3] {
name="GP_Int";
flags=;
layer_type=HIDDEN;
pos {x=6: y=0: z=0: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Striatum";
from_type=CUSTOM;
from=$17$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][7]$165$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2].children[1]$166$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_GP_Ext";
from_type=CUSTOM;
from=$86$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][2]$167$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2]$168$: };
recv_idx=1;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[2] {
name="Fm_STN";
from_type=CUSTOM;
from=$82$;
spec {type=FullPrjnSpec: spec=$152$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[5]$169$: };
recv_idx=2;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[5].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[4]$170$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R2";
sse=0;
icon_value=0;
netin {avg=0.07113075: max=0.0855621: max_i=2: };
i_thrs {avg=1.283481: max=1.391716: max_i=2: };
acts {avg=0.4611043: max=0.9236104: max_i=2: };
acts_p {avg=0.4150822: max=0.8454967: max_i=2: };
acts_m {avg=0.4150822: max=0.8454967: max_i=2: };
phase_dif_ratio=1;
kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=1.09251: k1_ithr=1.09251: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=1.14268: max=1.78849: max_i=3: };
adapt_i {avg_avg=0.25: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=3: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[1]$171$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[4] {
name="GP_Ext";
flags=;
layer_type=HIDDEN;
pos {x=6: y=4: z=0: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Striatum";
from_type=CUSTOM;
from=$17$;
spec {type=TesselPrjnSpec: spec=$167$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][6]$172$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_STN";
from_type=CUSTOM;
from=$82$;
spec {type=UniformRndPrjnSpec: spec=.projects[0].networks[0].specs[1]$173$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[0]$174$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[8].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[0]$175$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=0.1256137: max=0.1608976: max_i=1: };
i_thrs {avg=0.9921025: max=1.256732: max_i=1: };
acts {avg=0.9708879: max=0.9711923: max_i=1: };
acts_p {avg=0.9079125: max=0.9562136: max_i=0: };
acts_m {avg=0.9079125: max=0.9562136: max_i=0: };
phase_dif_ratio=1;
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0.0999999: k1_ithr=0.0999999: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0.06431491: max=0.1286298: max_i=1: };
adapt_i {avg_avg=0.5: i_kwta_pt=0.5: g_bar_i=2.5: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=$171$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[5] {
name="Thalamus";
flags=;
layer_type=HIDDEN;
pos {x=12: y=0: z=1: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_GP_Int";
from_type=CUSTOM;
from=$85$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][3]$176$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2].children[0]$177$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$83$;
spec {type=TesselPrjnSpec: spec=$176$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][1]$178$: };
recv_idx=1;
send_idx=3;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[6].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[2]$179$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=0.1785989: max=0.3571934: max_i=1: };
i_thrs {avg=1.269492: max=2.60895: max_i=1: };
acts {avg=0.4922692: max=0.9845384: max_i=1: };
acts_p {avg=0.4962071: max=0.9924142: max_i=1: };
acts_m {avg=0.4962071: max=0.9924142: max_i=1: };
phase_dif_ratio=1;
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0.979331: k1_ithr=0.746659: ithr_r=0.271261: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0.3659378: max=0.7309765: max_i=0: };
adapt_i {avg_avg=0.5: i_kwta_pt=0.6: g_bar_i=1.7: g_bar_l=0.07: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[2]$180$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[6] {
name="Motor_Cortex";
flags=NO_ADD_SSE|NO_ADD_COMP_SSE;
layer_type=TARGET;
pos {x=10: y=0: z=2: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Thalamus";
from_type=CUSTOM;
from=$84$;
spec {type=TesselPrjnSpec: spec=$176$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$178$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Input";
from_type=CUSTOM;
from=$151$;
spec {type=FullPrjnSpec: spec=$152$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[3]$181$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[5].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[7].projections[0];
Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[7].projections[1];
Projection_Group @. = [3] = LeabraPrjn .projects[0].networks[0].layers[8].projections[0];
Projection_Group @. = [4] = LeabraPrjn .projects[0].networks[0].layers[1].projections[3];
Projection_Group @. = [5] = LeabraPrjn .projects[0].networks[0].layers[1].projections[4];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[3].children[1]$182$: };
ext_flag=TARG;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=2.868245: max=3.241691: max_i=1: };
i_thrs {avg=21.41184: max=24.21268: max_i=1: };
acts {avg=0.4489419: max=0.8953166: max_i=3: };
acts_p {avg=0.4449383: max=0.8887834: max_i=3: };
acts_m {avg=0.4449383: max=0.8887834: max_i=3: };
phase_dif_ratio=1;
kwta {k=3: pct=0.75: pct_c=0.25: adth_k=1: k_ithr=22.35889: k1_ithr=18.57069: ithr_r=0.1856392: ithr_diff=0.1694268: tie_brk=0: };
i_val {kwta=20.84361: g_i=20.84361: gp_g_i=0: g_i_orig=20.84361: };
un_g_i {avg=20.84361: max=20.84361: max_i=0: };
adapt_i {avg_avg=0.75: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0]$183$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[7] {
name="Output";
flags=;
layer_type=TARGET;
pos {x=8: y=6: z=2: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$83$;
spec {type=TesselPrjnSpec: spec=$165$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$178$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$83$;
spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[0][9]$184$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$178$: };
recv_idx=1;
send_idx=2;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[1]$185$: };
ext_flag=TARG;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=1.984406;
icon_value=0;
netin {avg=0.223297: max=0.4465939: max_i=1: };
i_thrs {avg=2.572752: max=6.145503: max_i=1: };
acts {avg=0.4959215: max=0.991843: max_i=1: };
acts_p {avg=0.4960862: max=0.9921724: max_i=1: };
acts_m {avg=0.4960862: max=0.9921724: max_i=1: };
phase_dif_ratio=1;
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=6.145503: k1_ithr=-1: ithr_r=0: ithr_diff=1.162721: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=0: };
adapt_i {avg_avg=0.5: i_kwta_pt=0: g_bar_i=1: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[3]$186$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[8] {
name="STN";
flags=;
layer_type=HIDDEN;
pos {x=7: y=1: z=1: };
un_geom {x=3: y=3: n_not_xy=0: n=9: };
unit_groups=0;
gp_geom {x=2: y=1: n_not_xy=0: n=2: };
gp_spc {x=0: y=0: };
act_geom {x=3: y=3: n_not_xy=0: n=9: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$83$;
spec {type=FullPrjnSpec: spec=$152$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[6]$187$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_GP_Ext";
from_type=CUSTOM;
from=$86$;
spec {type=UniformRndPrjnSpec: spec=.projects[0].networks[0].specs[2]$188$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$172$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[2];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=3: y=3: n_not_xy=0: n=9: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[3].children[2]$189$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0.1796961: max=0.2133077: max_i=3: };
i_thrs {avg=0.8477212: max=1.099808: max_i=3: };
acts {avg=0.2072951: max=0.8850191: max_i=3: };
acts_p {avg=0.0886254: max=0.5460718: max_i=3: };
acts_m {avg=0.0886254: max=0.5460718: max_i=3: };
phase_dif_ratio=1;
kwta {k=2: pct=0.2222222: pct_c=0.7777778: adth_k=1: k_ithr=1.60686: k1_ithr=1.38061: ithr_r=0.151759: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=1.017167: max=1.059605: max_i=0: };
adapt_i {avg_avg=0.2222222: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][1].children[0]$190$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
};
view_objs {
name=;
el_typ=NetViewObj;
el_def=0;
};
flags=;
auto_build=AUTO_BUILD;
train_mode=TEST;
wt_update=ON_LINE;
small_batch_n=10;
batch=0;
epoch=0;
group=0;
trial=0;
tick=0;
cycle=77;
time=0;
group_name=;
trial_name="1100_09_889";
output_name=;
sse_unit_avg=0;
sse_sqrt=0;
sse=0;
sum_sse=0;
avg_sse=0;
cnt_err_tol=0.4;
cnt_err=0;
cur_sum_sse=0;
avg_sse_n=0;
cur_cnt_err=0;
train_time {name="train_time": start={usr=1455: sys=43: tot=723144884: }: end={usr=826668: sys=208224: tot=722144431: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
epoch_time {name="epoch_time": start={usr=1458: sys=43: tot=723144888: }: end={usr=826668: sys=208224: tot=722144431: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
dmem_sync_level=DMEM_SYNC_NETWORK;
dmem_nprocs=1;
usr1_save_fmt=FULL_NET;
wt_save_fmt=TEXT;
lay_layout=THREE_D;
n_units=88;
n_cons=1427;
max_size {x=14: y=9: z=3: };
font_sizes {
net_name=0.05;
net_vals=0.05;
layer=0.04;
layer_vals=0.03;
prjn=0.01;
unit=0.02;
un_nm_len=3;
};
view_params {
xy_square=0;
unit_spacing=0.05;
prjn_disp=L_R_F;
prjn_name=0;
prjn_width=0.002;
prjn_trans=0.5;
lay_trans=0.5;
unit_trans=0.6;
};
phase_order=MINUS_PLUS;
no_plus_test=1;
trial_init=DECAY_STATE;
sequence_init=DO_NOTHING;
first_plus_dwt=ONLY_FIRST_DWT;
phase=MINUS_PHASE;
nothing_phase=0;
phase_no=0;
phase_max=1;
cycle_max=100;
min_cycles=15;
min_cycles_phase2=35;
minus_cycles=0;
avg_cycles=0;
avg_cycles_sum=0;
avg_cycles_n=0;
netin_mod=1;
send_delta=0;
send_pct=0.3174603;
send_pct_n=20;
send_pct_tot=63;
avg_send_pct=0;
avg_send_pct_sum=28.28574;
avg_send_pct_n=78;
maxda_stopcrit=0.005;
maxda=0.04341922;
trg_max_act_stopcrit=1;
trg_max_act=0.991843;
ext_rew=0;
avg_ext_rew=0;
avg_ext_rew_sum=0;
avg_ext_rew_n=0;
};
};
};
