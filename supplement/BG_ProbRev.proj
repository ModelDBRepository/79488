// ta_Dump File v2.0
LeabraProject .projects[0] { 
Doc_Group @.docs = [1] {
taDoc @[0] { };
};

Wizard_Group @.wizards = [1] {
LeabraWizard @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};

LayerWizElList @.layer_cfg = [3] {
LayerWizEl @[0] { };
LayerWizEl @[1] { };
LayerWizEl @[2] { };
};
};
};

SelectEdit_Group @.edits = [1] {
SelectEdit @[0] { 
EditMbrItem_Group @.mbrs = [7] {
EditMbrItem @[0] { };
EditMbrItem @[1] { };
EditMbrItem @[2] { };
EditMbrItem @[3] { };
EditMbrItem @[4] { };
EditMbrItem @[5] { };
EditMbrItem @[6] { };
};
};
};

DataTable_Group @.data = [0] {
DataTable_Group @.gp[0] = [4] { 
DataTable @[0] { 
DataTableCols @.data = [5] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
};
};
DataTable @[1] { 
DataTableCols @.data = [5] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
};
};
DataTable @[2] { 
DataTableCols @.data = [5] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
};
};
DataTable @[3] { 
DataTableCols @.data = [5] {
String_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
};
};
};
DataTable_Group @.gp[1] = [3] { 
DataTable @[0] { 
DataTableCols @.data = [10] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
String_Data @[3] { };
String_Data @[4] { };
int_Data @[5] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[6] { };
float_Data @[7] { };
float_Data @[8] { };
float_Data @[9] { };
};
};
DataTable @[1] { 
DataTableCols @.data = [6] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[2] { };
float_Data @[3] { };
float_Data @[4] { };
float_Data @[5] { };
};
};
DataTable @[2] { 
DataTableCols @.data = [16] {
int_Data @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
String_Data @[3] { };
String_Data @[4] { };
int_Data @[5] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
int_Data @[6] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
float_Data @[7] { };
float_Data @[8] { };
float_Data @[9] { };
float_Data @[10] { };
float_Data @[11] { };
float_Data @[12] { };
float_Data @[13] { };
float_Data @[14] { };
float_Data @[15] { };
};
};
};
DataTable_Group @.gp[2] = [1] { 
DataTable @[0] { 
DataTableCols @.data = [3] {
int_Data @[0] { };
float_Data @[1] { };
float_Data @[2] { };
};
};
};
};

taBase_Group @.data_proc = [4] {
taDataProc @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taDataAnal @[1] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taDataGen @[2] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
taImageProc @[3] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};

Program_Group @.programs = [1] {
Program @[0] { 
ProgVar_List @.args = [8] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
};

ProgVar_List @.vars = [6] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
};

ProgEl_List @.init_code = [1] {
IfReturn @[0] { };
};

ProgEl_List @.prog_code = [28] {
IfReturn @[0] { };
Comment @[1] { };
MiscCall @[2] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[3] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[4] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[5] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[6] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[7] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[8] { };
RegisterArgs @[9] { };
Comment @[10] { };
PrintExpr @[11] { };
ProgVarFmArg @[12] { };
MethodCall @[13] { };
MiscCall @[14] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MiscCall @[15] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
ProgVarFmArg @[16] { };
ProgVarFmArg @[17] { };
ProgVarFmArg @[18] { };
ProgVarFmArg @[19] { };
Comment @[20] { };
MethodCall @[21] { 
ProgArg_List @.meth_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
MethodCall @[22] { 
ProgArg_List @.meth_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
MethodCall @[23] { 
ProgArg_List @.meth_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
MethodCall @[24] { 
ProgArg_List @.meth_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
OtherProgramVar @[25] { };
PrintExpr @[26] { };
ProgramCall @[27] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program_Group @.gp[0] = [17] { 
Program @[0] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [6] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
};

ProgEl_List @.init_code = [2] {
NetCounterInit @[0] { };
IfElse @[1] { 
ProgEl_List @.true_code = [2] {
AssignExpr @[0] { };
OtherProgramVar @[1] { };
};

ProgEl_List @.false_code = [2] {
AssignExpr @[0] { };
OtherProgramVar @[1] { };
};
};
};

ProgEl_List @.prog_code = [3] {
NetCounterInit @[0] { };
WhileLoop @[1] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [3] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
};
};
NetCounterIncr @[1] { };
};
};
DataCalcLoop @[2] { 
DataOpList @.src_cols = [6] {
DataOpEl @[0] { };
DataOpEl @[1] { };
DataOpEl @[2] { };
DataOpEl @[3] { };
DataOpEl @[4] { };
DataOpEl @[5] { };
};

ProgEl_List @.loop_code = [1] {
DataGroupProg @[0] { 
DataOpList @.ops = [3] {
DataGroupEl @[0] { };
DataGroupEl @[1] { };
DataGroupEl @[2] { };
};
};
};

ProgVar_List @.src_col_vars = [6] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
};
};
};
};
Program @[1] { 
ProgObjList @.objs = [1] {
RndSeed @[0] { };
};

ProgType_List @.types = [1] {
DynEnumType @[0] { 
DynEnumItem_List @.enums = [2] {
DynEnumItem @[0] { };
DynEnumItem @[1] { };
};
};
};

ProgVar_List @.args = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgVar_List @.vars = [20] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
ProgVar @[15] { };
ProgVar @[16] { };
ProgVar @[17] { };
ProgVar @[18] { };
ProgVar @[19] { };
};

ProgEl_List @.init_code = [6] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
AssignExpr @[2] { };
NetCounterInit @[3] { };
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};

ProgEl_List @.false_code = [1] {
MethodCall @[0] { };
};
};
IfGuiPrompt @[5] { 
ProgEl_List @.yes_code = [2] {
MethodCall @[0] { };
PrintExpr @[1] { };
};
};
};

ProgEl_List @.prog_code = [14] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
NetCounterInit @[2] { };
MemberAssign @[3] { };
MemberAssign @[4] { };
IfElse @[5] { 
ProgEl_List @.true_code = [2] {
MethodCall @[0] { };
PrintExpr @[1] { };
};
};
AssignExpr @[6] { };
ForLoop @[7] { 
ProgEl_List @.loop_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
UserScript @[0] { };
};
};
};
};
OtherProgramVar @[8] { };
OtherProgramVar @[9] { };
MemberAssign @[10] { };
ProgramCall @[11] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
WhileLoop @[12] { 
ProgEl_List @.loop_code = [6] {
MemberAssign @[0] { };
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};

ProgEl_List @.false_code = [1] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
NetCounterIncr @[2] { };
IfBreak @[3] { };
MemberAssign @[4] { };
IfElse @[5] { 
ProgEl_List @.true_code = [1] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};

ProgEl_List @.false_code = [1] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
};
};
MethodCall @[13] { };
};
};
Program @[2] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [5] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
};

ProgEl_List @.init_code = [2] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
};

ProgEl_List @.prog_code = [9] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[3] { };
NetDataLoop @[4] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
};
};
IfElse @[5] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
MethodCall @[6] { };
ProgramCall @[7] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[8] { };
};
};
Program @[3] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [12] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
};

ProgEl_List @.init_code = [4] {
NetCounterInit @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
AssignExpr @[3] { };
};

ProgEl_List @.prog_code = [12] {
IfElse @[0] { 
ProgEl_List @.true_code = [1] {
MemberAssign @[0] { };
};

ProgEl_List @.false_code = [1] {
MemberAssign @[0] { };
};
};
NetCounterInit @[1] { };
AssignExpr @[2] { };
AssignExpr @[3] { };
AssignExpr @[4] { };
MethodCall @[5] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[6] { };
NetDataLoop @[7] { 
ProgEl_List @.loop_code = [2] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[1] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
};
};
IfElse @[8] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
MethodCall @[9] { };
ProgramCall @[10] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[11] { };
};
};
Program @[4] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [6] {
NetCounterInit @[0] { };
MethodCall @[1] { };
WhileLoop @[2] { 
ProgEl_List @.loop_code = [4] {
UserScript @[0] { };
ProgramCall @[1] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[2] { };
MethodCall @[3] { };
};
};
MethodCall @[3] { };
ProgramCall @[4] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetUpdateView @[5] { };
};
};
Program @[5] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [6] {
NetCounterInit @[0] { };
MethodCall @[1] { };
WhileLoop @[2] { 
ProgEl_List @.loop_code = [4] {
UserScript @[0] { };
ProgramCall @[1] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
NetCounterIncr @[2] { };
MethodCall @[3] { };
};
};
MethodCall @[3] { };
ProgramCall @[4] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetUpdateView @[5] { };
};
};
Program @[6] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [4] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [12] {
NetCounterInit @[0] { };
MethodCall @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
ProgramCall @[3] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MemberAssign @[0] { };
};

ProgEl_List @.false_code = [1] {
MemberAssign @[0] { };
};
};
MethodCall @[5] { };
IfElse @[6] { 
ProgEl_List @.true_code = [1] {
AssignExpr @[0] { };
};

ProgEl_List @.false_code = [1] {
AssignExpr @[0] { };
};
};
WhileLoop @[7] { 
ProgEl_List @.loop_code = [4] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetCounterIncr @[1] { };
IfContinue @[2] { };
IfBreak @[3] { };
};
};
MethodCall @[8] { };
IfElse @[9] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
IfElse @[10] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
NetUpdateView @[11] { };
};
};
Program @[7] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgEl_List @.init_code = [1] {
NetCounterInit @[0] { };
};

ProgEl_List @.prog_code = [12] {
NetCounterInit @[0] { };
MethodCall @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
ProgramCall @[3] { 
ProgArg_List @.prog_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
IfElse @[4] { 
ProgEl_List @.true_code = [1] {
MemberAssign @[0] { };
};

ProgEl_List @.false_code = [1] {
MemberAssign @[0] { };
};
};
MethodCall @[5] { };
IfElse @[6] { 
ProgEl_List @.true_code = [1] {
AssignExpr @[0] { };
};

ProgEl_List @.false_code = [1] {
AssignExpr @[0] { };
};
};
WhileLoop @[7] { 
ProgEl_List @.loop_code = [4] {
ProgramCall @[0] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
NetCounterIncr @[1] { };
IfContinue @[2] { };
IfBreak @[3] { };
};
};
MethodCall @[8] { };
IfElse @[9] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
IfElse @[10] { 
ProgEl_List @.true_code = [1] {
MethodCall @[0] { };
};
};
NetUpdateView @[11] { };
};
};
Program @[8] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.prog_code = [3] {
MethodCall @[0] { };
NetUpdateView @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
};
};
Program @[9] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.prog_code = [3] {
MethodCall @[0] { };
NetUpdateView @[1] { };
ProgramCall @[2] { 
ProgArg_List @.prog_args = [1] {
ProgArg @[0] { };
};
};
};
};
Program @[10] { 
ProgObjList @.objs = [1] {
LayerWriter @[0] { 
LayerDataEl_List @.layer_data = [5] {
LayerWriterEl @[0] { };
LayerWriterEl @[1] { };
LayerWriterEl @[2] { };
LayerWriterEl @[3] { };
LayerWriterEl @[4] { };
};
};
};

ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.init_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { };
};
};
Program @[11] { 
ProgObjList @.objs = [1] {
LayerWriter @[0] { 
LayerDataEl_List @.layer_data = [5] {
LayerWriterEl @[0] { };
LayerWriterEl @[1] { };
LayerWriterEl @[2] { };
LayerWriterEl @[3] { };
LayerWriterEl @[4] { };
};
};
};

ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [1] {
ProgVar @[0] { };
};

ProgEl_List @.init_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [2] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { };
};
};
Program @[12] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [10] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
NetMonItem @[6] { };
NetMonItem @[7] { };
NetMonItem @[8] { };
NetMonItem @[9] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [3] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [4] {
MethodCall @[0] { };
MethodCall @[1] { };
MethodCall @[2] { };
MethodCall @[3] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[13] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [16] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
NetMonItem @[6] { };
NetMonItem @[7] { };
NetMonItem @[8] { };
NetMonItem @[9] { };
NetMonItem @[10] { };
NetMonItem @[11] { };
NetMonItem @[12] { };
NetMonItem @[13] { };
NetMonItem @[14] { };
NetMonItem @[15] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgEl_List @.init_code = [3] {
MethodCall @[0] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[1] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [5] {
IfReturn @[0] { };
MethodCall @[1] { };
MethodCall @[2] { };
MethodCall @[3] { };
MethodCall @[4] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[14] { 
ProgObjList @.objs = [1] {
NetMonitor @[0] { 
NetMonItem_List @.items = [6] {
NetMonItem @[0] { };
NetMonItem @[1] { };
NetMonItem @[2] { };
NetMonItem @[3] { };
NetMonItem @[4] { };
NetMonItem @[5] { };
};
};
};

ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [3] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
};

ProgEl_List @.init_code = [4] {
AssignExpr @[0] { };
MethodCall @[1] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MethodCall @[2] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
MethodCall @[3] { 
ProgArg_List @.meth_args = [1] {
ProgArg @[0] { };
};
};
};

ProgEl_List @.prog_code = [4] {
MethodCall @[0] { };
MethodCall @[1] { };
AssignExpr @[2] { };
MethodCall @[3] { };
};
};
Program @[15] { 
ProgVar_List @.args = [1] {
ProgVar @[0] { };
};

ProgVar_List @.vars = [6] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
};

ProgEl_List @.prog_code = [6] {
IfReturn @[0] { };
MiscCall @[1] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
MiscCall @[2] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
AssignExpr @[3] { };
MethodCall @[4] { 
ProgArg_List @.meth_args = [4] {
ProgArg @[0] { };
ProgArg @[1] { };
ProgArg @[2] { };
ProgArg @[3] { };
};
};
MethodCall @[5] { 
ProgArg_List @.meth_args = [2] {
ProgArg @[0] { };
ProgArg @[1] { };
};
};
};
};
Program @[16] { 
ProgVar_List @.args = [2] {
ProgVar @[0] { };
ProgVar @[1] { };
};

ProgVar_List @.vars = [15] {
ProgVar @[0] { };
ProgVar @[1] { };
ProgVar @[2] { };
ProgVar @[3] { };
ProgVar @[4] { };
ProgVar @[5] { };
ProgVar @[6] { };
ProgVar @[7] { };
ProgVar @[8] { };
ProgVar @[9] { };
ProgVar @[10] { };
ProgVar @[11] { };
ProgVar @[12] { };
ProgVar @[13] { };
ProgVar @[14] { };
};

ProgEl_List @.prog_code = [4] {
AssignExpr @[0] { };
AssignExpr @[1] { };
AssignExpr @[2] { };
IfElse @[3] { 
ProgEl_List @.true_code = [4] {
IfElse @[0] { 
ProgEl_List @.true_code = [2] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
MemberAssign @[0] { };
};
};
MemberAssign @[1] { };
};

ProgEl_List @.false_code = [2] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [1] {
MemberAssign @[0] { };
};
};
MemberAssign @[1] { };
};
};
AssignExpr @[1] { };
AssignExpr @[2] { };
IfElse @[3] { 
ProgEl_List @.true_code = [4] {
MemberAssign @[0] { };
MemberAssign @[1] { };
MemberAssign @[2] { };
MemberAssign @[3] { };
};

ProgEl_List @.false_code = [4] {
MemberAssign @[0] { };
MemberAssign @[1] { };
MemberAssign @[2] { };
MemberAssign @[3] { };
};
};
};

ProgEl_List @.false_code = [1] {
ForLoop @[0] { 
ProgEl_List @.loop_code = [2] {
MemberAssign @[0] { };
MemberAssign @[1] { };
};
};
};
};
};
};
};
};

DataViewer_List @.viewers = [1] {
MainWindowViewer @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
UserDataItem @[1] { };
UserDataItem @[2] { };
UserDataItem @[3] { };
UserDataItem @[4] { };
UserDataItem @[5] { };
};

ToolBar_List @.toolbars = [1] {
ToolBar @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
};
};
};

FrameViewer_List @.frames = [3] {
tabBrowseViewer @[0] { };
PanelViewer @[1] { };
T3DataViewer @[2] { 
T3DataViewFrame_List @.frames = [4] {
T3DataViewFrame @[0] { 
T3DataView_List @.children = [1] {
NetView @[0] { 
ScaleRange_List @.scale_ranges = [22] {
ScaleRange @[0] { };
ScaleRange @[1] { };
ScaleRange @[2] { };
ScaleRange @[3] { };
ScaleRange @[4] { };
ScaleRange @[5] { };
ScaleRange @[6] { };
ScaleRange @[7] { };
ScaleRange @[8] { };
ScaleRange @[9] { };
ScaleRange @[10] { };
ScaleRange @[11] { };
ScaleRange @[12] { };
ScaleRange @[13] { };
ScaleRange @[14] { };
ScaleRange @[15] { };
ScaleRange @[16] { };
ScaleRange @[17] { };
ScaleRange @[18] { };
ScaleRange @[19] { };
ScaleRange @[20] { };
ScaleRange @[21] { };
};
};
};
};
T3DataViewFrame @[1] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [16] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
GraphColView @[6] { };
GraphColView @[7] { };
GraphColView @[8] { };
GraphColView @[9] { };
GraphColView @[10] { };
GraphColView @[11] { };
GraphColView @[12] { };
GraphColView @[13] { };
GraphColView @[14] { };
GraphColView @[15] { };
};
};
};
};
T3DataViewFrame @[2] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [6] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
GraphColView @[3] { };
GraphColView @[4] { };
GraphColView @[5] { };
};
};
};
};
T3DataViewFrame @[3] { 
T3DataView_List @.children = [1] {
GraphTableView @[0] { 
T3DataView_List @.children = [3] {
GraphColView @[0] { };
GraphColView @[1] { };
GraphColView @[2] { };
};
};
};
};
};
};
};

DockViewer_List @.docks = [1] {
ToolBoxDockViewer @[0] { 
UserDataItem_List @*(.user_data_) { 
UserDataItem @[0] { };
UserDataItem @[1] { };
UserDataItem @[2] { };
UserDataItem @[3] { };
UserDataItem @[4] { };
UserDataItem @[5] { };
};
};
};
};
};

Network_Group @.networks = [1] {
LeabraNetwork @[0] { 
BaseSpec_Group @.specs = [3] {
ConSpec @[0] { };
UniformRndPrjnSpec @[1] { };
UniformRndPrjnSpec @[2] { };
BaseSpec_Group @.gp[0] = [10] { 
FullPrjnSpec @[0] { };
OneToOnePrjnSpec @[1] { };
TesselPrjnSpec @[2] { 
BaseSpec_Group @.children = [1] {
TesselPrjnSpec @[0] { 
TessEl_List @.send_offs = [18] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
TessEl @[12] { };
TessEl @[13] { };
TessEl @[14] { };
TessEl @[15] { };
TessEl @[16] { };
TessEl @[17] { };
};
};
};

TessEl_List @.send_offs = [18] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
TessEl @[12] { };
TessEl @[13] { };
TessEl @[14] { };
TessEl @[15] { };
TessEl @[16] { };
TessEl @[17] { };
};
};
TesselPrjnSpec @[3] { 
TessEl_List @.send_offs = [9] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
};
};
TesselPrjnSpec @[4] { 
TessEl_List @.send_offs = [12] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
};
};
TesselPrjnSpec @[5] { 
TessEl_List @.send_offs = [2] {
TessEl @[0] { };
TessEl @[1] { };
};
};
TesselPrjnSpec @[6] { 
TessEl_List @.send_offs = [12] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
TessEl @[9] { };
TessEl @[10] { };
TessEl @[11] { };
};
};
TesselPrjnSpec @[7] { 
TessEl_List @.send_offs = [9] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
TessEl @[4] { };
TessEl @[5] { };
TessEl @[6] { };
TessEl @[7] { };
TessEl @[8] { };
};
};
TesselPrjnSpec @[8] { 
TessEl_List @.send_offs = [4] {
TessEl @[0] { };
TessEl @[1] { };
TessEl @[2] { };
TessEl @[3] { };
};
};
OneToOnePrjnSpec @[9] { };
};
BaseSpec_Group @.gp[1] = [7] { 
LeabraBiasSpec @[0] { 
BaseSpec_Group @.children = [1] {
LeabraBiasSpec @[0] { };
};
};
LeabraConSpec @[1] { };
LeabraConSpec @[2] { 
BaseSpec_Group @.children = [2] {
LeabraConSpec @[0] { };
LeabraConSpec @[1] { };
};
};
LeabraConSpec @[3] { 
BaseSpec_Group @.children = [7] {
LeabraConSpec @[0] { };
LeabraConSpec @[1] { };
LeabraConSpec @[2] { };
LeabraConSpec @[3] { };
LeabraConSpec @[4] { };
LeabraConSpec @[5] { };
LeabraConSpec @[6] { };
};
};
LeabraConSpec @[4] { };
LeabraConSpec @[5] { };
LeabraConSpec @[6] { };
};
BaseSpec_Group @.gp[2] = [2] { 
LeabraUnitSpec @[0] { 
BaseSpec_Group @.children = [5] {
LeabraUnitSpec @[0] { };
LeabraUnitSpec @[1] { };
LeabraUnitSpec @[2] { };
LeabraUnitSpec @[3] { 
BaseSpec_Group @.children = [3] {
LeabraUnitSpec @[0] { };
LeabraUnitSpec @[1] { 
Schedule @.noise_sched = [4] {
SchedItem @[0] { };
SchedItem @[1] { };
SchedItem @[2] { };
SchedItem @[3] { };
};
};
LeabraUnitSpec @[2] { };
};
};
LeabraUnitSpec @[4] { };
};
};
LeabraUnitSpec @[1] { };
};
BaseSpec_Group @.gp[3] = [2] { 
LeabraLayerSpec @[0] { 
BaseSpec_Group @.children = [7] {
LeabraLayerSpec @[0] { };
LeabraLayerSpec @[1] { };
LeabraLayerSpec @[2] { };
LeabraLayerSpec @[3] { };
LeabraLayerSpec @[4] { };
LeabraLayerSpec @[5] { };
LeabraLayerSpec @[6] { };
};
};
LeabraLayerSpec @[1] { 
BaseSpec_Group @.children = [2] {
LeabraLayerSpec @[0] { };
LeabraLayerSpec @[1] { };
};
};
};
};

Layer_Group @.layers = [9] {
LeabraLayer @[0] { 
Unit_Group @.units = [25] {
};
};
LeabraLayer @[1] { 
Projection_Group @.projections = [5] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
LeabraPrjn @[2] { };
LeabraPrjn @[3] { };
LeabraPrjn @[4] { };
};

Unit_Group @.units = [36] {
};
};
LeabraLayer @[2] { 
Unit_Group @.units = [4] {
};
};
LeabraLayer @[3] { 
Projection_Group @.projections = [3] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
LeabraPrjn @[2] { };
};

Unit_Group @.units = [4] {
};
};
LeabraLayer @[4] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[5] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[6] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [4] {
};
};
LeabraLayer @[7] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [2] {
};
};
LeabraLayer @[8] { 
Projection_Group @.projections = [2] {
LeabraPrjn @[0] { };
LeabraPrjn @[1] { };
};

Unit_Group @.units = [9] {
};
};
};
};
};
};
LeabraProject .projects[0] {
name="Project_0";
desc="mtrNoGoGlut: stronger glutamate projns from ctx to NoGo (mGluR!)
nodecMat = no decay b/w phases in matrix, so can learn about recently active synapse";
tags=;
templates {
name=;
el_typ=taBase;
el_def=0;
};
docs {
name=;
el_typ=taDoc;
el_def=0;
taDoc @[0] {
name="ProjectDocs";
auto_open=1;
text="<html>
<head></head>
<body>

= Probabilistic Reversal Learning in the Basal Ganglia: Adverse Medication Effects =


* GENERAL USAGE NOTE: To start, it is usually a good idea to do <code>Object/Edit Dialog</code> in
the menu just above this text, which will open this documentation in a separate window that you can more easily come back to.  If your screen is small, you may also want to make this new window \"Always on Top\": e.g., in Linux, <code>Emergent-logo-at-top-left-></code> <code> Advanced-> Keep Above Others</code>).   Alternatively, you can always return to this document by clicking on the <code>ProjectDocs</code> tab at the top of this middle panel.

This project replicates the effect described in Frank (2005), where simulated DA medications selectively impair probabilistic reversal learning, but not acquisition (as in, e.g., Cools et al, 2001, Cereb Cortex).
These medication effects are due to partial blockade of DA dips needed to learn NoGo and override the prepotent Go response learned during acquisition. This model includes the subthalamic nucleus (not in original Frank '05 paper), and has identical parameters to that described in the weather prediction learning model  and the probabilistic selection Go/NoGo learning model.  

The project is set up to run 40 epochs, and automatically switches from TrainFreq to
Train_Reversal half way through (after 20 epochs). Each stimulus 'cue' in the probabilistic learning task is represented by a column of four units in the Input layer. Stimulus A (first column of units) is rewarded for selecting response 1 on 80% of trials, with negative feedback on the remaining trials, and vice versa for stimulus B. These probabilities are then reversed.

You can monitor performance on the training/reversal environments in the 
[[.T3Tab.EpochOutputData]] graph, counting the number of errors made out of 2 possible in each test epoch.  Networks are tested after every epoch of training on the TestFreq or Test_Reversal input data environments, which simply present the two events and record whether the most optimally correct response was made (ie choosing the 80% stimulus is correct in this test).
  
Note that this test is also administered to the model at the very beginning, prior to any training, as a measure of baseline performance (should be chance on average), and that during this test there is no 'feedback' (DA bursts or dips which would otherwise drive learning).
 
For intact network performance, make sure the number of intact SNc units is set to 4 (out of 4 units), the DA burst value is set to 1 (corresponding to maximal phasic burst firing rate) and the DA dip value is set to 0 (minimum phasic dip DA firing rate). These values are set in the  [[.PanelTab.SelectEdit_1]] control panel.
 

To monitor performance across multiple networks, first save a Data Log file to store the data. Open the <code>data->OutputData subgroup</code> tree in the '''Tree''' window (far left) and click on <code>EpochOutputData</code> to display the data table (which is where the raw data is stored that is then plotted in the graph on the right). Click on <code>Object->Save Data Log</code>). Make sure to name this logfile with some reference to the current dopamine settings, so that you can properly interpret the data (e.g., name this 'Intact_epc.dat').  To run a set of networks on the task, expand the <code> programs</code> tab int the \"Tree\" window on the fat left, and then under <code> LeabraAll_Std_subgrpup</code>, click on the <code.LeabraBatch</code> object. Hit Init and Run on the bottom of the resulting [[.PanelTab.LeabraBatch]] panel that will open. This  will run a set of 25 networks, and store the data in the logfile you just created.  


(To speed things up, the display on the network and graphs has been turned off. If you want to observe activations while the network is running or monitor the visual graphs in the right frames, click on the appropriate tab that you want to view and check the <code>Display!</code> box on the top left.)


The output in the cnt_err column of the [[.PanelTab.EpochOutputData]] log file is the number of errors (out of 2) made in the optimal test environment, plotted as a function of epoch number, for each run of the network in the batch. Because the data are noisy (probabilistic rewards combined with random input weights which could by chance lead to particularly good or bad performance), we need to average across multiple networks with different sets of initial weights. 
This is done automatically at the end of running a batch of networks, with resulting mean and standard error of the number of errors reported in the <code>EpochOutputData_Group</code> data table and plotted in the associated graph on the right (click on its tab). A mean value of 1.0 reflects 50% performance (chance).

(To analyze the data manually, from the [[.PanelTab.EpochOutputData]] data table, click on  <code>DataProc->Group Mean SEM</code>. In the dialog box that pops up, make sure the   <code>dest_data</code> is set to <code>NULL</code>; this will create a new output data log under the AnalysisData_subgroup in the left frame, called <code>EpochOutputData_Group</code>. Also set  the first <code>gp_col1</code> to \"epoch\" so that the script can analyze performance as a function of each epoch, averaged across all networks. Set all other fields to <code>NULL</code> and click <code>Ok</code>. Now open the new analysis  <code>EpochOutputData_Group</code> log. You should see the statistics (mean, standard error) for each variable that was monitored in the EpochOutputData log. The relevant ones are cnt_err_mean and cnt_err_sem).

You should see that intact networks learn to choose the most rewarding stimulus/response combination within the 20 epochs, and then right at the reversal they make a high amount of errors (as expected since network doesn't know there is a reversal!), but then gradually learns to override its previous learned associations, using pure reinforcement learning. Thus the model learns NoGo to the previously rewarding response, and then as a result of noise in cortical unit activity, it will begin to select the previously incorrect response, which is then reinforced via new Go learning. (Note noise is critical for this exploration of alternative actions when a particular strategy isn't working; although not explored here, this noise can be dynamically modulated by norepinephrine function (Frank, Scheres & Sherman, 2007; inspired by McClure, Gilzenrat & Cohen 2005)

To simulate DA medication, simply check off the \"meds\" checkbox in the  [[.PanelTab.SelectEdit_1]] control panel. This sets the DA dip value so that the SNc dopamine units are prevented from completely dropping to zero during negative outcomes, as posited to arise from the tonic stimulation of levodopa and/or D2 agonists onto D2 receptors in the NoGo pathway, even if DA neurons themselves actually stop firing (see Frank, 2005).  (Specifically, the net input to DA cells is set to a minimum of .024, which is still a dip relative to the tonic value of .03, but less so than the intact dip to 0 value).
 
Set a new log file name in the EpochOutputData object, and give it a new name (e.g, with a DAmeds descriptor). Hit Init and Run on the LeabraBatch panel. When it's done, analyze the group mean and standard error as above. You should see that medicated networks are especially impaired in the probabilistic reversal learning phase compared with intact networks, due to a reduced ability to learn NoGo in order to over-ride previously learned Go associations. This prediction was confirmed in subsequent studies in which it was found that medicated PD patients showed specific deficits in reversal learning from negative prediction errors (NoGo learning), but not positive prediction errors (Go learning) (Cools, Altamirano, & D'Esposito, 2006). This effect is also similar to the impaired negative feedback learning seen in patients on l-dopa medication in our probabilistic selection task (Frank et al 2004, 2007).



== Role of the DA Pause ==

Some have argued that while phasic DA bursts encode positive predictions errors,  DA dips may not be functionally effective,  due to already low baseline firing rates of DA cells (e.g., Bayer & Glincher, 2005). For example, the smaller range of DA dips is likely compensated for by a counteracting asymmetry in the receptor <i>  sensitivity </i> to dips versus bursts.  In particular, because DA binds much more strongly to D2 than D1 class of receptors,  D2 receptors are very sensitive to low tonic DA  levels, whereas large increases in DA are required to functionally stimulate D1 receptors (e.g., Goto & Grace, 2005).  Thus smaller decreases in DA firing may be sufficient to functionally affect D2 receptors, which drives NoGo learning in our model. Consistent with this account, genetic factors controlling striatal D2 receptor are strongly predictive of NoGo learning in the probabilistic task (Frank et al, 2007; Klein et al, 2007). 

Moreover, recent evidence shows that the magnitude of negative prediction errors is correlated with the <i> duration </i> of DA pauses, rather than in the change in firing rates (Bayer, Lau & Glimcher, 2007).  This finding makes sense in the context of the model, because in order to learn from DA dips there has to be sufficient time for DA to be cleared from the synapse so that NoGo neurons can be disinhibited. Given a halflife of ~75 ms in dorsal striatum (Gonon, 1997), DA pauses for negative prediction errors lasting up to 350ms would give more than enough time for this signal to be functionally effective. Thus the longer the pause, the greater probability that a given D2 receptor will be unoccupied, and the greater likelihood of NoGo units to become disinhibited and undergo synaptic weight changes (NoGo learning).

To see this in the model, in the [[.PanelTab.SelectEdit_1]] control panel, change the \"burst/pause duration\" from 20 cycles to 10 cycles. This reduces the number of processing cycles in the 'plus phase' during which simulated DA levels change to their phasic value and drive Go or NoGo learning relative to the response selection 'minus phase'. Make sure all other settings are default (intact): maximal DA bursts (1.0), all 4 SNc units connected, no meds. If you re-run the intact network with this shorter burst/pause duration, you should see that acquisition is spared, but the model shows NoGo learning deficits in the reversal phase (see also the probabilsitic selection simulations).  This is because there has to be sufficient time for the SNc DA units to deactivate, and for the NoGo units to become disinhibited. The time course of this is dependent on the integration of membrane potentials and sluggishness of the neurons in the model, which is a rough approximation of the temporal dynamics associated with DA reuptake and NoGo unit disinhibition. In contrast, shorter duration DA bursts are still effective (Go learning is preserved), because the Go units that selected the response were already activated and simply got an additional boost of activity from the phasic burst. Thus the model demonstrates the usefulness of the DA pause carrying information in its duration. 

Finally, we show that the fidelity of the DA pause is perhaps more critical for performance in this task than that of the DA burst. Set the burst/pause duration back to teh default value of 30, and reduce the magnitude of the DA burst to .04 (corresponding to a DA unit normalized firing rate of 0.8). This setting caused relative Go learning deficits in the probabilistic selection simulations. Here, you should see that the networks show relatively intact acquisition and reversal, thus showing that the simple probabilistic reversal task is particularly demanding on the DA dip / NoGo system, given that one has to override prepotent Go associations with NoGo learning in the reversal phase. With more severe DA depletion (e.g., setting num_intact_snc_units to 2), the model shows global deficits in both acquisition and reversal, due to a substantial reduction in Go learning.

</body>
</html>
";
};
};
wizards {
name=;
el_typ=LeabraWizard;
el_def=0;
LeabraWizard @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="LeabraWizard_2";
auto_open=0;
n_layers=3;
layer_cfg {
name=;
el_typ=LayerWizEl;
el_def=0;
LayerWizEl @[0] {
name="LayerWizEl";
n_units=25;
io_type=76;
};
LayerWizEl @[1] {
name="LayerWizEl";
n_units=25;
io_type=INPUT;
};
LayerWizEl @[2] {
name="LayerWizEl";
n_units=25;
io_type=7274496;
};
};
connectivity=BIDIRECTIONAL;
default_net_type=LeabraNetwork;
};
};
edits {
name=;
el_typ=SelectEdit;
el_def=0;
SelectEdit @[0] {
name="SelectEdit_1";
auto_edit=1;
desc=;
mbrs {
name=;
el_typ=EditMbrItem;
el_def=0;
EditMbrItem @[0] {
label="tonic DA";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[11]$0$;
mbr=ProgVar::real_val;
};
EditMbrItem @[1] {
label="DA burst ";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[14]$1$;
mbr=ProgVar::real_val;
};
EditMbrItem @[2] {
label="DA dip ";
desc=" real value";
base=.projects[0].programs.gp[0][16].vars[13]$2$;
mbr=ProgVar::real_val;
};
EditMbrItem @[3] {
label="num intact snc units";
desc=" integer value (also for enum types)";
base=.projects[0].programs.gp[0][1].vars[13]$3$;
mbr=ProgVar::int_val;
};
EditMbrItem @[4] {
label="minus phase cycles";
desc=" the expression to compute and assign to the member<br>  :  enter the expression here -- you can just type in names of program variables or literal values. enclose strings in double quotes. variable names will be checked and automatically updated<br>  var lookup!:  lookup a program variable and add it to the current expression (this field then returns to empty/NULL)<br>  enum lookup!:  lookup a dynamic enum variable and add it to the current expression (this field then returns to empty/NULL)";
base=.projects[0].programs.gp[0][6].prog_code[4].false_code[0]$4$;
mbr=MemberAssign::expr;
};
EditMbrItem @[5] {
label="meds";
desc=" boolean value";
base=.projects[0].programs.gp[0][0].vars[1]$5$;
mbr=ProgVar::bool_val;
};
EditMbrItem @[6] {
label="burst/pause duration ";
desc=" the expression to compute and assign to the member<br>  :  enter the expression here -- you can just type in names of program variables or literal values. enclose strings in double quotes. variable names will be checked and automatically updated<br>  var lookup!:  lookup a program variable and add it to the current expression (this field then returns to empty/NULL)<br>  enum lookup!:  lookup a dynamic enum variable and add it to the current expression (this field then returns to empty/NULL)";
base=.projects[0].programs.gp[0][6].prog_code[4].true_code[0]$6$;
mbr=MemberAssign::expr;
};
};
mths {
name=;
el_typ=EditMthItem;
el_def=0;
group_type=GT_BUTTONS;
};
};
};
data {
name=;
el_typ=DataTable;
el_def=0;
DataTable_Group @.gp[0] {
name="InputData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="Train_Freq";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[20] "80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"80vs20";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";"20vs80";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 20] 1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 20] 1;0;1;0;1;0;1;0;0;1;1;0;1;0;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 20] 100;100;100;100;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 20] 1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[1] {
name="Train_Reversal";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[20] "80vs20R";"80vs20R";"80vs20R";"80vs20R";"80vs20R";"80vs20R";"80vs20R";"80vs20R";"80vs20R";"80vs20R";"20vs80R";"20vs80R";"20vs80R";"20vs80R";"20vs80R";"20vs80R";"20vs80R";"20vs80R";"20vs80R";"20vs80R";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 20] 1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0.0099999998;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0.0099999998;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 20] 0;1;0;1;0;1;0;1;1;0;0;1;0;1;0;1;0;1;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 20] 100;100;100;100;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0;0;0;0;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;0.035;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 20] 1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;1;0;1;0;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;0;1;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[2] {
name="TestFreq";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[2] "80";"80";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 2] 1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 2] 1;0;0;1;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 2] 0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 2] 0;0;0;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[3] {
name="Test_Reversal";
desc=;
data {
name="data";
el_typ=String_Data;
el_def=0;
String_Data @[0] {
name="Name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[2] "80_Rev";"80_Rev";};
};
float_Data @[1] {
name="Input";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 5;5;};
calc_expr {
expr=;
};
ar {
name=;
[5 5 2] 1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;1;0;0;0;0;0;0;0;0;};
};
float_Data @[2] {
name="Output";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 2] 0;1;1;0;};
};
float_Data @[3] {
name="SNc";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;2;};
calc_expr {
expr=;
};
ar {
name=;
[2 2 2] 0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;0.029999999;};
};
float_Data @[4] {
name="Motor_Cortex";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
ar {
name=;
[2 1 2] 0;0;0;0;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
DataTable_Group @.gp[1] {
name="OutputData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="TrialOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="trial";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
String_Data @[3] {
name="trial_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
String_Data @[4] {
name="group_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
int_Data @[5] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="phase_no";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[6] {
name="minus_cycles";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[7] {
name="sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[8] {
name="ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
float_Data @[9] {
name="Output_sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[0] };
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[1] {
name="EpochOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 0;};
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 0;};
};
float_Data @[2] {
name="avg_sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 0.99251437;};
};
float_Data @[3] {
name="cnt_err";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 1;};
};
float_Data @[4] {
name="avg_ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 0;};
};
float_Data @[5] {
name="avg_cycles";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[1] 100;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
DataTable @[2] {
name="CycleOutputData";
desc=;
data {
name="data";
el_typ=int_Data;
el_def=0;
int_Data @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="batch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="epoch";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="trial";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
String_Data @[3] {
name="trial_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
String_Data @[4] {
name="group_name";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[5] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="phase_no";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
int_Data @[6] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NARROW";
value 1 0=1;
};
};
name="cycle";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[7] {
name="sse";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[8] {
name="ext_rew";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[9] {
name="STN_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[10] {
name="Motor__acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[11] {
name="Thalam_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[12] {
name="GP_Int_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[13] {
name="GP_Ext_acts_avg";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
};
float_Data @[14] {
name="Output_act";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
};
float_Data @[15] {
name="Output_units_0_act";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=1;
cell_geom{ 2;1;};
calc_expr {
expr=;
};
};
};
data_flags=AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
DataTable_Group @.gp[2] {
name="AnalysisData";
el_typ=DataTable;
el_def=0;
DataTable @[0] {
name="EpochOutputData_Group";
desc=;
data {
name="data";
el_typ=DataColTp;
el_def=0;
int_Data @[0] {
name="epoch_group";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[41] 0;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;};
};
float_Data @[1] {
name="cnt_err_mean";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[41] 0.80000001;0.60000002;0.89999998;0.5;0.89999998;0.5;0.60000002;0.60000002;0.30000001;0.40000001;0.30000001;0.5;0.30000001;0.30000001;0.40000001;0.1;0.40000001;0.30000001;0.2;0.40000001;1.8;1.6;1;0.89999998;1.1;0.5;0.89999998;0.5;0.80000001;0.80000001;0.80000001;0.89999998;0.60000002;0.5;0.40000001;0.40000001;0.60000002;0.5;0.60000002;0.69999999;0.40000001;};
};
float_Data @[2] {
name="cnt_err_sem";
col_flags=SAVE_ROWS|SAVE_DATA;
is_matrix=0;
cell_geom{ 1;};
calc_expr {
expr=;
};
ar {
name=;
[41] 0.2366432;0.15491933;0.2626785;0.15811388;0.22135943;0.15811388;0.15491933;0.20976177;0.14491376;0.15491933;0.14491376;0.21213204;0.20248456;0.14491376;0.15491933;0.094868332;0.15491933;0.14491376;0.12649111;0.20976177;0.12649111;0.20976177;0.2;0.2626785;0.17029385;0.15811388;0.17029385;0.15811388;0.2366432;0.2366432;0.18973666;0.17029385;0.15491933;0.21213204;0.15491933;0.15491933;0.15491933;0.15811388;0.15491933;0.20248456;0.20976177;};
};
};
data_flags=SAVE_ROWS|AUTO_CALC;
auto_load=NO_AUTO_LOAD;
auto_load_file=;
keygen 4 0=0;
};
};
};
data_proc {
name=;
el_typ=taDataProc;
el_def=0;
taDataProc @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_base";
};
taDataAnal @[1] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_anal";
};
taDataGen @[2] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="data_gen";
};
taImageProc @[3] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="NO_CLIP";
value 1 0=1;
};
};
name="image_proc";
};
};
programs {
name=;
el_typ=Program;
el_def=0;
step_prog=.projects[0].programs[0]$7$;
tags=;
desc=;
Program @[0] {
name="LeabraStartup";
tags="Leabra, Startup";
desc="run project in the background (replaces leabra_startup.css)
command line is: emergent -nogui -ni -p <project name>.proj [epochs=xxx] [batches=xxx] [tag=xxx]";
flags=STARTUP_RUN;
objs {
name=;
el_typ=taNBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=.projects[0].networks[0]$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to operate on -- updates batch counter on network and passes it to train program";
};
ProgVar @[1] {
name="batches";
var_type=T_Int;
int_val=25;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[2] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[3] {
name="DA_burst_val";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[4] {
name="meds";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[5] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][0]$9$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
ProgVar @[6] {
name="TrainFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
ProgVar @[7] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][2]$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="batch";
var_type=T_Object;
object_type=Program;
object_val=.projects[0].programs.gp[0][0]$11$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="set this to point to your batch process";
};
ProgVar @[1] {
name="tag";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[2] {
name="log_dir";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="log file directory";
};
ProgVar @[3] {
name="log_file_nm";
var_type=T_String;
string_val="/home/frankmj/sims/bg_da/stn/distro/pn/pdp4/BG_ProbRev_recover1.epc.dat";
objs_ptr=0;
flags=NULL_CHECK;
desc="name of log file";
};
ProgVar @[4] {
name="EpochOutputData";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[1][1]$12$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[5] {
name="TrialOutputData";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[1][0]$13$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=Function;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
IfReturn @[0] {
desc="don't run if running in the gui!";
flags=;
cond {
expr="taMisc::gui_active";
var_expr="taMisc::gui_active";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
IfReturn @[0] {
desc="don't run if running in the gui!";
flags=;
cond {
expr="taMisc::gui_active";
var_expr="taMisc::gui_active";
vars {
};
var_names{ };
bad_vars{ };
};
};
Comment @[1] {
desc="add our special args from command line";
flags=;
};
MiscCall @[2] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"tag=\"";
var_expr="\"tag=\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"FileTag\"";
var_expr="\"FileTag\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[3] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"logdir=\"";
var_expr="\"logdir=\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"LogDir\"";
var_expr="\"LogDir\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[4] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"num_intact_snc_units=\"";
var_expr="\"num_intact_snc_units=\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"num_intact_snc_units\"";
var_expr="\"num_intact_snc_units\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[5] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"DA_burst_val=\"";
var_expr="\"DA_burst_val=\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"DA_burst_val\"";
var_expr="\"DA_burst_val\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[6] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"meds=\"";
var_expr="\"meds=\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"meds\"";
var_expr="\"meds\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[7] {
desc=;
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::AddArgName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="flag";
required=0;
def_val="\"\"";
expr {
expr="\"batches=\"";
var_expr="\"batches=\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="name";
required=0;
def_val="\"\"";
expr {
expr="\"batches\"";
var_expr="\"batches\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[8] {
desc="key step: actually process args!";
flags=;
result_var=NULL;
object_type=taMisc;
method=taMisc::UpdateArgs;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
RegisterArgs @[9] {
desc="This is KEY!!! actuall processes all args, including those from ProgVarFmArg guys below";
flags=;
};
Comment @[10] {
desc="Initialize and set variables from args";
flags=;
};
PrintExpr @[11] {
desc=;
flags=;
expr {
expr="\"Loaded project: \" << .projects[0].file_name";
var_expr="\"Loaded project: \" << .projects[0].file_name";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgVarFmArg @[12] {
desc=;
flags=;
prog=$11$;
var_name="meds";
arg_name="meds";
};
MethodCall @[13] {
desc=;
flags=;
result_var=NULL;
obj=.projects[0].programs[0].vars[0]$14$;
method=Program::Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MiscCall @[14] {
desc=;
flags=;
result_var=.projects[0].programs[0].vars[1]$15$;
object_type=taMisc;
method=taMisc::FindArgByName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="nm";
required=0;
def_val="\"\"";
expr {
expr="\"FileTag\"";
var_expr="\"FileTag\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[15] {
desc=;
flags=;
result_var=.projects[0].programs[0].vars[2]$16$;
object_type=taMisc;
method=taMisc::FindArgByName;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="nm";
required=0;
def_val="\"\"";
expr {
expr="\"LogDir\"";
var_expr="\"LogDir\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
ProgVarFmArg @[16] {
desc=;
flags=;
prog=$11$;
var_name="max_batch";
arg_name="batches";
};
ProgVarFmArg @[17] {
desc=;
flags=;
prog=.projects[0].programs.gp[0][1]$17$;
var_name="max_epoch";
arg_name="epochs";
};
ProgVarFmArg @[18] {
desc=;
flags=;
prog=$17$;
var_name="num_intact_snc_units";
arg_name="num_intact_snc_units";
};
ProgVarFmArg @[19] {
desc=;
flags=;
prog=.projects[0].programs.gp[0][16]$18$;
var_name="DA_burst_val";
arg_name="DA_burst_val";
};
Comment @[20] {
desc="Set log files";
flags=;
};
MethodCall @[21] {
desc="last arg is to include dmem proc number";
flags=;
result_var=.projects[0].programs[0].vars[3]$19$;
obj=.projects[0].programs[0].vars[4]$20$;
method=taBase::GetFileNameFmProject;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="ext";
required=1;
def_val=;
expr {
expr="\".epc.dat\"";
var_expr="\".epc.dat\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="tag";
required=0;
def_val="\"\"";
expr {
expr="tag";
var_expr="$#0#$";
vars {
};
var_names{ tag;};
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=const_taString_ref;
type="const taString&";
name="subdir";
required=0;
def_val="\"\"";
expr {
expr="log_dir";
var_expr="$#0#$";
vars {
};
var_names{ log_dir;};
bad_vars{ };
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="dmem_proc_no";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[22] {
desc="last arg is to restrict log to dmem_proc = 0";
flags=;
result_var=NULL;
obj=$20$;
method=DataTable::SaveDataLog;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="fname";
required=0;
def_val="\"\"";
expr {
expr="log_file_nm";
var_expr="$#0#$";
vars {
};
var_names{ log_file_nm;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=bool;
type="bool";
name="append";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="dmem_proc_0";
required=0;
def_val="true";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[23] {
desc="last arg is to include dmem proc number";
flags=OFF;
result_var=$19$;
obj=.projects[0].programs[0].vars[5]$21$;
method=taBase::GetFileNameFmProject;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="ext";
required=1;
def_val=;
expr {
expr="\".trl.dat\"";
var_expr="\".trl.dat\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="tag";
required=0;
def_val="\"\"";
expr {
expr="tag";
var_expr="$#0#$";
vars {
};
var_names{ tag;};
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=const_taString_ref;
type="const taString&";
name="subdir";
required=0;
def_val="\"\"";
expr {
expr="log_dir";
var_expr="$#0#$";
vars {
};
var_names{ log_dir;};
bad_vars{ };
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="dmem_proc_no";
required=0;
def_val="false";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[24] {
desc="last arg is to restrict log to dmem_proc = 0";
flags=OFF;
result_var=NULL;
obj=$21$;
method=DataTable::SaveDataLog;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="fname";
required=0;
def_val="\"\"";
expr {
expr="log_file_nm";
var_expr="$#0#$";
vars {
};
var_names{ log_file_nm;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=bool;
type="bool";
name="append";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="dmem_proc_0";
required=0;
def_val="true";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
OtherProgramVar @[25] {
desc=;
flags=OFF;
other_prog=$11$;
set_other=1;
var_1=.projects[0].programs[0].args[4]$22$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
PrintExpr @[26] {
desc=;
flags=;
expr {
expr="\"Running: \" << batch.name";
var_expr="\"Running: \" << $#0#$.name";
vars {
};
var_names{ batch;};
bad_vars{ };
};
};
ProgramCall @[27] {
desc=;
flags=;
target=$11$;
targ_ld_init="*LeabraBatch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
};
};
Program_Group @.gp[0] {
name="LeabraAll_Std";
el_typ=Program;
el_def=0;
step_prog=.projects[0].programs.gp[0][6]$23$;
tags="Leabra, Std, All";
desc="The full set of programs for training a standard Leabra network";
Program @[0] {
name="LeabraBatch";
tags="Leabra, Std";
desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to operate on -- updates batch counter on network and passes it to train program";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns -- not used by this program, but passed to train program";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="batch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="batch counter";
};
ProgVar @[1] {
name="meds";
var_type=T_Bool;
bool_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="simulate da meds (reduced da dip)?";
};
ProgVar @[2] {
name="DA_dip_val";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[3] {
name="gp_spec";
var_type=T_Object;
object_type=DataGroupSpec;
object_val=.projects[0].programs.gp[0][0].prog_code[2].loop_code[0].group_spec$24$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[4] {
name="epc_out_data";
var_type=T_Object;
object_type=DataTable;
object_val=$12$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
ProgVar @[5] {
name="max_batch";
var_type=T_Int;
int_val=50;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="maximum number of batch runs to perform";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initializes local batch counter and batch field on network";
flags=;
network_var=.projects[0].programs.gp[0][0].args[0]$25$;
local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$26$;
counter=Network::batch;
};
IfElse @[1] {
desc=;
flags=;
cond {
expr="meds==true";
var_expr="$#0#$==true";
vars {
};
var_names{ meds;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][0].vars[2]$27$;
expr {
expr=".024";
var_expr=".024";
vars {
};
var_names{ };
bad_vars{ };
};
};
OtherProgramVar @[1] {
desc=;
flags=;
other_prog=$18$;
set_other=1;
var_1=$27$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=$27$;
expr {
expr="0";
var_expr="0";
vars {
};
var_names{ };
bad_vars{ };
};
};
OtherProgramVar @[1] {
desc=;
flags=;
other_prog=$18$;
set_other=1;
var_1=$27$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
};
};
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
NetCounterInit @[0] {
desc="initializes local batch counter and batch field on network";
flags=;
network_var=$25$;
local_ctr_var=$26$;
counter=Network::batch;
};
WhileLoop @[1] {
desc="the main loop over training runs";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc="run the training program -- sets the network and input_data args";
flags=;
target=$17$;
targ_ld_init="*LeabraTrain*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=bool;
type="bool";
name="no_prompts";
required=1;
def_val=;
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment the local batch counter and copy to network";
flags=;
network_var=$25$;
local_ctr_var=$26$;
counter=Network::batch;
};
};
test {
expr="batch < max_batch";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ batch;max_batch;};
bad_vars{ };
};
};
DataCalcLoop @[2] {
desc="Calculate average err as function of epochs across nets.";
flags=;
src_data_var=.projects[0].programs.gp[0][0].vars[4]$28$;
dest_data_var=NULL;
src_cols {
name="src_cols";
el_typ=DataOpEl;
el_def=0;
DataOpEl @[0] {
col_name="batch";
};
DataOpEl @[1] {
col_name="epoch";
};
DataOpEl @[2] {
col_name="avg_sse";
};
DataOpEl @[3] {
col_name="cnt_err";
};
DataOpEl @[4] {
col_name="avg_ext_rew";
};
DataOpEl @[5] {
col_name="avg_cycles";
};
};
dest_cols {
name="dest_cols";
el_typ=DataOpEl;
el_def=0;
};
loop_code {
name=;
el_typ=UserScript;
el_def=0;
DataGroupProg @[0] {
desc=;
flags=;
src_data_var=$28$;
dest_data_var=NULL;
group_spec {
name="group_spec";
ops {
name=;
el_typ=DataGroupEl;
el_def=0;
DataGroupEl @[0] {
col_name="epoch";
agg {name="Aggregate": op=GROUP: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
};
DataGroupEl @[1] {
col_name="cnt_err";
agg {name="Aggregate": op=MEAN: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
};
DataGroupEl @[2] {
col_name="cnt_err";
agg {name="Aggregate": op=SEM: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
};
};
};
};
};
src_col_vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="s_batch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[1] {
name="s_epoch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[2] {
name="s_avg_sse";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[3] {
name="s_cnt_err";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[4] {
name="s_avg_ext_rew";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[5] {
name="s_avg_cycles";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
dest_col_vars {
name=;
el_typ=ProgVar;
el_def=0;
};
};
};
};
Program @[1] {
name="LeabraTrain";
tags="Leabra, Std";
desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
flags=SHOW_STEP;
objs {
name=;
el_typ=RndSeed;
el_def=0;
RndSeed @[0] {
name="rnd_seed";
seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;};
mti=156;
};
};
types {
name=;
el_typ=DynEnumType;
el_def=0;
DynEnumType @[0] {
name="RndInitType";
desc=;
enums {
name=;
el_typ=DynEnumItem;
el_def=0;
DynEnumItem @[0] {
name="OLD_SEED";
value=0;
desc="use stored random seed value (recreates same sequence every time)";
};
DynEnumItem @[1] {
name="NEW_SEED";
value=1;
desc="generate new random seed (new sequence of random numbers)";
};
};
bits=0;
};
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to train";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
ProgVar @[2] {
name="no_prompts";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="max_epoch";
var_type=T_Int;
int_val=40;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="maximum number of epochs to run";
};
ProgVar @[1] {
name="train_mode";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=Network::TrainMode;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
};
ProgVar @[2] {
name="test_mode";
var_type=T_HardEnum;
int_val=0;
hard_enum_type=Network::TrainMode;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
};
ProgVar @[3] {
name="rnd_init";
var_type=T_DynEnum;
dyn_enum_val {
enum_type=.projects[0].programs.gp[0][1].types[0]$29$;
value=0;
};
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="how to initialize the random numbers when the Init button is pressed";
};
ProgVar @[4] {
name="epoch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current epoch -- local copy, which is used to update network's epoch counter";
};
ProgVar @[5] {
name="err_stopcrit";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
};
ProgVar @[6] {
name="rnd_seed";
var_type=T_Object;
object_type=RndSeed;
object_val=.projects[0].programs.gp[0][1].objs[0]$30$;
objs_ptr=1;
flags=NULL_CHECK;
desc="random seed that is used at start of training -- if OldSeed is called";
};
ProgVar @[7] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[8] {
name="Test_Reversal";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][3]$31$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[9] {
name="train_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=.projects[0].networks[0].train_time$32$;
objs_ptr=0;
flags=NULL_CHECK;
desc="records time used to train network (object lives on network -- this is a pointer to it)";
};
ProgVar @[10] {
name="TestFreq";
var_type=T_Object;
object_type=DataTable;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[11] {
name="j";
var_type=T_Int;
int_val=18;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[12] {
name="i";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[13] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[14] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[15] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=.projects[0].networks[0].layers[2]$33$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[16] {
name="Train_Freq";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
ProgVar @[17] {
name="Train_Reversal";
var_type=T_Object;
object_type=DataTable;
object_val=.projects[0].data.gp[0][1]$34$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
ProgVar @[18] {
name="str_unit";
var_type=T_Object;
object_type=UnitSpec;
object_val=.projects[0].networks[0].specs.gp[2][0].children[3].children[0]$35$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[19] {
name="Striatum";
var_type=T_Object;
object_type=LeabraLayer;
object_val=.projects[0].networks[0].layers[1]$36$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][1].args[2]$37$;
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
MethodCall @[1] {
desc="check network to make sure it is ready to be run";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][1].args[0]$38$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
AssignExpr @[2] {
desc="get our pointer to the network training time object";
flags=;
result_var=.projects[0].programs.gp[0][1].vars[9]$39$;
expr {
expr="network.train_time";
var_expr="$#0#$.train_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
NetCounterInit @[3] {
desc="initialize epoch counter ";
flags=;
network_var=$38$;
local_ctr_var=.projects[0].programs.gp[0][1].vars[4]$40$;
counter=Network::epoch;
};
IfElse @[4] {
desc="initialize random seed (either old or new)";
flags=;
cond {
expr="rnd_init == OLD_SEED";
var_expr="$#0#$ == OLD_SEED";
vars {
};
var_names{ rnd_init;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="restore previous random seed (all runs produce same results)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][1].vars[6]$41$;
method=RndSeed::OldSeed;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="new random numbers each time";
flags=;
result_var=NULL;
obj=$41$;
method=RndSeed::NewSeed;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
IfGuiPrompt @[5] {
desc="don't initialize weights without checking";
flags=;
prompt="Do you want to Initialize Network Weights";
yes_label="Yes";
no_label="No";
yes_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="initialize network weights: could also load pre-set weights or something else here";
flags=;
result_var=NULL;
obj=$38$;
method=Network::Init_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
PrintExpr @[1] {
desc=;
flags=;
expr {
expr="network.name << \" Weights Initialized\"";
var_expr="$#0#$.name << \" Weights Initialized\"";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc="get our pointer to the network training time object";
flags=;
result_var=$39$;
expr {
expr="network.train_time";
var_expr="$#0#$.train_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[1] {
desc="start timer to keep track of how long it takes to run entire training run";
flags=;
result_var=NULL;
obj=$39$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
NetCounterInit @[2] {
desc="initialize epoch counter (both our local copy and network's epoch counter)";
flags=;
network_var=$38$;
local_ctr_var=$40$;
counter=Network::epoch;
};
MemberAssign @[3] {
desc=;
flags=;
obj=.projects[0].programs.gp[0][1].vars[18]$42$;
path="noise.mean";
expr {
expr=".001";
var_expr=".001";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[4] {
desc="set network's training mode to our local value";
flags=;
obj=$38$;
path="train_mode";
expr {
expr="train_mode";
var_expr="$#0#$";
vars {
};
var_names{ train_mode;};
bad_vars{ };
};
update_after=0;
};
IfElse @[5] {
desc=;
flags=;
cond {
expr="no_prompts";
var_expr="$#0#$";
vars {
};
var_names{ no_prompts;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="initialize network weights: could also load pre-set weights or something else here";
flags=;
result_var=NULL;
obj=$38$;
method=Network::Init_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
PrintExpr @[1] {
desc=;
flags=;
expr {
expr="network.name << \" Weights Initialized\"";
var_expr="$#0#$.name << \" Weights Initialized\"";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
AssignExpr @[6] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][1].vars[14]$43$;
expr {
expr="SNc.units.size";
var_expr="$#0#$.units.size";
vars {
};
var_names{ SNc;};
bad_vars{ };
};
};
ForLoop @[7] {
desc="only connect intact snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over striatal units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
UserScript @[0] {
desc="zero out weights for non-intact snc units";
flags=;
script {
expr="SNc.units[i].send[0].Cn(j).wt=0; SNc.units[i].send[1].Cn(j).wt=0;       ";
var_expr="$#0#$.units[$#1#$].send[0].Cn($#2#$).wt=0; $#0#$.units[$#1#$].send[1].Cn($#2#$).wt=0;       ";
vars {
};
var_names{ SNc;i;j;};
bad_vars{ };
};
};
};
init {
expr="j = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ j;};
bad_vars{ };
};
test {
expr="j <    (Striatum.units.size)/2";
var_expr="$#0#$ <    ($#1#$.units.size)/2";
vars {
};
var_names{ j;Striatum;};
bad_vars{ };
};
iter {
expr="j++";
var_expr="$#0#$++";
vars {
};
var_names{ j;};
bad_vars{ };
};
};
};
init {
expr="i = num_intact_snc_units";
var_expr="$#0#$ = $#1#$";
vars {
};
var_names{ i;num_intact_snc_units;};
bad_vars{ };
};
test {
expr="i <  snc_size";
var_expr="$#0#$ <  $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
OtherProgramVar @[8] {
desc=;
flags=;
other_prog=$18$;
set_other=1;
var_1=$3$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
OtherProgramVar @[9] {
desc=;
flags=;
other_prog=.projects[0].programs.gp[0][3]$44$;
set_other=1;
var_1=$3$;
var_2=NULL;
var_3=NULL;
var_4=NULL;
};
MemberAssign @[10] {
desc="set network's training mode to our local value";
flags=;
obj=$38$;
path="train_mode";
expr {
expr="test_mode";
var_expr="$#0#$";
vars {
};
var_names{ test_mode;};
bad_vars{ };
};
update_after=0;
};
ProgramCall @[11] {
desc="run the epoch program (one epoch), passes our network and input_data";
flags=;
target=$44$;
targ_ld_init="*LeabraTestEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestEnv";
required=1;
def_val=;
expr {
expr="TestFreq";
var_expr="$#0#$";
vars {
};
var_names{ TestFreq;};
bad_vars{ };
};
};
};
};
WhileLoop @[12] {
desc="main loop over epochs of training";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
MemberAssign @[0] {
desc="set network's training mode to our local value";
flags=;
obj=$38$;
path="train_mode";
expr {
expr="train_mode";
var_expr="$#0#$";
vars {
};
var_names{ train_mode;};
bad_vars{ };
};
update_after=0;
};
IfElse @[1] {
desc="Set Reversal environment mid-way through";
flags=;
cond {
expr="epoch<0.5*max_epoch";
var_expr="$#0#$<0.5*$#1#$";
vars {
};
var_names{ epoch;max_epoch;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc="run the epoch program (one epoch), passes our network and input_data";
flags=;
target=.projects[0].programs.gp[0][2]$45$;
targ_ld_init="*LeabraEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="Train_Freq";
var_expr="$#0#$";
vars {
};
var_names{ Train_Freq;};
bad_vars{ };
};
};
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc="run the epoch program (one epoch), passes our network and input_data";
flags=;
target=$45$;
targ_ld_init="*LeabraEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="Train_Reversal";
var_expr="$#0#$";
vars {
};
var_names{ Train_Reversal;};
bad_vars{ };
};
};
};
};
};
};
NetCounterIncr @[2] {
desc="increment the epoch counter (locally and on network)";
flags=;
network_var=$38$;
local_ctr_var=$40$;
counter=Network::epoch;
};
IfBreak @[3] {
desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
flags=OFF;
cond {
expr="network.cnt_err <= err_stopcrit";
var_expr="$#0#$.cnt_err <= $#1#$";
vars {
};
var_names{ network;err_stopcrit;};
bad_vars{ };
};
};
MemberAssign @[4] {
desc="set network's training mode to our local value";
flags=;
obj=$38$;
path="train_mode";
expr {
expr="test_mode";
var_expr="$#0#$";
vars {
};
var_names{ test_mode;};
bad_vars{ };
};
update_after=0;
};
IfElse @[5] {
desc="Set Reversal environment mid-way through";
flags=;
cond {
expr="epoch<0.5*max_epoch";
var_expr="$#0#$<0.5*$#1#$";
vars {
};
var_names{ epoch;max_epoch;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc=;
flags=;
target=$44$;
targ_ld_init="*LeabraTestEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestEnv";
required=1;
def_val=;
expr {
expr="TestFreq";
var_expr="$#0#$";
vars {
};
var_names{ TestFreq;};
bad_vars{ };
};
};
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ProgramCall @[0] {
desc=;
flags=;
target=$44$;
targ_ld_init="*LeabraTestEpoch*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestEnv";
required=1;
def_val=;
expr {
expr="Test_Reversal";
var_expr="$#0#$";
vars {
};
var_names{ Test_Reversal;};
bad_vars{ };
};
};
};
};
};
};
};
test {
expr="epoch < max_epoch";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ epoch;max_epoch;};
bad_vars{ };
};
};
MethodCall @[13] {
desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
flags=;
result_var=NULL;
obj=$39$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[2] {
name="LeabraEpoch";
tags="Leabra, Std";
desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to operate on";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="table of patterns to present to the network, one row at a time";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="data_loop_order";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=DataLoop::Order;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
};
ProgVar @[1] {
name="trial";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current trial (event) within the epoch -- increments automatically";
};
ProgVar @[2] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$13$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
};
ProgVar @[3] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=.projects[0].networks[0].epoch_time$46$;
objs_ptr=0;
flags=NULL_CHECK;
desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
};
ProgVar @[4] {
name="data_loop_index";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=NULL_CHECK;
desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=.projects[0].programs.gp[0][2].args[0]$47$;
local_ctr_var=.projects[0].programs.gp[0][2].vars[1]$48$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=.projects[0].programs.gp[0][2].vars[3]$49$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=$47$;
local_ctr_var=$48$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=$49$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[2] {
desc="start the epoch timer to record computation time per epoch";
flags=;
result_var=NULL;
obj=$49$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[3] {
desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][2].vars[2]$50$;
method=DataTable::ResetData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetDataLoop @[4] {
desc="iterates over the events/rows of input_data, according to data_loop_order variable";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the trial program, passing network and input_data";
flags=;
target=.projects[0].programs.gp[0][4]$51$;
targ_ld_init="*LeabraTrial*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
IfElse @[1] {
desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
flags=;
cond {
expr="network.Compute_Weights_Test(trial+1)";
var_expr="$#0#$.Compute_Weights_Test($#1#$+1)";
vars {
};
var_names{ network;trial;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="update the weight values based on changes computed by trial program";
flags=;
result_var=NULL;
obj=$47$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
};
data_var=.projects[0].programs.gp[0][2].args[1]$52$;
index_var=.projects[0].programs.gp[0][2].vars[4]$53$;
order_var=.projects[0].programs.gp[0][2].vars[0]$54$;
order=PERMUTED;
item_idx_list{ 8;2;5;15;18;3;11;12;1;17;0;10;4;16;9;14;13;6;19;7;};
dmem_nprocs=1;
dmem_this_proc=0;
};
IfElse @[5] {
desc="if full batch mode, update only at end of epoch";
flags=;
cond {
expr="network.wt_update == Network::BATCH";
var_expr="$#0#$.wt_update == Network::BATCH";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="final update of weights based on accumulated changes";
flags=;
result_var=NULL;
obj=$47$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
MethodCall @[6] {
desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
flags=;
result_var=NULL;
obj=$47$;
method=LeabraNetwork::Compute_EpochStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[7] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=OFF;
target=.projects[0].programs.gp[0][14]$55$;
targ_ld_init="*LeabraEpochMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[8] {
desc="done with the computation in the epoch -- record time it took";
flags=;
result_var=NULL;
obj=$49$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[3] {
name="LeabraTestEpoch";
tags=;
desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to operate on";
};
ProgVar @[1] {
name="TestEnv";
var_type=T_Object;
object_type=DataTable;
object_val=$10$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="data_loop_order";
var_type=T_HardEnum;
int_val=1;
hard_enum_type=DataLoop::Order;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
};
ProgVar @[1] {
name="trial";
var_type=T_Int;
int_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current trial (event) within the epoch -- increments automatically";
};
ProgVar @[2] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$13$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
};
ProgVar @[3] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=$46$;
objs_ptr=0;
flags=NULL_CHECK;
desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
};
ProgVar @[4] {
name="data_loop_index";
var_type=T_Int;
int_val=2;
objs_ptr=0;
flags=NULL_CHECK;
desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
};
ProgVar @[5] {
name="epoch";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[6] {
name="max_epoch";
var_type=T_Int;
int_val=40;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[7] {
name="str_unit";
var_type=T_Object;
object_type=UnitSpec;
object_val=$35$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[8] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[9] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[10] {
name="k";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[11] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$33$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=.projects[0].programs.gp[0][3].args[0]$56$;
local_ctr_var=.projects[0].programs.gp[0][3].vars[1]$57$;
counter=Network::trial;
};
AssignExpr @[1] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=.projects[0].programs.gp[0][3].vars[3]$58$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[5]$59$;
expr {
expr=".programs.LeabraTrain.epoch.int_val";
var_expr=".programs.LeabraTrain.epoch.int_val";
vars {
};
var_names{ };
bad_vars{ };
};
};
AssignExpr @[3] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[6]$60$;
expr {
expr=".programs.LeabraTrain.max_epoch.int_val";
var_expr=".programs.LeabraTrain.max_epoch.int_val";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
IfElse @[0] {
desc="Set Reversal environment mid-way through";
flags=;
cond {
expr="epoch<0.5*max_epoch";
var_expr="$#0#$<0.5*$#1#$";
vars {
};
var_names{ epoch;max_epoch;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=" set input data";
flags=;
obj=.projects[0].programs.gp[0][3].args[1]$61$;
path="TestFreq";
expr {
expr=;
var_expr=;
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=" set input data";
flags=;
obj=$61$;
path="Test_Reversal";
expr {
expr=;
var_expr=;
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
};
NetCounterInit @[1] {
desc="initialize trial counter (local variable and in the network)";
flags=;
network_var=$56$;
local_ctr_var=$57$;
counter=Network::trial;
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[9]$62$;
expr {
expr="SNc.units.size";
var_expr="$#0#$.units.size";
vars {
};
var_names{ SNc;};
bad_vars{ };
};
};
AssignExpr @[3] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][3].vars[10]$63$;
expr {
expr="(float)num_intact_snc_units/ snc_size";
var_expr="(float)$#0#$/ $#1#$";
vars {
};
var_names{ num_intact_snc_units;snc_size;};
bad_vars{ };
};
};
AssignExpr @[4] {
desc="get pointer to epoch timer object on network";
flags=;
result_var=$58$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[5] {
desc="start the epoch timer to record computation time per epoch";
flags=;
result_var=NULL;
obj=$58$;
method=TimeUsed::StartTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_used";
required=0;
def_val="true";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[6] {
desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][3].vars[2]$64$;
method=DataTable::ResetData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetDataLoop @[7] {
desc="iterates over the events/rows of input_data, according to data_loop_order variable";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the trial program, passing network and input_data";
flags=;
target=.projects[0].programs.gp[0][5]$65$;
targ_ld_init="*LeabraTestTrial*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestEnv";
var_expr="$#0#$";
vars {
};
var_names{ TestEnv;};
bad_vars{ };
};
};
};
};
IfElse @[1] {
desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
flags=;
cond {
expr="network.Compute_Weights_Test(trial+1)";
var_expr="$#0#$.Compute_Weights_Test($#1#$+1)";
vars {
};
var_names{ network;trial;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="update the weight values based on changes computed by trial program";
flags=;
result_var=NULL;
obj=$56$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
};
data_var=$61$;
index_var=.projects[0].programs.gp[0][3].vars[4]$66$;
order_var=.projects[0].programs.gp[0][3].vars[0]$67$;
order=PERMUTED;
item_idx_list{ 1;0;};
dmem_nprocs=1;
dmem_this_proc=0;
};
IfElse @[8] {
desc="if full batch mode, update only at end of epoch";
flags=;
cond {
expr="network.wt_update == Network::BATCH";
var_expr="$#0#$.wt_update == Network::BATCH";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="final update of weights based on accumulated changes";
flags=;
result_var=NULL;
obj=$56$;
method=Network::Compute_Weights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
MethodCall @[9] {
desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
flags=;
result_var=NULL;
obj=$56$;
method=LeabraNetwork::Compute_EpochStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[10] {
desc="run program that records data from network and possibly other sources about the epoch";
flags=;
target=$55$;
targ_ld_init="*LeabraEpochMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[11] {
desc="done with the computation in the epoch -- record time it took";
flags=;
result_var=NULL;
obj=$58$;
method=TimeUsed::EndTimer;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[4] {
name="LeabraTrial";
tags="Leabra, Std";
desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
flags=SHOW_STEP;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to operate on -- typically set by higher-level calling programs";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=NULL_CHECK;
desc="datatable containing training input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="phase_no";
var_type=T_Int;
int_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
};
ProgVar @[1] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether to update any network view displays after trial is completed";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=.projects[0].programs.gp[0][4].args[0]$68$;
local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$69$;
counter=LeabraNetwork::phase_no;
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=$68$;
local_ctr_var=$69$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[1] {
desc="initializes various counters at start of trial";
flags=;
result_var=NULL;
obj=$68$;
method=LeabraNetwork::Trial_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
WhileLoop @[2] {
desc="loop over phases of settling in the network";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
UserScript @[0] {
desc=;
flags=OFF;
script {
expr=".programs.LeabraSettle.Init();
";
var_expr=".programs.LeabraSettle.Init();
";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgramCall @[1] {
desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
flags=;
target=$23$;
targ_ld_init="*LeabraSettle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[2] {
desc="increment the phase number (also on network)";
flags=;
network_var=$68$;
local_ctr_var=$69$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[3] {
desc="increments other phase state information to prepare for the next phase of settling";
flags=;
result_var=NULL;
obj=$68$;
method=LeabraNetwork::Trial_UpdatePhase;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
test {
expr="phase_no < network.phase_max";
var_expr="$#0#$ < $#1#$.phase_max";
vars {
};
var_names{ phase_no;network;};
bad_vars{ };
};
};
MethodCall @[3] {
desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
flags=;
result_var=NULL;
obj=$68$;
method=LeabraNetwork::Trial_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[4] {
desc="records data about the trial-level processing to a datatable for graphing/processing";
flags=OFF;
target=.projects[0].programs.gp[0][12]$70$;
targ_ld_init="*LeabraTrialMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetUpdateView @[5] {
desc="update the network view(s) (only if update_net_view is true)";
flags=;
network_var=$68$;
update_var=.projects[0].programs.gp[0][4].vars[1]$71$;
};
};
};
Program @[5] {
name="LeabraTestTrial";
tags=;
desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to operate on -- typically set by higher-level calling programs";
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK;
desc="datatable containing training input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="phase_no";
var_type=T_Int;
int_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
};
ProgVar @[1] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether to update any network view displays after trial is completed";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=.projects[0].programs.gp[0][5].args[0]$72$;
local_ctr_var=.projects[0].programs.gp[0][5].vars[0]$73$;
counter=LeabraNetwork::phase_no;
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
NetCounterInit @[0] {
desc="initialize the local phase_no counter, and corresponding network one";
flags=;
network_var=$72$;
local_ctr_var=$73$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[1] {
desc="initializes various counters at start of trial";
flags=;
result_var=NULL;
obj=$72$;
method=LeabraNetwork::Trial_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
WhileLoop @[2] {
desc="loop over phases of settling in the network";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
UserScript @[0] {
desc=;
flags=OFF;
script {
expr=".programs.LeabraTestSettle.Init();
";
var_expr=".programs.LeabraTestSettle.Init();
";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgramCall @[1] {
desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
flags=;
target=.projects[0].programs.gp[0][7]$74$;
targ_ld_init="*LeabraTestSettle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[2] {
desc="increment the phase number (also on network)";
flags=;
network_var=$72$;
local_ctr_var=$73$;
counter=LeabraNetwork::phase_no;
};
MethodCall @[3] {
desc="increments other phase state information to prepare for the next phase of settling";
flags=;
result_var=NULL;
obj=$72$;
method=LeabraNetwork::Trial_UpdatePhase;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
test {
expr="phase_no < network.phase_max";
var_expr="$#0#$ < $#1#$.phase_max";
vars {
};
var_names{ phase_no;network;};
bad_vars{ };
};
};
MethodCall @[3] {
desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
flags=;
result_var=NULL;
obj=$72$;
method=LeabraNetwork::Trial_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[4] {
desc="records data about the trial-level processing to a datatable for graphing/processing";
flags=;
target=$70$;
targ_ld_init="*LeabraTrialMonitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetUpdateView @[5] {
desc="update the network view(s) (only if update_net_view is true)";
flags=;
network_var=$72$;
update_var=.projects[0].programs.gp[0][5].vars[1]$75$;
};
};
};
Program @[6] {
name="LeabraSettle";
tags="Leabra, Std";
desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle";
var_type=T_Int;
int_val=9;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current cycle of settling (local loop counter)";
};
ProgVar @[1] {
name="min_cycles";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=NULL_CHECK;
desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
};
ProgVar @[2] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="if true, will update network views at end of settling";
};
ProgVar @[3] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=.projects[0].programs.gp[0][10].objs[0]$76$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=.projects[0].programs.gp[0][6].args[0]$77$;
local_ctr_var=.projects[0].programs.gp[0][6].vars[0]$78$;
counter=Network::cycle;
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=$77$;
local_ctr_var=$78$;
counter=Network::cycle;
};
MethodCall @[1] {
desc="resets input data, before getting new external inputs data from apply inputs call";
flags=;
result_var=NULL;
obj=$77$;
method=Network::Init_InputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[2] {
desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
flags=;
target=.projects[0].programs.gp[0][10]$79$;
targ_ld_init="*ApplyInputs*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
ProgramCall @[3] {
desc=;
flags=;
target=$18$;
targ_ld_init="*DA_Rew_Punish*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
};
};
IfElse @[4] {
desc=;
flags=;
cond {
expr="network.phase == LeabraNetwork::PLUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::PLUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=;
flags=;
obj=$77$;
path="cycle_max";
expr {
expr="20";
var_expr="20";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="number of cycles to run in minus phase";
flags=;
obj=$77$;
path="cycle_max";
expr {
expr="100";
var_expr="100";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
};
MethodCall @[5] {
desc="initializes various counters at start of settling";
flags=;
result_var=NULL;
obj=$77$;
method=LeabraNetwork::Settle_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[6] {
desc="get appropriate min_cycles value depending on which phase we're in";
flags=;
cond {
expr="network.phase_no <= 1";
var_expr="$#0#$.phase_no <= 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=.projects[0].programs.gp[0][6].vars[1]$80$;
expr {
expr="network.min_cycles";
var_expr="$#0#$.min_cycles";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=$80$;
expr {
expr="network.min_cycles_phase2";
var_expr="$#0#$.min_cycles_phase2";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
WhileLoop @[7] {
desc="the main loop over cycles of updating";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the cycle program, which computes one cycle of activations";
flags=;
target=.projects[0].programs.gp[0][8]$81$;
targ_ld_init="*LeabraCycle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment cycle counter (also on network)";
flags=;
network_var=$77$;
local_ctr_var=$78$;
counter=Network::cycle;
};
IfContinue @[2] {
desc="avoid subsequent stopping criteria if below min_cycles";
flags=;
cond {
expr="cycle < min_cycles";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ cycle;min_cycles;};
bad_vars{ };
};
};
IfBreak @[3] {
desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
flags=;
cond {
expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
var_expr="($#0#$.maxda < $#0#$.maxda_stopcrit) ||
 ($#0#$.trg_max_act > $#0#$.trg_max_act_stopcrit)";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
test {
expr="cycle < network.cycle_max";
var_expr="$#0#$ < $#1#$.cycle_max";
vars {
};
var_names{ cycle;network;};
bad_vars{ };
};
};
MethodCall @[8] {
desc="perform final operations at end of settling (storing final activations, etc)";
flags=;
result_var=NULL;
obj=$77$;
method=LeabraNetwork::Settle_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[9] {
desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
flags=;
cond {
expr="network.phase == LeabraNetwork::MINUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::MINUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="compute trial-level statistics";
flags=;
result_var=NULL;
obj=$77$;
method=LeabraNetwork::Compute_TrialStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
IfElse @[10] {
desc="this stat must be called in plus phase when reward information is avail";
flags=;
cond {
expr="network.phase_no == 1";
var_expr="$#0#$.phase_no == 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="get external reward information";
flags=;
result_var=NULL;
obj=$77$;
method=LeabraNetwork::Compute_ExtRew;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
NetUpdateView @[11] {
desc="update network views, if update_net_view == true";
flags=;
network_var=$77$;
update_var=.projects[0].programs.gp[0][6].vars[2]$82$;
};
};
};
Program @[7] {
name="LeabraTestSettle";
tags=;
desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle";
var_type=T_Int;
int_val=100;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="current cycle of settling (local loop counter)";
};
ProgVar @[1] {
name="min_cycles";
var_type=T_Int;
int_val=15;
objs_ptr=0;
flags=NULL_CHECK;
desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
};
ProgVar @[2] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="if true, will update network views at end of settling";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=.projects[0].programs.gp[0][7].args[0]$83$;
local_ctr_var=.projects[0].programs.gp[0][7].vars[0]$84$;
counter=Network::cycle;
};
};
prog_code {
name=;
el_typ=NetCounterInit;
el_def=0;
NetCounterInit @[0] {
desc="initialize local cycle counter and corresponding counter on network";
flags=;
network_var=$83$;
local_ctr_var=$84$;
counter=Network::cycle;
};
MethodCall @[1] {
desc="resets input data, before getting new external inputs data from apply inputs call";
flags=;
result_var=NULL;
obj=$83$;
method=Network::Init_InputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
ProgramCall @[2] {
desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
flags=;
target=.projects[0].programs.gp[0][11]$85$;
targ_ld_init="*ApplyInputsTest*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="TestWP";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
ProgramCall @[3] {
desc=;
flags=;
target=$18$;
targ_ld_init="*DA_Rew_Punish*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=DataTable;
type="DataTable*";
name="input_data";
required=1;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
};
};
IfElse @[4] {
desc=;
flags=;
cond {
expr="network.phase == LeabraNetwork::PLUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::PLUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc=;
flags=;
obj=$83$;
path="cycle_max";
expr {
expr="30";
var_expr="30";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="number of cycles to run in minus phase";
flags=;
obj=$83$;
path="cycle_max";
expr {
expr="100";
var_expr="100";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
};
MethodCall @[5] {
desc="initializes various counters at start of settling";
flags=;
result_var=NULL;
obj=$83$;
method=LeabraNetwork::Settle_Init;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[6] {
desc="get appropriate min_cycles value depending on which phase we're in";
flags=;
cond {
expr="network.phase_no <= 1";
var_expr="$#0#$.phase_no <= 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=.projects[0].programs.gp[0][7].vars[1]$86$;
expr {
expr="network.min_cycles";
var_expr="$#0#$.min_cycles";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
flags=;
result_var=$86$;
expr {
expr="network.min_cycles_phase2";
var_expr="$#0#$.min_cycles_phase2";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
WhileLoop @[7] {
desc="the main loop over cycles of updating";
flags=;
loop_code {
name=;
el_typ=ProgramCall;
el_def=0;
ProgramCall @[0] {
desc="run the cycle program, which computes one cycle of activations";
flags=;
target=.projects[0].programs.gp[0][9]$87$;
targ_ld_init="*LeabraTestCycle*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=LeabraNetwork;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
NetCounterIncr @[1] {
desc="increment cycle counter (also on network)";
flags=;
network_var=$83$;
local_ctr_var=$84$;
counter=Network::cycle;
};
IfContinue @[2] {
desc="avoid subsequent stopping criteria if below min_cycles";
flags=;
cond {
expr="cycle < min_cycles";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ cycle;min_cycles;};
bad_vars{ };
};
};
IfBreak @[3] {
desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
flags=;
cond {
expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
var_expr="($#0#$.maxda < $#0#$.maxda_stopcrit) ||
 ($#0#$.trg_max_act > $#0#$.trg_max_act_stopcrit)";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
test {
expr="cycle < network.cycle_max";
var_expr="$#0#$ < $#1#$.cycle_max";
vars {
};
var_names{ cycle;network;};
bad_vars{ };
};
};
MethodCall @[8] {
desc="perform final operations at end of settling (storing final activations, etc)";
flags=;
result_var=NULL;
obj=$83$;
method=LeabraNetwork::Settle_Final;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
IfElse @[9] {
desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
flags=;
cond {
expr="network.phase == LeabraNetwork::MINUS_PHASE";
var_expr="$#0#$.phase == LeabraNetwork::MINUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="compute trial-level statistics";
flags=;
result_var=NULL;
obj=$83$;
method=LeabraNetwork::Compute_TrialStats;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
IfElse @[10] {
desc="this stat must be called in plus phase when reward information is avail";
flags=;
cond {
expr="network.phase_no == 1";
var_expr="$#0#$.phase_no == 1";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MethodCall @[0] {
desc="get external reward information";
flags=;
result_var=NULL;
obj=$83$;
method=LeabraNetwork::Compute_ExtRew;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
};
};
NetUpdateView @[11] {
desc="update network views, if update_net_view == true";
flags=;
network_var=$83$;
update_var=.projects[0].programs.gp[0][7].vars[2]$88$;
};
};
};
Program @[8] {
name="LeabraCycle";
tags="Leabra, Std";
desc="runs one cycle of leabra processing (updating net inputs and activations)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="this does all the standard leabra processing for one cycle of activation updating";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][8].args[0]$89$;
method=LeabraNetwork::Cycle_Run;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetUpdateView @[1] {
desc="update network views if update_net_view == true";
flags=;
network_var=$89$;
update_var=.projects[0].programs.gp[0][8].vars[0]$90$;
};
ProgramCall @[2] {
desc=;
flags=OFF|NON_STD;
target=.projects[0].programs.gp[0][13]$91$;
targ_ld_init="*Cycle_Monitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
};
};
Program @[9] {
name="LeabraTestCycle";
tags=;
desc="runs one cycle of leabra processing (updating net inputs and activations)";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="update_net_view";
var_type=T_Bool;
bool_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="this does all the standard leabra processing for one cycle of activation updating";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][9].args[0]$92$;
method=LeabraNetwork::Cycle_Run;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
NetUpdateView @[1] {
desc="update network views if update_net_view == true";
flags=;
network_var=$92$;
update_var=.projects[0].programs.gp[0][9].vars[0]$93$;
};
ProgramCall @[2] {
desc=;
flags=;
target=$91$;
targ_ld_init="*Cycle_Monitor*";
prog_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=Network;
type="LeabraNetwork*";
name="network";
required=1;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
};
};
Program @[10] {
name="ApplyInputs";
tags="Network, InputData, Apply";
desc="apply the current input data to the network as external input and target values";
flags=;
objs {
name=;
el_typ=LayerWriter;
el_def=0;
LayerWriter @[0] {
name="LayerWriter_0";
data=$9$;
network=$8$;
layer_data {
name=;
el_typ=LayerWriterEl;
el_def=0;
LayerWriterEl @[0] {
chan_name="Input";
net_target=LAYER;
layer_name="Input";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[1] {
chan_name="Output";
net_target=LAYER;
layer_name="Output";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[2] {
chan_name="SNc";
net_target=LAYER;
layer_name="SNc";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[3] {
chan_name="Motor_Cortex";
net_target=LAYER;
layer_name="Motor_Cortex";
offset {x=0: y=0: };
use_layer_type=0;
ext_flags=COMP;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[4] {
chan_name="Name";
net_target=TRIAL_NAME;
layer_name="Name";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
};
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to apply inputs to -- typically set by calling program";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=NULL_CHECK;
desc="input datatable containing input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=$76$;
objs_ptr=1;
flags=CTRL_PANEL|NULL_CHECK;
desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][10].vars[0]$94$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
flags=;
result_var=NULL;
obj=$94$;
method=taList_impl::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=$94$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="input_data";
var_expr="$#0#$";
vars {
};
var_names{ input_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="apply inputs to the network!  layer writer has all the key specs";
flags=;
result_var=NULL;
obj=$94$;
method=LayerWriter::ApplyInputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[11] {
name="ApplyInputsTest";
tags=;
desc="apply the current input data to the network as external input and target values";
flags=;
objs {
name=;
el_typ=LayerWriter;
el_def=0;
LayerWriter @[0] {
name="LayerWriter_0";
data=$10$;
network=$8$;
layer_data {
name=;
el_typ=LayerWriterEl;
el_def=0;
LayerWriterEl @[0] {
chan_name="Input";
net_target=LAYER;
layer_name="Input";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[1] {
chan_name="Output";
net_target=LAYER;
layer_name="Output";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[2] {
chan_name="SNc";
net_target=LAYER;
layer_name="SNc";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=EXT;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[3] {
chan_name="Motor_Cortex";
net_target=LAYER;
layer_name="Motor_Cortex";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=TARG;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
LayerWriterEl @[4] {
chan_name="Name";
net_target=TRIAL_NAME;
layer_name="Name";
offset {x=0: y=0: };
use_layer_type=1;
ext_flags=;
noise {name="": type=NONE: mean=0: var=0.5: par=1: };
};
};
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$8$;
objs_ptr=0;
flags=NULL_CHECK;
desc="network to apply inputs to -- typically set by calling program";
};
ProgVar @[1] {
name="TestWP";
var_type=T_Object;
object_type=DataTable;
object_val=$10$;
objs_ptr=0;
flags=NULL_CHECK;
desc="input datatable containing input/output patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="LayerWriter_0";
var_type=T_Object;
object_type=LayerWriter;
object_val=.projects[0].programs.gp[0][11].objs[0]$95$;
objs_ptr=1;
flags=CTRL_PANEL|NULL_CHECK;
desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][11].vars[0]$96$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
flags=;
result_var=NULL;
obj=$96$;
method=taList_impl::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="sets the datatable and network for the layer writer, so it knows what to write to";
flags=;
result_var=NULL;
obj=$96$;
method=LayerWriter::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataBlock_ptr;
type="DataBlock*";
name="db";
required=0;
def_val=;
expr {
expr="TestWP";
var_expr="$#0#$";
vars {
};
var_names{ TestWP;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="apply inputs to the network!  layer writer has all the key specs";
flags=;
result_var=NULL;
obj=$96$;
method=LayerWriter::ApplyInputData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[12] {
name="LeabraTrialMonitor";
tags="Leabra, Std, Monitor";
desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="trial_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="trial";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="trial";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="trial_name";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="trial_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="group_name";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="group_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="phase_no";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="phase_no";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[6] {
name="minus_cycles";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="minus_cycles";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[7] {
name="sse";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[8] {
name="ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[9] {
name="Output_sse";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[7]$97$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$8$;
data=$13$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to record data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="trial_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$13$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="data table to record trial-level data to (this program writes new data to this table!)";
};
ProgVar @[1] {
name="trial_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][12].objs[0]$98$;
objs_ptr=1;
flags=NULL_CHECK;
desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="set the network and datatable for the NetMonitor";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].vars[1]$99$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="trial_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ trial_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
flags=;
result_var=NULL;
obj=$99$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[2] {
desc="update the monitor items and data schema based on current settings of the NetMonitor object";
flags=;
result_var=NULL;
obj=$99$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].vars[0]$100$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[1] {
desc="get the new monitor data from the network and other sources -- this does the main work";
flags=;
result_var=NULL;
obj=$99$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[2] {
desc="update views and other things after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$100$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[3] {
desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][12].args[0]$101$;
method=Network::DMem_ShareTrialData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=1;
def_val=;
expr {
expr="trial_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ trial_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="n_rows";
required=0;
def_val="1";
expr {
expr="1";
var_expr="1";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
};
Program @[13] {
name="Cycle_Monitor";
tags=;
desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="cycle_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="trial";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="trial";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="trial_name";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="trial_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="group_name";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="group_name";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="phase_no";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="phase_no";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[6] {
name="cycle";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="cycle";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[7] {
name="sse";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[8] {
name="ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[9] {
name="STN_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[8]$102$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[10] {
name="Motor__acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[6]$103$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[11] {
name="Thalam_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[5]$104$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[12] {
name="GP_Int_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[3]$105$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[13] {
name="GP_Ext_acts_avg";
computed=0;
object_type=LeabraLayer;
object=.projects[0].networks[0].layers[4]$106$;
variable="acts.avg";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[14] {
name="Output_act";
computed=0;
object_type=LeabraLayer;
object=$97$;
variable="act";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[15] {
name="Output_units_0_act";
computed=0;
object_type=LeabraLayer;
object=$97$;
variable="units[0].act";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$8$;
data=.projects[0].data.gp[1][2]$107$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to record data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="cycle_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$107$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="data table to record trial-level data to (this program writes new data to this table!)";
};
ProgVar @[1] {
name="cycle_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][13].objs[0]$108$;
objs_ptr=1;
flags=NULL_CHECK;
desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="set the network and datatable for the NetMonitor";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].vars[1]$109$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="cycle_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ cycle_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[1] {
desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
flags=;
result_var=NULL;
obj=$109$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[2] {
desc="update the monitor items and data schema based on current settings of the NetMonitor object";
flags=;
result_var=NULL;
obj=$109$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
IfReturn @[0] {
desc=;
flags=;
cond {
expr="network.phase_no>0";
var_expr="$#0#$.phase_no>0";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[1] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].vars[0]$110$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[2] {
desc="get the new monitor data from the network and other sources -- this does the main work";
flags=;
result_var=NULL;
obj=$109$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[3] {
desc="update views and other things after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$110$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[4] {
desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][13].args[0]$111$;
method=Network::DMem_ShareTrialData;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=1;
def_val=;
expr {
expr="cycle_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ cycle_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="n_rows";
required=0;
def_val="1";
expr {
expr="1";
var_expr="1";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
};
Program @[14] {
name="LeabraEpochMonitor";
tags="Leabra, Std, Monitor";
desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
flags=;
objs {
name=;
el_typ=NetMonitor;
el_def=0;
NetMonitor @[0] {
name="epoch_netmon";
items {
name=;
el_typ=NetMonItem;
el_def=0;
NetMonItem @[0] {
name="batch";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="batch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[1] {
name="epoch";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="epoch";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[2] {
name="avg_sse";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="avg_sse";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[3] {
name="cnt_err";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="cnt_err";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[4] {
name="avg_ext_rew";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="avg_ext_rew";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
NetMonItem @[5] {
name="avg_cycles";
computed=0;
object_type=LeabraNetwork;
object=$8$;
variable="avg_cycles";
var_label=;
name_style=AUTO_NAME;
max_name_len=6;
val_type=VT_FLOAT;
matrix=0;
matrix_geom{ };
agg {name="": op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
};
};
network=$8$;
data=$12$;
rmv_orphan_cols=1;
};
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to get data from";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="epoch_mon_data";
var_type=T_Object;
object_type=DataTable;
object_val=$12$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="data table to write the epoch data to";
};
ProgVar @[1] {
name="epoch_netmon";
var_type=T_Object;
object_type=NetMonitor;
object_val=.projects[0].programs.gp[0][14].objs[0]$112$;
objs_ptr=1;
flags=NULL_CHECK;
desc="network monitor object that contains full specs for what to record and where to get it";
};
ProgVar @[2] {
name="epoch_timer";
var_type=T_Object;
object_type=TimeUsed;
object_val=$46$;
objs_ptr=0;
flags=NULL_CHECK;
desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=AssignExpr;
el_def=0;
};
init_code {
name=;
el_typ=MethodCall;
el_def=0;
AssignExpr @[0] {
desc="get the epoch timer from current network";
flags=;
result_var=.projects[0].programs.gp[0][14].vars[2]$113$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[1] {
desc="set data and network on NetMonitor object";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][14].vars[1]$114$;
method=NetMonitor::SetDataNetwork;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=DataTable_ptr;
type="DataTable*";
name="dt";
required=0;
def_val=;
expr {
expr="epoch_mon_data";
var_expr="$#0#$";
vars {
};
var_names{ epoch_mon_data;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network_ptr;
type="Network*";
name="net";
required=0;
def_val=;
expr {
expr="network";
var_expr="$#0#$";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
};
};
MethodCall @[2] {
desc="check configuration and emit errors/warnings for problems";
flags=;
result_var=NULL;
obj=$114$;
method=taBase::CheckConfig;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="quiet";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[3] {
desc="update the monitor items and data schema based on current settings of NetMonitor";
flags=;
result_var=NULL;
obj=$114$;
method=NetMonitor::UpdateMonitors;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=bool;
type="bool";
name="reset_first";
required=0;
def_val="false";
expr {
expr="true";
var_expr="true";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
MethodCall @[0] {
desc="add a new blank row to the data";
flags=;
result_var=NULL;
obj=.projects[0].programs.gp[0][14].vars[0]$115$;
method=DataTable::AddBlankRow;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
MethodCall @[1] {
desc="get the new monitor data and stor it into the data table -- this does the main job here";
flags=;
result_var=NULL;
obj=$114$;
method=NetMonitor::GetMonVals;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
AssignExpr @[2] {
desc="get the epoch timer from current network";
flags=;
result_var=$113$;
expr {
expr="network.epoch_time";
var_expr="$#0#$.epoch_time";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
MethodCall @[3] {
desc="update after writing new data to monitor data table";
flags=;
result_var=NULL;
obj=$115$;
method=DataBlock::WriteClose;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
};
};
};
};
Program @[15] {
name="SaveWeights";
tags="Network, Weights";
desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
flags=;
objs {
name=;
el_typ=taOBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=Network;
object_val=NULL;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="tag";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="user-provided tag (startup script will set this!)";
};
ProgVar @[1] {
name="wts_subdir";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="user-provided subdirectory to save weights in";
};
ProgVar @[2] {
name="fname";
var_type=T_String;
string_val=;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="final generated file name -- do not edit!";
};
ProgVar @[3] {
name="epoch_str";
var_type=T_String;
string_val="0036";
objs_ptr=0;
flags=NULL_CHECK;
desc="string rep of epoch with leading zeros";
};
ProgVar @[4] {
name="batch_str";
var_type=T_String;
string_val="03";
objs_ptr=0;
flags=NULL_CHECK;
desc="string rep of batch with leading zeros";
};
ProgVar @[5] {
name="final_tag";
var_type=T_String;
string_val=".03_0036";
objs_ptr=0;
flags=NULL_CHECK;
desc="batch + epoch";
};
};
functions {
name=;
el_typ=ProgEl;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=MethodCall;
el_def=0;
IfReturn @[0] {
desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
flags=;
cond {
expr="taMisc::dmem_proc > 0";
var_expr="taMisc::dmem_proc > 0";
vars {
};
var_names{ };
bad_vars{ };
};
};
MiscCall @[1] {
desc="get current batch counter for file name, with leading zeros to length 3";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[4]$116$;
object_type=taMisc;
method=taMisc::LeadingZeros;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=int;
type="int";
name="num";
required=0;
def_val=;
expr {
expr="network.batch";
var_expr="$#0#$.batch";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="len";
required=0;
def_val=;
expr {
expr="2";
var_expr="2";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MiscCall @[2] {
desc="get current epoch counter with leading zeros to length 4";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[3]$117$;
object_type=taMisc;
method=taMisc::LeadingZeros;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=int;
type="int";
name="num";
required=0;
def_val=;
expr {
expr="network.epoch";
var_expr="$#0#$.epoch";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=int;
type="int";
name="len";
required=0;
def_val=;
expr {
expr="4";
var_expr="4";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
AssignExpr @[3] {
desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[5]$118$;
expr {
expr="tag + \".\" + batch_str + \"_\" + epoch_str";
var_expr="$#0#$ + \".\" + $#1#$ + \"_\" + $#2#$";
vars {
};
var_names{ tag;batch_str;epoch_str;};
bad_vars{ };
};
};
MethodCall @[4] {
desc="get a file name based on the project's current file name, for saving the weights";
flags=;
result_var=.projects[0].programs.gp[0][15].vars[2]$119$;
obj=.projects[0].programs.gp[0][15].args[0]$120$;
method=taBase::GetFileNameFmProject;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="ext";
required=1;
def_val=;
expr {
expr="\".wts.gz\"";
var_expr="\".wts.gz\"";
vars {
};
var_names{ };
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=const_taString_ref;
type="const taString&";
name="tag";
required=0;
def_val="\"\"";
expr {
expr="final_tag";
var_expr="$#0#$";
vars {
};
var_names{ final_tag;};
bad_vars{ };
};
};
ProgArg @[2] {
arg_type=const_taString_ref;
type="const taString&";
name="subdir";
required=0;
def_val="\"\"";
expr {
expr="wts_subdir";
var_expr="$#0#$";
vars {
};
var_names{ wts_subdir;};
bad_vars{ };
};
};
ProgArg @[3] {
arg_type=bool;
type="bool";
name="dmem_proc_no";
required=0;
def_val="false";
expr {
expr="false";
var_expr="false";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
MethodCall @[5] {
desc="save the weights to that file name";
flags=;
result_var=NULL;
obj=$120$;
method=Network::SaveWeights;
meth_args {
name=;
el_typ=ProgArg;
el_def=0;
ProgArg @[0] {
arg_type=const_taString_ref;
type="const taString&";
name="fname";
required=0;
def_val="\"\"";
expr {
expr="fname";
var_expr="$#0#$";
vars {
};
var_names{ fname;};
bad_vars{ };
};
};
ProgArg @[1] {
arg_type=Network::WtSaveFormat;
type="Network::WtSaveFormat";
name="fmt";
required=0;
def_val="Network::NET_FMT";
expr {
expr="Network::NET_FMT";
var_expr="Network::NET_FMT";
vars {
};
var_names{ };
bad_vars{ };
};
};
};
};
};
};
Program @[16] {
name="DA_Rew_Punish";
tags=;
desc=;
flags=;
objs {
name=;
el_typ=taNBase;
el_def=0;
};
types {
name=;
el_typ=ProgType;
el_def=0;
};
args {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="network";
var_type=T_Object;
object_type=LeabraNetwork;
object_val=$8$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="network to train";
};
ProgVar @[1] {
name="input_data";
var_type=T_Object;
object_type=DataTable;
object_val=$9$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc="datatable with training patterns";
};
};
vars {
name=;
el_typ=ProgVar;
el_def=0;
ProgVar @[0] {
name="num_intact_snc_units";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[1] {
name="snc_size";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[2] {
name="k";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[3] {
name="sse";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[4] {
name="act0";
var_type=T_Real;
real_val=0.2854880392551422;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[5] {
name="act1";
var_type=T_Real;
real_val=0.3291127383708954;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[6] {
name="SNc";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$33$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[7] {
name="Output";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$97$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[8] {
name="Motor_Cortex";
var_type=T_Object;
object_type=LeabraLayer;
object_val=$103$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[9] {
name="matrisom_unitspec";
var_type=T_Object;
object_type=LeabraUnitSpec;
object_val=$35$;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[10] {
name="i";
var_type=T_Int;
int_val=4;
objs_ptr=0;
flags=NULL_CHECK;
desc=;
};
ProgVar @[11] {
name="tonic_DA";
var_type=T_Real;
real_val=0.03;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[12] {
name="op_sse";
var_type=T_Int;
int_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[13] {
name="DA_dip_val";
var_type=T_Real;
real_val=0;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
ProgVar @[14] {
name="DA_burst_val";
var_type=T_Real;
real_val=1;
objs_ptr=0;
flags=CTRL_PANEL|NULL_CHECK;
desc=;
};
};
functions {
name=;
el_typ=Function;
el_def=0;
};
load_code {
name=;
el_typ=ProgEl;
el_def=0;
};
init_code {
name=;
el_typ=ProgEl;
el_def=0;
};
prog_code {
name=;
el_typ=ProgEl;
el_def=0;
AssignExpr @[0] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[1]$121$;
expr {
expr="SNc.units.size";
var_expr="$#0#$.units.size";
vars {
};
var_names{ SNc;};
bad_vars{ };
};
};
AssignExpr @[1] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[2]$122$;
expr {
expr="(float)num_intact_snc_units/ snc_size";
var_expr="(float)$#0#$/ $#1#$";
vars {
};
var_names{ num_intact_snc_units;snc_size;};
bad_vars{ };
};
};
AssignExpr @[2] {
desc=;
flags=;
result_var=.projects[0].programs.gp[0][16].vars[3]$123$;
expr {
expr="network.sse";
var_expr="$#0#$.sse";
vars {
};
var_names{ network;};
bad_vars{ };
};
};
IfElse @[3] {
desc="apply phasic DA in plus phase";
flags=;
cond {
expr="network.phase==LeabraNetwork::PLUS_PHASE";
var_expr="$#0#$.phase==LeabraNetwork::PLUS_PHASE";
vars {
};
var_names{ network;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
IfElse @[0] {
desc="if error is  below threshold, given DA burst";
flags=;
cond {
expr="k>0&&Output.sse<0.5";
var_expr="$#0#$>0&&$#1#$.sse<0.5";
vars {
};
var_names{ k;Output;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set external input on SNC to high value for DA burst";
flags=;
obj=.projects[0].programs.gp[0][16].vars[6]$124$;
path="units[i].ext";
expr {
expr="DA_burst_val";
var_expr="$#0#$";
vars {
};
var_names{ DA_burst_val;};
bad_vars{ };
};
update_after=0;
};
};
init {
expr="i = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ i;};
bad_vars{ };
};
test {
expr="i < snc_size";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
MemberAssign @[1] {
desc="set striatal gain in proportion to DA and # intact Snc units";
flags=;
obj=.projects[0].programs.gp[0][16].vars[9]$125$;
path="act.gain";
expr {
expr="k*10000";
var_expr="$#0#$*10000";
vars {
};
var_names{ k;};
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc=;
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set DA units to 0 for DA dip";
flags=;
obj=$124$;
path="units[i].ext";
expr {
expr="DA_dip_val";
var_expr="$#0#$";
vars {
};
var_names{ DA_dip_val;};
bad_vars{ };
};
update_after=0;
};
};
init {
expr="i = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ i;};
bad_vars{ };
};
test {
expr="i < snc_size";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
MemberAssign @[1] {
desc="set striatal gain to be lower for DA dip (less D1 contrast enhancement)";
flags=;
obj=$125$;
path="act.gain";
expr {
expr="600-k*300";
var_expr="600-$#0#$*300";
vars {
};
var_names{ k;};
bad_vars{ };
};
update_after=0;
};
};
};
AssignExpr @[1] {
desc="store minus phase activation of motor ctx unit 0";
flags=;
result_var=.projects[0].programs.gp[0][16].vars[4]$126$;
expr {
expr="Motor_Cortex.units[0].act_m";
var_expr="$#0#$.units[0].act_m";
vars {
};
var_names{ Motor_Cortex;};
bad_vars{ };
};
};
AssignExpr @[2] {
desc="store minus phase act of motor unit 1";
flags=;
result_var=.projects[0].programs.gp[0][16].vars[5]$127$;
expr {
expr="Motor_Cortex.units[1].act_m";
var_expr="$#0#$.units[1].act_m";
vars {
};
var_names{ Motor_Cortex;};
bad_vars{ };
};
};
IfElse @[3] {
desc="if model selected R1";
flags=;
cond {
expr="act0>act1";
var_expr="$#0#$>$#1#$";
vars {
};
var_names{ act0;act1;};
bad_vars{ };
};
true_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=.projects[0].programs.gp[0][16].vars[8]$128$;
path="units[0].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[1] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$128$;
path="units[1].ext";
expr {
expr="0.0";
var_expr="0.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[2] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$128$;
path="units[2].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[3] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$128$;
path="units[3].ext";
expr {
expr="0";
var_expr="0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$128$;
path="units[0].ext";
expr {
expr="0";
var_expr="0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[1] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$128$;
path="units[1].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[2] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$128$;
path="units[2].ext";
expr {
expr="0";
var_expr="0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
MemberAssign @[3] {
desc="set plus phase acts to reflect minus phase response";
flags=;
obj=$128$;
path="units[3].ext";
expr {
expr="1.0";
var_expr="1.0";
vars {
};
var_names{ };
bad_vars{ };
};
update_after=0;
};
};
};
};
false_code {
name=;
el_typ=ProgEl;
el_def=0;
ForLoop @[0] {
desc="loop over snc units";
flags=;
loop_code {
name=;
el_typ=ProgEl;
el_def=0;
MemberAssign @[0] {
desc="set tonic DA val";
flags=;
obj=$124$;
path="units[i].ext";
expr {
expr="tonic_DA";
var_expr="$#0#$";
vars {
};
var_names{ tonic_DA;};
bad_vars{ };
};
update_after=0;
};
MemberAssign @[1] {
desc="set striatal gain in proportion to DA and # intact Snc units";
flags=;
obj=$125$;
path="act.gain";
expr {
expr="k*2500";
var_expr="$#0#$*2500";
vars {
};
var_names{ k;};
bad_vars{ };
};
update_after=0;
};
};
init {
expr="i = 0";
var_expr="$#0#$ = 0";
vars {
};
var_names{ i;};
bad_vars{ };
};
test {
expr="i < snc_size";
var_expr="$#0#$ < $#1#$";
vars {
};
var_names{ i;snc_size;};
bad_vars{ };
};
iter {
expr="i++";
var_expr="$#0#$++";
vars {
};
var_names{ i;};
bad_vars{ };
};
};
};
};
};
};
};
};
viewers {
name=;
el_typ=TopLevelViewer;
el_def=0;
MainWindowViewer @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_lft";
value 6 0=0;
};
UserDataItem @[1] {
name="view_win_top";
value 6 0=0;
};
UserDataItem @[2] {
name="view_win_wd";
value 6 0=1;
};
UserDataItem @[3] {
name="view_win_ht";
value 6 0=0.8306772708892822;
};
UserDataItem @[4] {
name="view_win_iconified";
value 1 0=0;
};
UserDataItem @[5] {
name="view_splitter_state";
value 9 0="AAAA/wAAAAAAAAADAAAAyQAAAhIAAANBAQAAAAYBAAAAAQ==";
};
};
m_data=.projects[0]$129$;
name="Browser";
visible=1;
m_is_root=0;
m_is_viewer_xor_browser=0;
m_is_proj_viewer=1;
m_is_dialog=0;
toolbars {
name=;
el_typ=ToolBar;
el_def=0;
ToolBar @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_visible";
value 1 0=1;
};
};
m_data=NULL;
name="Application";
visible=0;
lft=0;
top=0.03087649;
o=Horizontal;
};
};
frames {
name=;
el_typ=FrameViewer;
el_def=0;
tabBrowseViewer @[0] {
m_data=NULL;
name="Tree";
visible=1;
root_typ=LeabraProject;
root_md=NULL;
m_root=$129$;
};
PanelViewer @[1] {
m_data=NULL;
name="Panels";
visible=1;
};
T3DataViewer @[2] {
m_data=NULL;
name="T3Frames";
visible=1;
frames {
name=;
el_typ=T3DataViewFrame;
el_def=0;
T3DataViewFrame @[0] {
m_data=NULL;
name="Frame2";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
NetView @[0] {
m_data=$8$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
lay_disp_modes{ Input=0;Striatum=0;SNc=0;GP_Int=0;GP_Ext=0;Thalamus=0;Motor_Cortex=0;Output=0;STN=0;};
scale {
name="ColorScale";
chunks=133;
min=-0;
max=0;
range=0;
zero=0;
spec=.colorspecs[0]$130$;
auto_scale=1;
};
scale_ranges {
name=;
el_typ=ScaleRange;
el_def=0;
ScaleRange @[0] {
name="act";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[1] {
name="r.wt";
auto_scale=1;
min=-0;
max=0;
};
ScaleRange @[2] {
name="v_m";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[3] {
name="I_net";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[4] {
name="gc.a";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[5] {
name="gc.h";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[6] {
name="gc.i";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[7] {
name="gc.l";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[8] {
name="vcb.acc";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[9] {
name="vcb.hyst";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[10] {
name="da";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[11] {
name="act_dif";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[12] {
name="act_p";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[13] {
name="act_m";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[14] {
name="act_avg";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[15] {
name="act_eq";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[16] {
name="wt_prjn";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[17] {
name="net";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[18] {
name="ext";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[19] {
name="targ";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[20] {
name="bias.pdw";
auto_scale=0;
min=-1;
max=1;
};
ScaleRange @[21] {
name="bias.wt";
auto_scale=0;
min=-1;
max=1;
};
};
display=0;
lay_mv=1;
ordered_uvg_list{ r.wt;};
unit_disp_mode=UDM_CYLINDER;
unit_text_disp=UTD_NONE;
max_size {x=14: y=9: z=3: };
font_sizes {
net_name=0.05;
net_vals=0.05;
layer=0.04;
layer_vals=0.03;
prjn=0.01;
unit=0.02;
un_nm_len=3;
};
view_params {
xy_square=0;
unit_spacing=0.05;
prjn_disp=L_R_F;
prjn_name=0;
prjn_width=0.002;
prjn_trans=0.5;
lay_trans=0.5;
unit_trans=0.6;
};
wt_line_disp=0;
wt_line_width=4;
wt_line_thr=0.5;
wt_line_swt=0;
wt_prjn_lay=NULL;
};
};
};
camera_pos {x=0.601324: y=0.6189932: z=1.452952: };
camera_orient {x=-0.7751102: y=0.5152406: z=0.3656991: rot=0.1340278: };
camera_focdist=1.876728;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[1] {
m_data=NULL;
name="CycleOutputData";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=$107$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[1][2].data[0]$131$;
m_transform=NULL;
name="batch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[1][2].data[1]$132$;
m_transform=NULL;
name="epoch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[1][2].data[2]$133$;
m_transform=NULL;
name="trial";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[1][2].data[3]$134$;
m_transform=NULL;
name="trial_name";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[1][2].data[4]$135$;
m_transform=NULL;
name="group_name";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[1][2].data[5]$136$;
m_transform=NULL;
name="phase_no";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[6] {
m_data=.projects[0].data.gp[1][2].data[6]$137$;
m_transform=NULL;
name="cycle";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[7] {
m_data=.projects[0].data.gp[1][2].data[7]$138$;
m_transform=NULL;
name="sse";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[8] {
m_data=.projects[0].data.gp[1][2].data[8]$139$;
m_transform=NULL;
name="ext_rew";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[9] {
m_data=.projects[0].data.gp[1][2].data[9]$140$;
m_transform=NULL;
name="STN_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[10] {
m_data=.projects[0].data.gp[1][2].data[10]$141$;
m_transform=NULL;
name="Motor__acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[11] {
m_data=.projects[0].data.gp[1][2].data[11]$142$;
m_transform=NULL;
name="Thalam_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[12] {
m_data=.projects[0].data.gp[1][2].data[12]$143$;
m_transform=NULL;
name="GP_Int_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[13] {
m_data=.projects[0].data.gp[1][2].data[13]$144$;
m_transform=NULL;
name="GP_Ext_acts_avg";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[14] {
m_data=.projects[0].data.gp[1][2].data[14]$145$;
m_transform=NULL;
name="Output_act";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[15] {
m_data=.projects[0].data.gp[1][2].data[15]$146$;
m_transform=NULL;
name="Output_units_0_act";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=-1: };
display_on=0;
manip_ctrl_on=1;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="cycle";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name="batch";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="STN_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=-6e-07: max=6e-07: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="Motor__acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="GP_Int_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="GP_Ext_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="green": r=0: g=1: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name="Thalam_acts_avg";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
};
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
graph_type=XY;
plot_style=LINE;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
color_mode=VALUE_COLOR;
negative_draw=0;
axis_font_size=0.05;
label_font_size=0.04;
label_spacing=-1;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
err_1 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_spacing=1;
err_bar_width=0.02;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$130$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
width=1;
depth=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.37625: y=0.4125: z=1.389598: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=1.899598;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[2] {
m_data=NULL;
name="EpochOutputData";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=$12$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[1][1].data[0]$147$;
m_transform=NULL;
name="batch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[1][1].data[1]$148$;
m_transform=NULL;
name="epoch";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=40: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[1][1].data[2]$149$;
m_transform=NULL;
name="avg_sse";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[3] {
m_data=.projects[0].data.gp[1][1].data[3]$150$;
m_transform=NULL;
name="cnt_err";
visible=1;
fixed_range {fix_min=1: min=0: fix_max=0: max=2: };
data_range {min=0: max=0: };
};
GraphColView @[4] {
m_data=.projects[0].data.gp[1][1].data[4]$151$;
m_transform=NULL;
name="avg_ext_rew";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[5] {
m_data=.projects[0].data.gp[1][1].data[5]$152$;
m_transform=NULL;
name="avg_cycles";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=0: };
display_on=1;
manip_ctrl_on=1;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="epoch";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=-6e-07: max=6e-07: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name="batch";
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="cnt_err";
fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
};
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
graph_type=XY;
plot_style=LINE;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
color_mode=VALUE_COLOR;
negative_draw=0;
axis_font_size=0.05;
label_font_size=0.04;
label_spacing=-1;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
err_1 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_spacing=1;
err_bar_width=0.02;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$130$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
width=1;
depth=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.4595: y=0.4778185: z=2.009545: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=2.499545;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
T3DataViewFrame @[3] {
m_data=NULL;
name="EpochOutputData_Group";
visible=1;
root_view {
m_data=NULL;
m_transform=NULL;
children {
name=;
el_typ=T3DataView;
el_def=0;
GraphTableView @[0] {
m_data=.projects[0].data.gp[2][0]$153$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
children {
name=;
el_typ=GraphColView;
el_def=0;
GraphColView @[0] {
m_data=.projects[0].data.gp[2][0].data[0]$154$;
m_transform=NULL;
name="epoch_group";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=40: };
data_range {min=0: max=0: };
};
GraphColView @[1] {
m_data=.projects[0].data.gp[2][0].data[1]$155$;
m_transform=NULL;
name="cnt_err_mean";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
GraphColView @[2] {
m_data=.projects[0].data.gp[2][0].data[2]$156$;
m_transform=NULL;
name="cnt_err_sem";
visible=1;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
data_range {min=0: max=0: };
};
};
main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
view_rows=10000;
view_range {min=0: max=40: };
display_on=1;
manip_ctrl_on=1;
x_axis {
m_data=NULL;
m_transform=NULL;
on=1;
axis=X;
col_name="epoch_group";
fixed_range {fix_min=0: min=0: fix_max=0: max=40: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=40: };
range {min=0: max=40: };
n_ticks=10;
axis_length=1;
row_num=0;
};
z_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Z;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
plot_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="cnt_err_mean";
fixed_range {fix_min=0: min=0.1: fix_max=0: max=1.8: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0.1: max=1.8: };
range {min=0.1: max=1.8: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
plot_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="red": r=1: g=0: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=SQUARE;
};
plot_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="blue": r=0: g=0: b=1: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=DIAMOND;
};
plot_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=TRIANGLE;
};
plot_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
data_range {min=0: max=1: };
range {min=0: max=1: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=PLUS;
};
alt_y_2=0;
alt_y_3=0;
alt_y_4=0;
alt_y_5=0;
graph_type=XY;
plot_style=LINE;
line_width=2;
point_size=MEDIUM;
point_spacing=1;
bar_space=0.2;
color_mode=FIXED_COLOR;
negative_draw=0;
axis_font_size=0.05;
label_font_size=0.04;
label_spacing=-1;
matrix_mode=SEP_GRAPHS;
mat_layout=BOT_ZERO;
mat_odd_vert=1;
err_1 {
m_data=NULL;
m_transform=NULL;
on=1;
axis=Y;
col_name="cnt_err_sem";
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_2 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_3 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_4 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_5 {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
line_style=SOLID;
point_style=CIRCLE;
};
err_spacing=1;
err_bar_width=0.02;
color_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
colorscale {
name="ColorScale";
chunks=133;
min=-1;
max=1;
range=0;
zero=0;
spec=$130$;
auto_scale=0;
};
raster_axis {
m_data=NULL;
m_transform=NULL;
on=0;
axis=Y;
col_name=;
fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
color {name="black": r=0: g=0: b=0: a=1: desc="": };
data_range {min=0: max=0: };
range {min=0: max=0: };
n_ticks=10;
axis_length=1;
row_num=0;
};
thresh=0.5;
thr_line_len=0.48;
width=1;
depth=1;
two_d_font=0;
two_d_font_scale=350;
};
};
};
camera_pos {x=1.428125: y=0.445: z=1.625331: };
camera_orient {x=0: y=0: z=1: rot=0: };
camera_focdist=1.637831;
bg_color {r=0.8: g=0.8: b=0.8: a=1: };
};
};
};
};
docks {
name=;
el_typ=DockViewer;
el_def=0;
ToolBoxDockViewer @[0] {
UserDataItem_List @*(.user_data_) {
name=;
el_typ=UserDataItemBase;
el_def=0;
UserDataItem @[0] {
name="view_win_lft";
value 6 0=0;
};
UserDataItem @[1] {
name="view_win_top";
value 6 0=0.06474103778600693;
};
UserDataItem @[2] {
name="view_win_wd";
value 6 0=0.0535714291036129;
};
UserDataItem @[3] {
name="view_win_ht";
value 6 0=0.7131474018096924;
};
UserDataItem @[4] {
name="view_win_iconified";
value 1 0=0;
};
UserDataItem @[5] {
name="view_visible";
value 1 0=1;
};
};
m_data=NULL;
name="Tools";
visible=1;
dock_flags=DV_MOVABLE|DV_FLOATABLE;
dock_area=1;
};
};
};
};
use_change_log=0;
last_change_desc="
";
networks {
name=;
el_typ=LeabraNetwork;
el_def=0;
LeabraNetwork @[0] {
name="BGNet";
desc=;
specs {
name=;
el_typ=ConSpec;
el_def=0;
ConSpec @[0] {
name="ConSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=ConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0: var=0.5: par=1: };
wt_limits {type=NONE: min=-1: max=1: sym=0: };
};
UniformRndPrjnSpec @[1] {
name="STN_GPe_RndPrjnSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=UniformRndPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
p_con=1;
sym_self=1;
same_seed=0;
rndm_seed {
name=;
seed{ 1942590695;1834211083;377798523;839440218;-583226373;705799995;-1978402924;1154338458;-462115379;246653898;1399794034;-1499780727;-1523899271;930991332;1290781086;1827104268;-716397506;1983718083;1167094774;951783845;-409479048;-735831888;435869947;-904086293;2026496515;403361634;-1944445990;-1372202487;2126959386;162557442;1012427038;1588232218;-1146450552;-853562653;-1656209805;-1888253373;1759765356;1728652414;-337014879;-1280803374;-575509963;-1765188122;-384524531;-821312351;-1870977276;1513531657;1301908149;699607679;871722190;941230124;480719736;-879564786;-698046303;1521335322;-1447079851;-716252964;526031609;1993676142;1340787872;1530654116;-969427509;1134915315;2122089688;-994370515;560929468;389650548;-1122373860;166734577;-286623372;-120943880;891391534;1880819345;-178283282;540924398;-472340061;2110112996;-1254638769;1538060551;1673190834;691970619;-959237381;-1357813313;1768507679;-1214978919;785612098;1900739683;2119690407;432529262;1597777345;-76740981;1752989913;507595810;1970077571;2120922148;-975091467;-1195485087;-2116172007;-1448521787;-1611468311;1523616406;1943148525;-1864229143;-937095503;-909740123;1292237191;387974384;538406262;509446046;-1972547268;-1733600336;-62144424;-1546025606;-1876304799;1885604132;1402880751;-482628413;1554473651;267768126;-629382805;-1249311349;-1924387261;1461040170;509667270;-779074633;-17507771;918255996;-143015157;-2090640919;315301152;702021484;808635402;-2068859673;-1347883889;1693940293;1805057885;-1668427604;-2137413199;-1104482850;208495526;118430790;-722180698;-1217415633;-224256734;1932248267;-1065779137;-10863097;487580081;-196290919;680669227;1979774005;-2037050706;21949689;-156516075;1715173136;1755205487;1472371560;1309034448;-829238765;-135616049;-2013309212;-1082863329;-899363014;-1287869739;-870456151;581622390;-1908234714;-1126900746;764733716;-925858573;-1751091051;-463341148;644681747;-1914494877;373038127;1588478313;1485299105;661291536;-1180395328;-1144161539;94598643;-1088175949;1032986199;-1100837220;407686955;-1082470443;1911682705;1627415103;310787166;1264015414;424266369;-2027001547;-1752167701;-228113290;1600850810;-2083186300;-1987228633;2000848866;-1395386373;80656148;317238254;-1145747623;-511425939;1346724944;180295410;-544883384;1732680478;-1525854862;236088797;1630557266;1645104332;445726791;1077576696;-2008807651;-2004400849;1274587809;1448655060;1550063216;454064067;-221087611;-594550512;-1272829249;1417249337;463284529;432100395;1078285484;-959540334;21248325;-866258652;-1081481128;-1833368508;-1379133116;-1920337657;-1251994147;1350814969;1508926409;1457463506;-436457777;-104638987;-300707471;-917721278;-620891785;523732153;445406412;1634813528;463926328;1581054136;170598643;-416905380;-1864557289;-202014810;1443533836;-1579728646;-1569783365;398032325;603645793;1459091613;-89353942;-1032688516;-1615894428;-767185823;-1946032362;931360128;-836341533;-1238311242;26872554;-1198342849;223875202;1787898723;1347039535;1426899535;712166878;1007370589;-2121265931;1279068215;1048275580;665564878;-854576448;1115606454;-1938871068;437377701;1893989311;60057612;-1411480578;-1802660403;-1229197402;-1114162509;1246510289;-100045555;-771237462;-321537560;1645429527;876081854;-344012824;613155858;-58817405;150811542;-10210852;2112860797;-528954460;-50850354;-649972970;1499955930;1421666445;1351215729;-1262602010;-980699257;1941355339;-961944897;-413046848;-411502877;522743470;-1432644237;-1120760559;-776500101;-1809149014;2127519490;470896056;662683123;-567303983;121758873;-1581863489;-91906121;-996490915;1435662432;1657906168;-1808273636;-1008367748;1370467542;775127407;336430775;908983458;-1287820551;2018562582;684733517;1364159782;839309547;1634308483;-497817377;118348535;-1269053010;955697418;-461911650;286131813;-300370221;1037538534;2023161463;-259022712;-1784489335;970316778;1578200481;500283714;1165730615;1099858613;850929875;-122366113;1415506233;-119359212;-2033313111;2063284557;168272506;1014246244;1972611072;1049837341;2120277277;-1358473916;867839429;1548671628;375995816;335745466;-92761852;-1313606594;983851877;957484913;-786771928;1174167013;457619777;1577173252;29408666;-1853196004;-954511750;-9741238;1764765760;-1106091459;418868525;1218646124;244543749;1280742435;-1669454769;1391623016;-1782787888;1672996012;-660347923;1734104018;-70130822;-1181208948;-285723476;-1959961034;42073851;-1354695576;-548612189;-692983842;1398992433;-1954474622;-414265610;1827986420;-1740813210;392408431;812967600;306150025;1150550306;-1577525793;522329421;-1905599679;1183746118;1873227418;113271279;-118624832;2064640613;91279896;-1296994070;923686864;-1237563925;-671532219;432504743;376157897;-1964026811;-509307951;-1291095292;-92298376;-440266966;742491999;-363297213;907719292;-2097711796;-72292200;797405338;-902353499;-166246906;-943459407;-1618209704;296966888;276718739;881687730;-63517562;-481360418;-1200473828;-144528583;2055425204;425514158;-972984629;-437772543;955225817;-1571664087;1255280381;-1520917476;411210494;-1044569805;1196139168;1000345811;314304961;788619297;-1721237341;1855193732;-688848034;-560160224;110451616;205166806;1045130054;606457223;-106064310;-350539693;-1199925658;-1553567608;1827860289;-495518821;-289479856;-1888403873;66174658;-1741606928;-1734480553;1792669379;2112354548;649961546;-1072485902;1950021075;-145032130;-1448841129;-455451267;-1966366114;-1298920795;837046384;-1783493271;1554055716;544335337;-302006934;-149606522;2022999324;826072250;-549276476;1862748770;1989186214;1089115433;956552701;1745621701;-2034815611;614102796;1479888671;-146686913;-690079684;-1114868597;-2016690506;2090920277;-830594320;-1261017876;2072821639;194345641;-1605828714;484660319;-454560202;1794417171;511341824;-1255389158;-669363423;1164033229;-1107097310;828519990;1450362036;476068860;1972265003;-1879752310;1894610209;-2128722743;1301770305;-1624467838;-731973801;-337476939;-1809040191;1525193216;-2001741915;-2027225998;-1162995606;-717541281;2050620663;-1135005089;2015601957;-1661832271;334966618;-236871560;-2075212969;-2141684690;1078043241;1723366617;828122061;147352703;-1999649046;-903143402;-1024430520;1633016716;-1604804280;1647853874;1626223577;613437415;854959232;-1237163556;-230090669;-278438371;1723117265;500023237;-1216412905;1717506101;1373064296;1994723034;1814828511;2067592941;937637146;-1370177392;-1274587966;-48108349;-378201671;1262614325;62390688;164974972;-830307263;-1714046089;1359544797;2016161042;83584009;930716322;-497279679;2023049077;-206104661;1501245447;562523072;104611198;-46372430;298890283;2110698786;-1091302072;20052267;-1304541777;140132249;-1245355586;-727077616;-316829592;152731111;-154344094;1345278005;-558417490;1281066959;-1469762051;-383552934;199222085;413618054;1552260824;-576003758;105415137;2042323739;1646910169;1084993049;840296744;216680633;1409468883;-1555896089;734078106;};
mti=115;
};
};
UniformRndPrjnSpec @[2] {
name="GPe_STN_RndPrjnSpec_1";
desc=;
unique{ };
children {
name=;
el_typ=UniformRndPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
p_con=0.4;
sym_self=1;
same_seed=0;
rndm_seed {
name=;
seed{ 1942590695;1834211083;377798523;839440218;-583226373;705799995;-1978402924;1154338458;-462115379;246653898;1399794034;-1499780727;-1523899271;930991332;1290781086;1827104268;-716397506;1983718083;1167094774;951783845;-409479048;-735831888;435869947;-904086293;2026496515;403361634;-1944445990;-1372202487;2126959386;162557442;1012427038;1588232218;-1146450552;-853562653;-1656209805;-1888253373;1759765356;1728652414;-337014879;-1280803374;-575509963;-1765188122;-384524531;-821312351;-1870977276;1513531657;1301908149;699607679;871722190;941230124;480719736;-879564786;-698046303;1521335322;-1447079851;-716252964;526031609;1993676142;1340787872;1530654116;-969427509;1134915315;2122089688;-994370515;560929468;389650548;-1122373860;166734577;-286623372;-120943880;891391534;1880819345;-178283282;540924398;-472340061;2110112996;-1254638769;1538060551;1673190834;691970619;-959237381;-1357813313;1768507679;-1214978919;785612098;1900739683;2119690407;432529262;1597777345;-76740981;1752989913;507595810;1970077571;2120922148;-975091467;-1195485087;-2116172007;-1448521787;-1611468311;1523616406;1943148525;-1864229143;-937095503;-909740123;1292237191;387974384;538406262;509446046;-1972547268;-1733600336;-62144424;-1546025606;-1876304799;1885604132;1402880751;-482628413;1554473651;267768126;-629382805;-1249311349;-1924387261;1461040170;509667270;-779074633;-17507771;918255996;-143015157;-2090640919;315301152;702021484;808635402;-2068859673;-1347883889;1693940293;1805057885;-1668427604;-2137413199;-1104482850;208495526;118430790;-722180698;-1217415633;-224256734;1932248267;-1065779137;-10863097;487580081;-196290919;680669227;1979774005;-2037050706;21949689;-156516075;1715173136;1755205487;1472371560;1309034448;-829238765;-135616049;-2013309212;-1082863329;-899363014;-1287869739;-870456151;581622390;-1908234714;-1126900746;764733716;-925858573;-1751091051;-463341148;644681747;-1914494877;373038127;1588478313;1485299105;661291536;-1180395328;-1144161539;94598643;-1088175949;1032986199;-1100837220;407686955;-1082470443;1911682705;1627415103;310787166;1264015414;424266369;-2027001547;-1752167701;-228113290;1600850810;-2083186300;-1987228633;2000848866;-1395386373;80656148;317238254;-1145747623;-511425939;1346724944;180295410;-544883384;1732680478;-1525854862;236088797;1630557266;1645104332;445726791;1077576696;-2008807651;-2004400849;1274587809;1448655060;1550063216;454064067;-221087611;-594550512;-1272829249;1417249337;463284529;432100395;1078285484;-959540334;21248325;-866258652;-1081481128;-1833368508;-1379133116;-1920337657;-1251994147;1350814969;1508926409;1457463506;-436457777;-104638987;-300707471;-917721278;-620891785;523732153;445406412;1634813528;463926328;1581054136;170598643;-416905380;-1864557289;-202014810;1443533836;-1579728646;-1569783365;398032325;603645793;1459091613;-89353942;-1032688516;-1615894428;-767185823;-1946032362;931360128;-836341533;-1238311242;26872554;-1198342849;223875202;1787898723;1347039535;1426899535;712166878;1007370589;-2121265931;1279068215;1048275580;665564878;-854576448;1115606454;-1938871068;437377701;1893989311;60057612;-1411480578;-1802660403;-1229197402;-1114162509;1246510289;-100045555;-771237462;-321537560;1645429527;876081854;-344012824;613155858;-58817405;150811542;-10210852;2112860797;-528954460;-50850354;-649972970;1499955930;1421666445;1351215729;-1262602010;-980699257;1941355339;-961944897;-413046848;-411502877;522743470;-1432644237;-1120760559;-776500101;-1809149014;2127519490;470896056;662683123;-567303983;121758873;-1581863489;-91906121;-996490915;1435662432;1657906168;-1808273636;-1008367748;1370467542;775127407;336430775;908983458;-1287820551;2018562582;684733517;1364159782;839309547;1634308483;-497817377;118348535;-1269053010;955697418;-461911650;286131813;-300370221;1037538534;2023161463;-259022712;-1784489335;970316778;1578200481;500283714;1165730615;1099858613;850929875;-122366113;1415506233;-119359212;-2033313111;2063284557;168272506;1014246244;1972611072;1049837341;2120277277;-1358473916;867839429;1548671628;375995816;335745466;-92761852;-1313606594;983851877;957484913;-786771928;1174167013;457619777;1577173252;29408666;-1853196004;-954511750;-9741238;1764765760;-1106091459;418868525;1218646124;244543749;1280742435;-1669454769;1391623016;-1782787888;1672996012;-660347923;1734104018;-70130822;-1181208948;-285723476;-1959961034;42073851;-1354695576;-548612189;-692983842;1398992433;-1954474622;-414265610;1827986420;-1740813210;392408431;812967600;306150025;1150550306;-1577525793;522329421;-1905599679;1183746118;1873227418;113271279;-118624832;2064640613;91279896;-1296994070;923686864;-1237563925;-671532219;432504743;376157897;-1964026811;-509307951;-1291095292;-92298376;-440266966;742491999;-363297213;907719292;-2097711796;-72292200;797405338;-902353499;-166246906;-943459407;-1618209704;296966888;276718739;881687730;-63517562;-481360418;-1200473828;-144528583;2055425204;425514158;-972984629;-437772543;955225817;-1571664087;1255280381;-1520917476;411210494;-1044569805;1196139168;1000345811;314304961;788619297;-1721237341;1855193732;-688848034;-560160224;110451616;205166806;1045130054;606457223;-106064310;-350539693;-1199925658;-1553567608;1827860289;-495518821;-289479856;-1888403873;66174658;-1741606928;-1734480553;1792669379;2112354548;649961546;-1072485902;1950021075;-145032130;-1448841129;-455451267;-1966366114;-1298920795;837046384;-1783493271;1554055716;544335337;-302006934;-149606522;2022999324;826072250;-549276476;1862748770;1989186214;1089115433;956552701;1745621701;-2034815611;614102796;1479888671;-146686913;-690079684;-1114868597;-2016690506;2090920277;-830594320;-1261017876;2072821639;194345641;-1605828714;484660319;-454560202;1794417171;511341824;-1255389158;-669363423;1164033229;-1107097310;828519990;1450362036;476068860;1972265003;-1879752310;1894610209;-2128722743;1301770305;-1624467838;-731973801;-337476939;-1809040191;1525193216;-2001741915;-2027225998;-1162995606;-717541281;2050620663;-1135005089;2015601957;-1661832271;334966618;-236871560;-2075212969;-2141684690;1078043241;1723366617;828122061;147352703;-1999649046;-903143402;-1024430520;1633016716;-1604804280;1647853874;1626223577;613437415;854959232;-1237163556;-230090669;-278438371;1723117265;500023237;-1216412905;1717506101;1373064296;1994723034;1814828511;2067592941;937637146;-1370177392;-1274587966;-48108349;-378201671;1262614325;62390688;164974972;-830307263;-1714046089;1359544797;2016161042;83584009;930716322;-497279679;2023049077;-206104661;1501245447;562523072;104611198;-46372430;298890283;2110698786;-1091302072;20052267;-1304541777;140132249;-1245355586;-727077616;-316829592;152731111;-154344094;1345278005;-558417490;1281066959;-1469762051;-383552934;199222085;413618054;1552260824;-576003758;105415137;2042323739;1646910169;1084993049;840296744;216680633;1409468883;-1555896089;734078106;};
mti=115;
};
};
BaseSpec_Group @.gp[0] {
name="LeabraPrjns";
el_typ=LeabraUnitSpec;
el_def=0;
FullPrjnSpec @[0] {
name="FullPrjnSpec_0";
desc=;
unique{ };
children {
name=;
el_typ=FullPrjnSpec;
el_def=0;
};
self_con=1;
init_wts=0;
};
OneToOnePrjnSpec @[1] {
name="OneToOne";
desc=;
unique{ self_con;};
children {
name=;
el_typ=OneToOnePrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
n_conns=-1;
recv_start=0;
send_start=0;
};
TesselPrjnSpec @[2] {
name="Striatum_GPext";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
TesselPrjnSpec @[0] {
name="PFC_Act_Deep";
desc=;
unique{ send_scale;};
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=0: };
send_border {x=1: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[12] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[13] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[14] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[15] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[16] {
send_off {x=1: y=8: };
wt_val=1;
};
TessEl @[17] {
send_off {x=1: y=8: };
wt_val=1;
};
};
};
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=1: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
TessEl @[12] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[13] {
send_off {x=1: y=6: };
wt_val=1;
};
TessEl @[14] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[15] {
send_off {x=1: y=7: };
wt_val=1;
};
TessEl @[16] {
send_off {x=1: y=8: };
wt_val=1;
};
TessEl @[17] {
send_off {x=1: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[3] {
name="dMatrosomesGP";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=0;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[5] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=6: };
wt_val=1;
};
TessEl @[7] {
send_off {x=0: y=7: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[4] {
name="SNc_GO";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=2: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
};
};
TesselPrjnSpec @[5] {
name="MotorCortex_Striatum";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
};
};
TesselPrjnSpec @[6] {
name="SNc_NOGO";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=2: y=0: };
recv_n {x=2: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=1: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=1: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[3] {
send_off {x=1: y=1: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[5] {
send_off {x=1: y=2: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[7] {
send_off {x=1: y=3: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[9] {
send_off {x=1: y=4: };
wt_val=1;
};
TessEl @[10] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[11] {
send_off {x=1: y=5: };
wt_val=1;
};
};
};
TesselPrjnSpec @[7] {
name="Striatum_GPInt";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=0: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=5: };
wrap=0;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=1: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
TessEl @[4] {
send_off {x=0: y=4: };
wt_val=1;
};
TessEl @[5] {
send_off {x=0: y=5: };
wt_val=1;
};
TessEl @[6] {
send_off {x=0: y=6: };
wt_val=1;
};
TessEl @[7] {
send_off {x=0: y=7: };
wt_val=1;
};
TessEl @[8] {
send_off {x=0: y=8: };
wt_val=1;
};
};
};
TesselPrjnSpec @[8] {
name="MotorCortex_NoGoStriatum";
desc=;
unique{ };
children {
name=;
el_typ=TesselPrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
recv_off {x=2: y=0: };
recv_n {x=-1: y=-1: };
recv_skip {x=1: y=1: };
recv_group {x=1: y=9: };
wrap=1;
send_scale {x=1: y=1: };
send_border {x=0: y=0: };
send_offs {
name=;
el_typ=TessEl;
el_def=0;
TessEl @[0] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[1] {
send_off {x=0: y=0: };
wt_val=1;
};
TessEl @[2] {
send_off {x=0: y=2: };
wt_val=1;
};
TessEl @[3] {
send_off {x=0: y=3: };
wt_val=1;
};
};
};
OneToOnePrjnSpec @[9] {
name="OneToOne_2";
desc=;
unique{ self_con;};
children {
name=;
el_typ=OneToOnePrjnSpec;
el_def=0;
};
self_con=0;
init_wts=0;
n_conns=-1;
recv_start=0;
send_start=2;
};
};
BaseSpec_Group @.gp[1] {
name="Connections";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraBiasSpec @[0] {
name="LearnBias";
desc=;
unique{ rnd;wt_limits;wt_scale;wt_scale_init;};
children {
name=;
el_typ=LeabraBiasSpec;
el_def=0;
LeabraBiasSpec @[0] {
name="FixedBias";
desc=;
unique{ lrate;wt_limits;wt_scale;wt_scale_init;};
children {
name=;
el_typ=LeabraBiasSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
wt_limits {type=NONE: min=-1: max=5: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0: err=1: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
dwt_thresh=0.1;
};
};
rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
wt_limits {type=NONE: min=-1: max=5: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.01;
cur_lrate=0.01;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0: err=1: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
dwt_thresh=0.1;
};
LeabraConSpec @[1] {
name="FixedFull";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=3: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[2] {
name="GPeGPiInhib";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
LeabraConSpec @[0] {
name="ThalInhib";
desc=;
unique{ wt_scale;wt_sig;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=1: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[1] {
name="Inhib_Learn";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.35: var=0.1: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=8: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=1e-05;
cur_lrate=1e-05;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=1.75: rel=1.5: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[3] {
name="Fixed";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
LeabraConSpec @[0] {
name="STNcons";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.21: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=0.7: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[1] {
name="MotorCortex_Striatum";
desc=;
unique{ rnd;wt_limits;wt_scale;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.06: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=0;
wt_scale {abs=1: rel=1.5: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[2] {
name="Motor_NoGo";
desc="additional excitability for striatopallidal neurons (e.g, Beretta et al, 1997; Lei et al, 2004) )";
unique{ rnd;wt_limits;wt_scale;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.06: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=0;
wt_scale {abs=1: rel=0.5: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[3] {
name="Input_Motor_Prepotent_";
desc=;
unique{ rnd;wt_scale;lrate;lmix;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.35: var=0.005: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=3: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=1e-06;
cur_lrate=1e-06;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=1: err=0: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[4] {
name="InputStriatum";
desc=;
unique{ rnd;wt_scale;lrate;savg_cor;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.001;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.001: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[5] {
name="STN_GPi";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0.21: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=0.55: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=1e-04;
cur_lrate=1e-04;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[6] {
name="Mtr_STNcons";
desc=;
unique{ rnd;wt_scale;lrate;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.65: var=0.2: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=2: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
rnd {name="": type=UNIFORM: mean=0.1: var=0.01: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=1: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0.001;
cur_lrate=0.0075;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[4] {
name="Dopamine_D1_";
desc=;
unique{ rnd;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.5: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=0;
wt_scale {abs=0.5: rel=1: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[5] {
name="SNc_Inhib_D2_";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=1: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=0: };
inhib=1;
wt_scale {abs=0.5: rel=0.75: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=0.4: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
LeabraConSpec @[6] {
name="Inhib";
desc=;
unique{ rnd;inhib;};
children {
name=;
el_typ=LeabraConSpec;
el_def=0;
};
rnd {name="": type=UNIFORM: mean=0.7: var=0: par=1: };
wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
inhib=1;
wt_scale {abs=3: rel=2.25: };
wt_scale_init {init=0: abs=1: rel=1: };
wt_sig {gain=6: off=1.25: };
lrate=0;
cur_lrate=0;
lrs_value=EPOCH;
lrate_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=0;
cur_val=0;
};
lmix {hebb=0.01: err=0.99: err_sb=1: };
savg_cor {cor=1: thresh=0.01: norm_con_n=0: };
rel_net_adapt {
on=0;
trg_fm_input=0.85;
trg_fm_output=0.15;
trg_lateral=0;
trg_sum=1;
tol_lg=0.05;
tol_sm=0.2;
rel_lrate=0.1;
};
};
};
BaseSpec_Group @.gp[2] {
name="Units";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="FixedBiasUnitSpec";
desc=;
unique{ opt_thresh;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="GPExt_UnitSpec";
desc=;
unique{ bias_spec;act;opt_thresh;v_m_init;dt;g_bar;e_rev;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0].children[0]$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.26: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=2.5: h=0.1: a=0.5: };
e_rev {e=1: l=0.255: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="OutputUnitSpec";
desc=;
unique{ bias_spec;act;opt_thresh;g_bar;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.2: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[2] {
name="Thalamus";
desc=;
unique{ bias_spec;opt_thresh;dt;g_bar;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.4: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=0.5: l=0.07: i=1.7: h=0.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[3] {
name="LearnBiasUnitSpec";
desc=;
unique{ bias_spec;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
LeabraUnitSpec @[0] {
name="matrisom_unitspec";
desc=;
unique{ bias_spec;act;opt_thresh;g_bar;act_reg;noise_type;noise;dt;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.26: gain=10000: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.5: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=1: min=0.001: max=0.35: wt_dt=0.1: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=VM_NOISE;
noise {name="": type=GAUSSIAN: mean=0.001: var=0: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="Motor_Cortex_unitspec";
desc=;
unique{ bias_spec;opt_thresh;dt;acc;noise_type;noise;noise_sched;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.05: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.005: b_dec_dt=0.01: a_thr=0.25: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=VM_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.0015: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
SchedItem @[0] {
start_ctr=0;
start_val=1;
duration=25;
step=0;
};
SchedItem @[1] {
start_ctr=25;
start_val=1;
duration=55;
step=-0.009090909;
};
SchedItem @[2] {
start_ctr=80;
start_val=0.5;
duration=20;
step=-0.015;
};
SchedItem @[3] {
start_ctr=100;
start_val=0.2;
duration=1;
step=1;
};
};
};
LeabraUnitSpec @[2] {
name="STN_unitspec";
desc=;
unique{ bias_spec;act;opt_thresh;v_m_init;dt;g_bar;e_rev;noise_type;noise;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.25: var=0: par=1: };
dt {vm=0.045: net=0.17: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=1: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.2: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=.projects[0].networks[0].specs.gp[1][0]$158$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[4] {
name="GPInt_UnitSpec";
desc=;
unique{ bias_spec;opt_thresh;v_m_init;dt;g_bar;e_rev;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.26: var=0: par=1: };
dt {vm=0.2: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=3: i=1: h=0.1: a=0.5: };
e_rev {e=1: l=0.275: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.1: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NO_NOISE;
noise {name="": type=GAUSSIAN: mean=0: var=0.001: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
LeabraUnitSpec @[1] {
name="SNc_UnitSpec";
desc=;
unique{ opt_thresh;};
children {
name=;
el_typ=LeabraUnitSpec;
el_def=0;
};
act_range {min=0: max=1: range=1: scale=1: };
bias_con_type=LeabraCon;
bias_spec {type=LeabraBiasSpec: spec=$157$: };
sse_tol=0.5;
act_fun=NOISY_XX1;
act {thr=0.25: gain=100: nvar=0.005: avg_dt=0.005: i_thr=STD: };
spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
opt_thresh {send=0.1: delta=0.005: learn=0: updt_wts=0: phase_dif=0: };
clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
vm_range {min=0: max=1: range=1: scale=1: };
v_m_init {name="": type=UNIFORM: mean=0.15: var=0: par=1: };
dt {vm=0.95: net=1: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
g_bar {e=1: l=0.1: i=1: h=1.2: a=0.5: };
e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=1: trl=0: };
acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
act_reg {on=0: min=0.001: max=0.35: wt_dt=0.2: };
maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
noise_type=NETIN_NOISE;
noise {name="": type=GAUSSIAN: mean=0.0015: var=0.002: par=1: };
noise_sched {
name=;
el_typ=SchedItem;
el_def=0;
last_ctr=-1;
default_val=1;
interpolate=1;
cur_val=0;
};
};
};
BaseSpec_Group @.gp[3] {
name="LayerSpecs";
el_typ=LeabraUnitSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="LayerSpec_0";
desc=;
unique{ kwta;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="Matrisome_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;clamp;decay;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="GP_layerspec";
desc=;
unique{ kwta;compute_i;i_kwta_pt;clamp;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=0: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[2] {
name="Thalamus_layerspec";
desc=;
unique{ kwta;compute_i;decay;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[3] {
name="Output_layerspec";
desc=;
unique{ kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[4] {
name="PFC_Out_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=LAY_AND_GPS;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[5] {
name="InputLayer";
desc=;
unique{ kwta;compute_i;i_kwta_pt;clamp;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.25;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[6] {
name="SNc_layerspec";
desc=;
unique{ kwta;compute_i;clamp;inhib;decay;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=0: gain=0.5: d_gain=0: };
decay {event=1: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=3: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="NoDecayLayers";
desc=;
unique{ };
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
LeabraLayerSpec @[0] {
name="STN";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=ENTIRE_LAYER;
inhib {
type=UNIT_INHIB;
kwta_pt=0.5;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=2: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
LeabraLayerSpec @[1] {
name="PFCIn_layerspec";
desc=;
unique{ kwta;gp_kwta;inhib_group;compute_i;i_kwta_pt;inhib;};
children {
name=;
el_typ=LeabraLayerSpec;
el_def=0;
};
inhib_group=LAY_AND_GPS;
inhib {
type=KWTA_AVG_INHIB;
kwta_pt=0.6;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=5: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
inhib_group=ENTIRE_LAYER;
inhib {
type=KWTA_INHIB;
kwta_pt=0.25;
min_i=0;
comp_thr=0.5;
comp_gain=2;
gp_pt=0.2;
};
kwta {k_from=USE_K: k=1: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
tie_brk {on=0: k_thr=1: diff_thr=0.2: };
adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
clamp {hard=1: gain=0.5: d_gain=0: };
decay {event=0: phase=0: phase2=0: clamp_phase2=0: };
net_rescale {on=0: max_net=0.8: net_extra=0.2: };
abs_net_adapt {
on=0;
trg_net=0.5;
tol=0.1;
abs_lrate=0.1;
};
};
};
};
layers {
name=;
el_typ=LeabraLayer;
el_def=0;
pos {x=0: y=0: z=0: };
LeabraLayer @[0] {
name="Input";
flags=;
layer_type=INPUT;
pos {x=1: y=0: z=2: };
un_geom {x=5: y=5: n_not_xy=0: n=25: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=5: y=5: n_not_xy=0: n=25: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[0];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[6].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=5: y=5: n_not_xy=0: n=25: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0]$159$: };
ext_flag=EXT;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=-1: };
i_thrs {avg=0: max=0: max_i=-1: };
acts {avg=0.1524: max=0.95: max_i=1: };
acts_p {avg=0.1524: max=0.95: max_i=0: };
acts_m {avg=0.1524: max=0.95: max_i=1: };
phase_dif_ratio=1;
kwta {k=1: pct=0.04: pct_c=0.96: adth_k=1: k_ithr=-0.1: k1_ithr=-0.1: ithr_r=0: ithr_diff=-0: tie_brk=0: };
i_val {kwta=0: g_i=0.25: gp_g_i=0: g_i_orig=0.25: };
un_g_i {avg=0: max=0: max_i=-1: };
adapt_i {avg_avg=0.04: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[5]$160$: };
stm_gain=0.5;
hard_clamped=1;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[1] {
name="Striatum";
flags=;
layer_type=HIDDEN;
pos {x=1: y=0: z=1: };
un_geom {x=4: y=9: n_not_xy=0: n=36: };
unit_groups=0;
gp_geom {x=2: y=2: n_not_xy=0: n=4: };
gp_spc {x=0: y=0: };
act_geom {x=4: y=9: n_not_xy=0: n=36: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Input";
from_type=CUSTOM;
from=.projects[0].networks[0].layers[0]$161$;
spec {type=FullPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][0]$162$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[4]$163$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_SNc";
from_type=CUSTOM;
from=$33$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][4]$164$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][4]$165$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[2] {
name="Fm_SNc";
from_type=CUSTOM;
from=$33$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][6]$166$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][5]$167$: };
recv_idx=2;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[3] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$103$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][8]$168$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[2]$169$: };
recv_idx=3;
send_idx=4;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[4] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$103$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][5]$170$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[1]$171$: };
recv_idx=4;
send_idx=5;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[0];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=4: y=9: n_not_xy=0: n=36: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=$35$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="Go-R1";
sse=0;
icon_value=0;
netin {avg=0.7747682: max=1.030549: max_i=13: };
i_thrs {avg=4.212078: max=5.932788: max_i=13: };
acts {avg=0.1275352: max=0.9299284: max_i=13: };
acts_p {avg=0.1216748: max=0.8779461: max_i=14: };
acts_m {avg=0.1322549: max=0.9374449: max_i=13: };
phase_dif_ratio=1.086954;
kwta {k=3: pct=0.08333334: pct_c=0.9166667: adth_k=1: k_ithr=5.545918: k1_ithr=5.498456: ithr_r=0.008595021: ithr_diff=0.008558175: tie_brk=0: };
i_val {kwta=5.522187: g_i=5.522187: gp_g_i=0: g_i_orig=5.522187: };
un_g_i {avg=5.522187: max=5.522187: max_i=0: };
adapt_i {avg_avg=0.08439671: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[0]$172$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[2] {
name="SNc";
flags=;
layer_type=INPUT;
pos {x=2: y=0: z=0: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[1].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[1].projections[2];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][1]$173$: };
ext_flag=EXT;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0.5023195: max=0.5046904: max_i=2: };
i_thrs {avg=3.667396: max=3.685178: max_i=2: };
acts {avg=0.9642563: max=0.9647754: max_i=2: };
acts_p {avg=0: max=0: max_i=0: };
acts_m {avg=0.6569424: max=0.7015973: max_i=2: };
phase_dif_ratio=1;
kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=0: };
adapt_i {avg_avg=0.25: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[6]$174$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[3] {
name="GP_Int";
flags=;
layer_type=HIDDEN;
pos {x=6: y=0: z=0: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Striatum";
from_type=CUSTOM;
from=$36$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][7]$175$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2].children[1]$176$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_GP_Ext";
from_type=CUSTOM;
from=$106$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][2]$177$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2]$178$: };
recv_idx=1;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[2] {
name="Fm_STN";
from_type=CUSTOM;
from=$102$;
spec {type=FullPrjnSpec: spec=$162$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[5]$179$: };
recv_idx=2;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[5].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[4]$180$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R2";
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=0: };
i_thrs {avg=0.7500002: max=0.7500002: max_i=0: };
acts {avg=1.296329e-06: max=4.651301e-06: max_i=2: };
acts_p {avg=0.9301407: max=0.9393933: max_i=1: };
acts_m {avg=6.038569e-07: max=2.171804e-06: max_i=2: };
phase_dif_ratio=6.492103e-07;
kwta {k=1: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=1.09251: k1_ithr=1.09251: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=1.516062: max=1.65267: max_i=1: };
adapt_i {avg_avg=0.2657997: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=3: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[1]$181$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[4] {
name="GP_Ext";
flags=;
layer_type=HIDDEN;
pos {x=6: y=4: z=0: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Striatum";
from_type=CUSTOM;
from=$36$;
spec {type=TesselPrjnSpec: spec=$177$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][6]$182$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_STN";
from_type=CUSTOM;
from=$102$;
spec {type=UniformRndPrjnSpec: spec=.projects[0].networks[0].specs[1]$183$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[0]$184$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[8].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[0]$185$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=0: max=0: max_i=0: };
i_thrs {avg=0.04999996: max=0.04999996: max_i=0: };
acts {avg=0.7425114: max=0.7425114: max_i=0: };
acts_p {avg=0.4876397: max=0.9752793: max_i=1: };
acts_m {avg=0.8743705: max=0.9380304: max_i=1: };
phase_dif_ratio=1.793067;
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0.0999999: k1_ithr=0.0999999: ithr_r=0: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0: max=0: max_i=0: };
adapt_i {avg_avg=0.5344471: i_kwta_pt=0.5: g_bar_i=2.5: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=$181$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[5] {
name="Thalamus";
flags=;
layer_type=HIDDEN;
pos {x=12: y=0: z=1: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_GP_Int";
from_type=CUSTOM;
from=$105$;
spec {type=TesselPrjnSpec: spec=.projects[0].networks[0].specs.gp[0][3]$186$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][2].children[0]$187$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$103$;
spec {type=TesselPrjnSpec: spec=$186$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][1]$188$: };
recv_idx=1;
send_idx=3;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[6].projections[0];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[2]$189$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=0;
icon_value=0;
netin {avg=0.1380519: max=0.1714462: max_i=1: };
i_thrs {avg=0.9653895: max=1.215847: max_i=1: };
acts {avg=0.9566307: max=0.967977: max_i=1: };
acts_p {avg=0.4942285: max=0.988457: max_i=0: };
acts_m {avg=0.95355: max=0.9633654: max_i=1: };
phase_dif_ratio=1.929371;
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=0.979331: k1_ithr=0.746659: ithr_r=0.271261: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0.002674219: max=0.003352535: max_i=0: };
adapt_i {avg_avg=0.4995306: i_kwta_pt=0.6: g_bar_i=1.7: g_bar_l=0.07: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[2]$190$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[6] {
name="Motor_Cortex";
flags=NO_ADD_SSE|NO_ADD_COMP_SSE;
layer_type=TARGET;
pos {x=10: y=0: z=2: };
un_geom {x=2: y=2: n_not_xy=0: n=4: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=2: n_not_xy=0: n=4: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Thalamus";
from_type=CUSTOM;
from=$104$;
spec {type=TesselPrjnSpec: spec=$186$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$188$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Input";
from_type=CUSTOM;
from=$161$;
spec {type=FullPrjnSpec: spec=$162$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[3]$191$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[5].projections[1];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[7].projections[0];
Projection_Group @. = [2] = LeabraPrjn .projects[0].networks[0].layers[7].projections[1];
Projection_Group @. = [3] = LeabraPrjn .projects[0].networks[0].layers[8].projections[0];
Projection_Group @. = [4] = LeabraPrjn .projects[0].networks[0].layers[1].projections[3];
Projection_Group @. = [5] = LeabraPrjn .projects[0].networks[0].layers[1].projections[4];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=2: n_not_xy=0: n=4: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[3].children[1]$192$: };
ext_flag=COMP;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name="R1";
sse=1.017237;
icon_value=0;
netin {avg=1.711112: max=1.721266: max_i=1: };
i_thrs {avg=12.73334: max=12.80949: max_i=1: };
acts {avg=0.4312379: max=0.5438744: max_i=1: };
acts_p {avg=0.4749474: max=0.9509749: max_i=0: };
acts_m {avg=0.3085942: max=0.3316119: max_i=3: };
phase_dif_ratio=0.649744;
kwta {k=3: pct=0.75: pct_c=0.25: adth_k=1: k_ithr=12.76135: k1_ithr=12.64934: ithr_r=0.008816009: ithr_diff=0.008777287: tie_brk=0: };
i_val {kwta=12.71654: g_i=12.71654: gp_g_i=0: g_i_orig=12.71654: };
un_g_i {avg=12.71654: max=12.71654: max_i=0: };
adapt_i {avg_avg=0.7299449: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0]$193$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[7] {
name="Output";
flags=;
layer_type=TARGET;
pos {x=8: y=6: z=2: };
un_geom {x=2: y=1: n_not_xy=0: n=2: };
unit_groups=0;
gp_geom {x=0: y=0: n_not_xy=0: n=0: };
gp_spc {x=0: y=0: };
act_geom {x=2: y=1: n_not_xy=0: n=2: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$103$;
spec {type=TesselPrjnSpec: spec=$175$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$188$: };
recv_idx=0;
send_idx=1;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$103$;
spec {type=OneToOnePrjnSpec: spec=.projects[0].networks[0].specs.gp[0][9]$194$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$188$: };
recv_idx=1;
send_idx=2;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=2: y=1: n_not_xy=0: n=2: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[1]$195$: };
ext_flag=TARG|EXT;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0.1640609: max=0.1858529: max_i=1: };
i_thrs {avg=1.624974: max=1.973647: max_i=1: };
acts {avg=0.475: max=0.95: max_i=1: };
acts_p {avg=0.475: max=0.95: max_i=1: };
acts_m {avg=0.5944706: max=0.9215024: max_i=1: };
phase_dif_ratio=1.251517;
kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=1.973647: k1_ithr=1.276301: ithr_r=0.4359168: ithr_diff=0.3533285: tie_brk=0: };
i_val {kwta=1.276301: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=1.276301: max=1.276301: max_i=0: };
adapt_i {avg_avg=0.4997218: i_kwta_pt=0: g_bar_i=1: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][0].children[3]$196$: };
stm_gain=0.5;
hard_clamped=1;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
LeabraLayer @[8] {
name="STN";
flags=;
layer_type=HIDDEN;
pos {x=7: y=1: z=1: };
un_geom {x=3: y=3: n_not_xy=0: n=9: };
unit_groups=0;
gp_geom {x=2: y=1: n_not_xy=0: n=2: };
gp_spc {x=0: y=0: };
act_geom {x=3: y=3: n_not_xy=0: n=9: };
projections {
name=;
el_typ=LeabraPrjn;
el_def=0;
LeabraPrjn @[0] {
name="Fm_Motor_Cortex";
from_type=CUSTOM;
from=$103$;
spec {type=FullPrjnSpec: spec=$162$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=.projects[0].networks[0].specs.gp[1][3].children[6]$197$: };
recv_idx=0;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
LeabraPrjn @[1] {
name="Fm_GP_Ext";
from_type=CUSTOM;
from=$106$;
spec {type=UniformRndPrjnSpec: spec=.projects[0].networks[0].specs[2]$198$: };
con_type=LeabraCon;
recvcons_type=LeabraRecvCons;
sendcons_type=LeabraSendCons;
con_spec {type=LeabraConSpec: spec=$182$: };
recv_idx=1;
send_idx=0;
recv_n=1;
send_n=1;
projected=1;
direction=DIR_UNKNOWN;
netin_avg=0;
netin_rel=0;
avg_netin_avg=0;
avg_netin_avg_sum=0;
avg_netin_rel=0;
avg_netin_rel_sum=0;
avg_netin_n=0;
trg_netin_rel=-1;
};
};
send_prjns {
name=;
el_typ=LeabraPrjn;
el_def=0;
Projection_Group @. = [0] = LeabraPrjn .projects[0].networks[0].layers[3].projections[2];
Projection_Group @. = [1] = LeabraPrjn .projects[0].networks[0].layers[4].projections[1];
};
units {
name=;
el_typ=LeabraUnit;
el_def=0;
pos {x=0: y=0: z=0: };
unique_geom=0;
geom {x=3: y=3: n_not_xy=0: n=9: };
units_lesioned=0;
output_name=;
};
unit_spec {type=LeabraUnitSpec: spec=.projects[0].networks[0].specs.gp[2][0].children[3].children[2]$199$: };
ext_flag=;
dmem_dist=DMEM_DIST_DEFAULT;
dist {
fm_input=-1;
fm_output=-1;
};
output_name=;
sse=0;
icon_value=0;
netin {avg=0.1214984: max=0.1307476: max_i=6: };
i_thrs {avg=0.4112383: max=0.4806072: max_i=6: };
acts {avg=1.114462e-10: max=9.643488e-10: max_i=6: };
acts_p {avg=0.4466626: max=0.9376455: max_i=8: };
acts_m {avg=0.001480459: max=0.01081026: max_i=6: };
phase_dif_ratio=0.003314491;
kwta {k=2: pct=0.2222222: pct_c=0.7777778: adth_k=1: k_ithr=1.60686: k1_ithr=1.38061: ithr_r=0.151759: ithr_diff=0: tie_brk=0: };
i_val {kwta=0: g_i=0: gp_g_i=0: g_i_orig=0: };
un_g_i {avg=0.8578771: max=0.8674246: max_i=1: };
adapt_i {avg_avg=0.2311887: i_kwta_pt=0.5: g_bar_i=1: g_bar_l=1: };
spec {type=LeabraLayerSpec: spec=.projects[0].networks[0].specs.gp[3][1].children[0]$200$: };
stm_gain=0.5;
hard_clamped=0;
dav=0;
net_rescale=1;
avg_netin {avg=0: max=0: max_i=-1: };
avg_netin_sum {avg=0: max=0: max_i=-1: };
avg_netin_n=0;
da_updt=0;
misc_iar{ };
};
};
view_objs {
name=;
el_typ=NetViewObj;
el_def=0;
};
flags=;
auto_build=AUTO_BUILD;
train_mode=TRAIN;
wt_update=ON_LINE;
small_batch_n=10;
batch=0;
epoch=0;
group=0;
trial=15;
tick=0;
cycle=9;
time=0;
group_name=;
trial_name="20vs80";
output_name=;
sse_unit_avg=0;
sse_sqrt=0;
sse=0;
sum_sse=1.985029;
avg_sse=0.9925144;
cnt_err_tol=0.75;
cnt_err=1;
cur_sum_sse=15.87744;
avg_sse_n=16;
cur_cnt_err=8;
train_time {name="train_time": start={usr=5582: sys=2067: tot=453980032: }: end={usr=183285: sys=118593: tot=453537015: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
epoch_time {name="epoch_time": start={usr=5593: sys=2074: tot=453980051: }: end={usr=5593: sys=2074: tot=453980051: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
dmem_sync_level=DMEM_SYNC_NETWORK;
dmem_nprocs=1;
usr1_save_fmt=FULL_NET;
wt_save_fmt=TEXT;
lay_layout=THREE_D;
n_units=88;
n_cons=1427;
max_size {x=14: y=9: z=3: };
font_sizes {
net_name=0.05;
net_vals=0.05;
layer=0.04;
layer_vals=0.03;
prjn=0.01;
unit=0.02;
un_nm_len=3;
};
view_params {
xy_square=0;
unit_spacing=0.05;
prjn_disp=L_R_F;
prjn_name=0;
prjn_width=0.002;
prjn_trans=0.5;
lay_trans=0.5;
unit_trans=0.6;
};
phase_order=MINUS_PLUS;
no_plus_test=1;
trial_init=DECAY_STATE;
sequence_init=DO_NOTHING;
first_plus_dwt=ONLY_FIRST_DWT;
phase=PLUS_PHASE;
nothing_phase=0;
phase_no=1;
phase_max=2;
cycle_max=20;
min_cycles=15;
min_cycles_phase2=35;
minus_cycles=100;
avg_cycles=100;
avg_cycles_sum=1600;
avg_cycles_n=16;
netin_mod=1;
send_delta=0;
send_pct=0.3442623;
send_pct_n=21;
send_pct_tot=61;
avg_send_pct=0.4006349;
avg_send_pct_sum=741.4404;
avg_send_pct_n=1910;
maxda_stopcrit=0.005;
maxda=0.3145979;
trg_max_act_stopcrit=1;
trg_max_act=0;
ext_rew=0;
avg_ext_rew=0;
avg_ext_rew_sum=0;
avg_ext_rew_n=0;
};
};
};
